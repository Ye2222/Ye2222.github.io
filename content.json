{"meta":{"title":"Yeの博客","subtitle":"记录生活中的点点滴滴","description":"欢迎欢迎","author":"GuoYB","url":"https://ye2222.github.io","root":"/"},"pages":[{"title":"about","date":"2021-09-10T00:19:03.000Z","updated":"2023-04-15T07:41:22.613Z","comments":true,"path":"about/index.html","permalink":"https://ye2222.github.io/about/index.html","excerpt":"","text":"Thanks all"},{"title":"资料","date":"2022-04-11T06:40:31.000Z","updated":"2022-05-04T07:05:18.696Z","comments":true,"path":"book/index.html","permalink":"https://ye2222.github.io/book/index.html","excerpt":"","text":"Image_translation.pdf"},{"title":"categories","date":"2021-09-09T16:26:33.000Z","updated":"2022-01-10T02:37:54.397Z","comments":true,"path":"categories/index.html","permalink":"https://ye2222.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-11T06:45:21.000Z","updated":"2022-01-10T02:37:54.398Z","comments":true,"path":"tags/index.html","permalink":"https://ye2222.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深度学习汇总","slug":"深度学习汇总","date":"2023-05-28T07:03:20.000Z","updated":"2023-05-28T07:23:29.781Z","comments":true,"path":"posts/113347930/","link":"","permalink":"https://ye2222.github.io/posts/113347930/","excerpt":"","text":"深度学习 统计学习方法 L1：统计学习的基本概念 L2：感知机 未完... 李宏毅深度学习 L1：机器学习的基本任务和基本概念 L2：机器学习的模型调整，Critical point，Batch, Momentum, Optimization L3：卷积神经网络(CNN)，自注意力(Self-attention)机制，循环神经网络(RNN)，Transfomer L4：GAN 未完...","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"统计学习方法L2","slug":"统计学习方法L2","date":"2023-04-15T06:23:15.000Z","updated":"2023-04-26T11:19:54.822Z","comments":true,"path":"posts/12759/","link":"","permalink":"https://ye2222.github.io/posts/12759/","excerpt":"","text":"感知机（perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取+1和-1二值 感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面，属于判别模型 感知机旨在求出训练数据进行线性划分的分离超平面 为此，导入基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型 感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式 感知机预测是用学习得到的感知机模型对新的输入实例进行分类 本章内容 介绍感知机模型 叙述感知机的学习策略，特别是损失函数 介绍感知机学习算法，包括原始形式和对偶形式，并证明算法的收敛性 2.1 感知机模型 定义：假设输入空间（特征空间）是\\(\\chi \\subseteq R^n\\)，输出空间是\\(\\gamma = \\{+1, -1\\}\\) 输入\\(x \\in \\chi\\)表示实例的特征向量，对应于输入空间（特征空间） 输出\\(y \\in \\gamma\\)表示实例的类别 由输入空间到输出空间的如下函数称为感知机 \\[ f(x) = sign(w \\cdot x + b) \\] 其中，\\(w\\)和\\(b\\)为感知机模型参数，前者\\(w \\in R^n\\)为权值（weight）或权值向量（weight vector），后者\\(b \\in R\\)为偏置（bias），\\(w \\cdot x\\)表示\\(w\\)和\\(x\\)的内积 sign是符号函数，即 \\[ \\begin{align*} sign(x)= \\left \\{ \\begin{array}{ll} +1, &amp; x \\ge 0 \\\\ -1, &amp; x \\ &lt; 0 \\\\ \\end{array} \\right. \\end{align*} \\] 感知机是一种线性分类模型，属于判别模型 假设空间是定义在特征空间中的所有线性分类模型（linear classification model）或线性分类器（linear classifier），即函数集合\\(\\{f \\vert f(x)=w\\cdot x + b \\}\\) 几何解释 对于线性方程\\(w\\cdot x+b = 0\\) 对应于特征空间\\(R^n\\)中的一个超平面\\(S\\)，其中\\(w\\)是超平面的法向量，\\(b\\)是超平面的截距 这个超平面将特征空间划分为两个部分 位于两部分的点（特征向量）分别被分为正、负两类 因此，超平面\\(S\\)被称为分离超平面（separating hyperplane） 感知机学习 由训练数据集（实例的特征向量及类别） \\[ T= \\{(x_1,y_1), (x_2,y_2),\\dots,(x_N, y_N)\\} \\] 其中，\\(x_i \\in \\chi = R^n, y_i\\in \\gamma= \\{+1,-1\\}, i=1,2,\\dots,N\\)，即求得模型参数\\(w, b\\)。 感知机预测 通过学习得到的感知机模型，对于新的输入实例给出其对应的输出类别 2.2 感知机学习策略 数据集的线性可分性 给定训练数据集（实例的特征向量及类别） \\[ T= \\{(x_1,y_1), (x_2,y_2),\\dots,(x_N, y_N)\\} \\] 其中，\\(x_i \\in \\chi = R^n, y_i\\in \\gamma= \\{+1,-1\\}, i=1,2,\\dots,N\\) 如果存在某个超平面S：\\(w \\cdot x + b = 0\\)能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧 则称数据集\\(T\\)为线性可分数据集（linearly separable data set），否则称数据集\\(T\\)线性不可分 感知机学习策略 我们需要确定一个学习策略，即定义（经验）损失函数并将损失函数极小化 损失函数的一个自然选择是误分类点的总数 但是，这样的损失函数不是参数\\(w,b\\)的连续可导函数，不易优化 损失函数的另一个选择是误分类点到超平面\\(S\\)的总距离，这是感知机所采用的 输入空间中任一点\\(x_0\\)到超平面\\(S\\)的距离是 \\[ \\frac{1}{||w||}|w \\cdot x_0 + b | \\] \\(||w||\\)是\\(w\\)的\\(L_2\\)范数 对于误分类的数据\\((x_i, y_i)\\)来说 ，\\(-y_i(w \\cdot x_i + b) &gt; 0\\)成立 误分类点\\(x_i\\)到超平面\\(S\\)的距离是 \\[ -\\frac{1}{||w||}y_i(w \\cdot x_i + b) \\] 所有误分类点（记为M）到超平面\\(S\\)的总距离为 \\[ -\\frac{1}{||w||}\\sum_{x_i \\in M}y_i(w \\cdot x_i + b) \\] 不考虑\\(\\frac{1}{||w||}\\)，就可以得到感知机学习的损失函数 \\[ L(w,b) = - \\sum_{x_i \\in M}y_i(w \\cdot x_i + b) \\] 显然，损失函数\\(L(w,b)\\)是非负的 如果没有误分类点，损失函数值是0 误分类点越少，误分类点离超平面越近，损失函数值就越小 一个特定的样本点的损失函数： 在误分类时是参数\\(w,b\\)的线性函数 在正确分类时是0 因此，给定训练数据集\\(T\\)，损失函数\\(L(w,b)\\)是\\(w,b\\)的连续可导函数 2.3 感知机学习算法 感知机学习问题最优化的方法是随机梯度下降法 感知机学习算法的原始形式 损失函数最小化问题的解 \\[ \\min_{w,b}L(w,b) = - \\sum_{x_i \\in M}y_i(w \\cdot x_i + b) \\] 感知机学习算法是误分类驱动的，具体采用随机梯度下降法（stochastic gradient descent） 首先，任意选取一个超平面\\(w_0,b_o\\) 然后用梯度下降法不断地极小化目标函数，即上面的式子 极小化过程中不是一次使M中所有误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降 损失函数\\(L(w,b)\\)的梯度由下面式子给出（假设误分类点集合\\(M\\)是固定的） \\[ \\bigtriangledown_wL(w,b) = -\\sum_{x_i \\in M}y_ix_i \\\\ \\bigtriangledown_bL(w,b) = -\\sum_{x_i \\in M}y_i \\] 随机选取一个误分类点\\((x_i, y_i)\\)，对\\(w,b\\)进行更新 \\[ w \\leftarrow w + \\eta y_ix_i \\\\ b \\leftarrow b + \\eta y_i \\] 其中，\\(\\eta\\)是步长，在统计学习中又称为学习率（learning rate） 这样通过迭代可以期待损失函数\\(L(w,b)\\)不断减小，直到为0 算法如下： 该算法有如下解释： 当一个实例点被误分类，即位于分离超平面的错误一侧时，则调整\\(w,b\\)的值，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面间的距离，直到超平面越过该误分类点使其被正确分类 算法的收敛性 证明，对于线性可分数据集感知机学习算法原始形式收敛，即经过有限次迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型 定理表明，误分类的次数\\(k\\)是有上限的，经过有限次搜索可以找到训练数据完全正确分开的分离超平面。 即，当训练数据集线性可分时，感知机学习算法原始形式迭代是收敛的 当训练集线性不可分时，感知机学习算法不收敛，迭代结果会发生震荡 感知机学习算法的对偶形式 对偶形式的基本想法：将\\(w\\)和\\(b\\)表示为实例\\(x_i\\)和标记\\(y_i\\)的线性组合的形式，通过求解其系数而求得\\(w\\)和\\(b\\) 对误分类点\\((x_i, y_i)\\)通过 \\[ w \\leftarrow w + \\eta y_ix_i \\\\ b \\leftarrow b + \\eta y_i \\] 逐步修改\\(w, b\\)，设修改\\(n\\)次，则\\(w, b\\)关于\\((x_i, y_i)\\)的增量分别是\\(\\alpha_iy_ix_i\\)和\\(\\alpha_iy_i\\)，这里的\\(\\alpha_i = n_i\\eta\\) 这样可以看出，学习到的\\(w, b\\)可以分别表示为 \\[ w = \\sum_{i=1}^N\\alpha_iy_ix_i \\\\ b = \\sum_{i=1}^N\\alpha_iy_i \\] 注意，这里的点对是误分类点，关于\\((x_i, y_i)\\)这个点对$w, b $进行修改 \\(\\alpha_i &gt; 0 , i = 1, 2, \\dots, N\\)，当\\(\\eta\\)等于1时，表示第\\(i\\)个实例点由于误分而进行更新的次数 实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分类，换句话说，这样的实例对学习结果影响最大 算法如下： \\(w\\)用\\(\\sum_{j=1}^N \\alpha_jy_jx_j\\)表示，更新\\(\\alpha\\)和\\(b\\) 对偶形式中训练实例仅以内积的形式出现 为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的\\(Gram\\)矩阵（Gram matrix） \\[ G = [x_i \\cdot x_j]_{N \\times N} \\] 例子 本章概要 习题 \\(x\\) \\(y\\) \\(x \\oplus y\\) 0 0 0 1 0 1 0 1 1 1 1 0 XOR表示的区域是对角是相同的输出，但是一根线，也就是一个超平面无法做出这样的划分","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://ye2222.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"统计学习方法","slug":"机器学习/统计学习方法","permalink":"https://ye2222.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}],"tags":[]},{"title":"64位系统--BootLoader","slug":"64位系统--bootloader","date":"2023-04-13T11:36:51.000Z","updated":"2023-04-26T11:19:54.623Z","comments":true,"path":"posts/48218/","link":"","permalink":"https://ye2222.github.io/posts/48218/","excerpt":"","text":"BootLoader引导启动程序原本由Boot引导程序和Loader引导加载程序两部分构成。 Boot引导程序主要负责开机启动和加载Loader程序 Loader引导加载程序则用于完成配置硬件工作环境、引导加载内核等任务 Boot引导程序 计算机上电启动后，首先会经过BIOS上电自检，这个过程BIOS会 检测硬件设备是否存在问题 如检测无误，将根据BIOS的启动项配置选择引导设备 目前BIOS支持的设备启动项有软盘启动、U盘启动、硬盘启动以及网络启动 默认选择硬盘启动 从简单和易实现等角度看，我们选择最为简单的软盘行动 BIOS引导原理 为什么所有操作系统都从Boot引导程序开始？ 当BIOS自检设备结束后，会根据启动选项设置（此处指软驱启动）去选择启动设备 即检查软盘的第0磁头第0磁道第1扇区，是否以数值0x55和0xaa两字节作为结尾 如果是，那么BIOS认为这个扇区是一个Boot Sector（引导扇区），进而把此扇区的数据复制到物理内存地址0x7c00处，随后将处理器的执行权移交给这段程序，即跳转至0x7c00地址处执行","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/categories/Linux/"},{"name":"一个64位的系统","slug":"Linux/一个64位的系统","permalink":"https://ye2222.github.io/categories/Linux/%E4%B8%80%E4%B8%AA64%E4%BD%8D%E7%9A%84%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/tags/Linux/"}]},{"title":"64位系统--GNU_C","slug":"64位系统--GNU_C","date":"2023-04-13T11:31:51.000Z","updated":"2023-04-26T11:19:54.619Z","comments":true,"path":"posts/7112/","link":"","permalink":"https://ye2222.github.io/posts/7112/","excerpt":"","text":"GNU C内嵌汇编语言 GNU C语言提供了关键字asm来声明代码是内嵌的汇编语句 如： 1#define nop() __asm__ __volatile__ (&quot;nop \\n\\t&quot;) C语言使用关键字__asm__和__volatile__对汇编语句进行修饰，这两个关键字在C语言内嵌汇编语句时经常使用 __asm__：用于声明这行代码是一个内嵌汇编表达式 __volatile__：其作用是告诉编译器此行代码不能被编译器优化 GNU C语言有着极其复杂的书写格式，将分为3个部分学习 内嵌汇编表达式 操作约束和修饰符 序号占位符 内嵌汇编表达式 GNU C语言的内嵌汇编表达式由4部分构成，它们之间使用“:”号分割，其完整格式为 指令部分 : 输出部分 : 输入部分 : 损坏部分 如果将内嵌汇编表达式当作函数，指令部分是函数中的代码，输入部分用于向函数传入参数，输出部分可理解为函数的返回值。 4个部分的详细解释： 损坏部分的3种通知： 寄存器修改通知 内存修改通知 标志寄存器修改通知 操作约束和修饰符 每个输入，可细分为： 寄存器约束 内存约束 立即数约束 在输出表达式中，还有限定寄存器操作的修饰符 详细解释： 修饰符 &amp; 序号占位符 定义：是输入/输出操作约束的数值映射 每个内嵌汇编表达式最多只有10条输入/输出约束，这些约束按照书写顺序依次被映射为序号0~9 如果指令部分想引用序号占位符，必须使用百分号%前缀加以修饰 如%0表示第一个操作约束 为了区分序号占位符和寄存器，特别使用两个百分号（%%）来对寄存器加以修饰 在%与序号占位符之间插入字母b表示操作最低字节，或插入字母h表示操作次低字节 GNU C语言对标准C语言的扩展 GNU C语言在标准C语言的基础上引入了诸多人性化的扩展 柔性数组成员（或称零长数组、变长数组 ） GNU C语言允许使用长度为0的数组来增强结构体的灵活性，其在动态创建结构体时有着非常明显的优势 case关键字支持范围匹配 GNU C语言允许case关键字匹配一个数值范围，由此可以取代多级的if条件检测语句 12case &#x27;a&#x27;...&#x27;z&#x27;:break; typeof关键字获取变量类型 借助关键字typeof(x)可以取得变量x的数据类型 可变参数宏 在GNU C语言中宏函数允许使用可变参数类型 元素编号 标准C语言规定数组和结构体必须按照固定顺序对成员（或元素）进行初始化赋值 GNU C语言为使数组和结构体初始化更加自由，特意放宽该限制 数组可以在初始化期间借助下标对某些元素进行赋值，并在结构体初始化过程中使用成员名直接对成员进行赋值 允许数组和结构体按照任意顺序对成员（或元素）进行初始化赋值 当前函数名 为当前函数的名字准备了两个标识符 __PRETTY__FUNCTION__：保存着带有语言特色的名字 __FUNCTION__：保存着函数在源码中的名字 在C函数中，这两个标识符代表的函数名字相同 特殊属性声明 允许使用特殊属性对函数、变量和类型加以修饰，以便对它们进行手工代码优化和定制 在声明处加上关键字__attribute__((ATTRIBUTE))即可指定特殊属性 关键字中的ATTRIBUTE是属性说明 如有多个属性，必须用逗号隔开 目前支持的属性说明有 noreturn属性用来修饰函数，表示该函数从不返回，会使编译器在优化代码时剔除不必要的警告信息 packed属性作用是取消结构在编译时的对齐优化，使其按照实际占用字节数对齐 regparm(n)属性用于以指定寄存器传递参数的个数，该属性只能用在函数定义和声明里 寄存器参数的上限值为3（使用顺序为EAX、EDX、ECX），若超过3，剩余参数将使用内存传递方式 该属性只在x86处理器体系结构下有效","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/categories/Linux/"},{"name":"一个64位的系统","slug":"Linux/一个64位的系统","permalink":"https://ye2222.github.io/categories/Linux/%E4%B8%80%E4%B8%AA64%E4%BD%8D%E7%9A%84%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/tags/Linux/"}]},{"title":"统计学习方法L1","slug":"统计学习方法L1","date":"2023-04-11T07:56:41.000Z","updated":"2023-04-26T11:19:54.817Z","comments":true,"path":"posts/12439/","link":"","permalink":"https://ye2222.github.io/posts/12439/","excerpt":"","text":"第一章的主要内容 叙述统计学习的定义、研究对象和方法 叙述监督学习（本书的主要内容） 提出统计学习方法的三要素：模型、策略和算法 介绍模型选择，包括正则化、交叉验证与学习的泛化能力 介绍生成模型与判别模型 介绍监督学习方法的应用：分类问题、标注问题与回归问题 1.1 统计学习 统计学习的特点 定义：统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运 用模型对数据进行预测与分析的一门学科．统计学习也称为统计机器学习 (statistical machine learning） 主要特点： 统计学习以计算机及网络为平台，是建立在计算机及网络之上的 统计学习以数据为研究对象，是数据驱动的学科 统计学习的目的是对数据进行预测与分析 统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析 统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科，并且在发展中逐步形成独自的理论体系与方法论． 统计学习就是计算机系统通过运用数据及统计方法提高系统性能的机器学习. 现在，当人们提及机器学习时，往往是指统计机器学习． 统计学习的对象 很明显是数据，从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去 数据是多样的，包括存在于计算机及网络上的各种数字、文字、图像、视频、音频数据以及它们的组合． 统计学习的前提：同类数据具有一定的统计规律性，这里的同类数据是指具有某种共同性质的数据 由于具有统计规律性，所以可以用概率统计方法来加以处理。 比如，可以用随机变量描述数据中的特征，用概率分布描述数据的统计规律。 统计学习的目的 目的：用于对数据进行预测与分析，特别是对未知的新数据进行预测与分析 对数据的预测与分析是通过构建概率统计模型实现的 总的目标：考虑学习什么样的模型和如何学习模型，以使模型能对数据进行准确的预测与分析，同时也要考虑尽可能地提高学习效率 统计学习的方法 基于数据构建统计模型从而对数据进行预测与分析。 组成 监督学习（supervised learning） 非监督学习（unsupervised learning） 半监督学习（semi-supervised learning） 强化学习（reinforcement learning） 主要讨论监督学习，这种情况下的统计学习的方法概括如下： 从给定的、有限的、用于学习的训练数据（training data）集合出发，假设数据是独立同分布产生的 并且假设要学习的模型属于某个函数的集合，称为假设空间（hypothesis space） 应用某个评价准则（evaluation criterion），从假设空间中选取一个最优的模型，使它对已知训练数据及未知测试数据（test data）在给定的评价准则下有最优的预测 最优模型的选取由算法实现 统计学习方法包括模型的假设空间、模型选择的准则以及模型学习的算法 这个过程概括为三要素 模型（model） 策略（strategy） 算法（algorithm） 实现统计学习方法的步骤如下： （1）得到一个有限的训练数据集合； （2）确定包含所有可能的模型的假设空间，即学习模型的集合； （3）确定模型选择的准则，即学习的策略； （4）实现求解最优模型的算法，即学习的算法； （5）通过学习方法选择最优模型； （6）利用学习的最优模型对新数据进行预测或分析 统计学习的研究 包括三个方面 统计学习方法（statistical learning method） 旨在开发新的学习方法 统计学习理论（statistical learning theory） 研究在于探求统计学习方法的有效性与效率，以及统计学习的基本理论问题 统计学习应用（application of statistical learning） 主要考虑将统计学习方法应用到时机问题中取，解决实际问题 1.2 监督学习 监督学习的任务：学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测 基本概念 输入空间、特征空间与输出空间 将输入与输出所有可能取值的集合分别称为输入空间（input space）与输出空间（output space） 输入与输出空间可以是有限元素的集合，也可以是整个欧氏空间 输入空间与输出空间可以是同一个空间，也可以是不同的空间； 但通常输出空间远远小于输入空间． 每个具体的输入是一个实例（instance），通常由特征向量（feature vector）表示 所有特征向量存在的空间称为特征空间（feature space），特征空间的每一维对应于一个特征 有时假设输入空间与特征空间为相同的空间，对它们不予区分 有时假设输入空间与特征空间为不同的空间，将实例从输入空间映射到特征空间 模型实际上都是定义在特征空间上的 在监督学习过程中，将输入与输出看做是定义在输入（特征）空间与输出空间上的随机变量的取值 监督学习从训练数据（training data）集合中学习模型，对测试数据（test data）进行预测 训练数据由输入（或特征向量）与输出对组成，通常表示为 \\[ T = \\{(x_1, y_1), (x_2, y_2), \\dots , (x_N, y_N)\\} \\] 测试数据由相应的输入与输出对组成。 输入与输出对又称为样本（sample）或样本点 输入变量X和输出变量Y有不同的类型，可以是连续的，也可以是离散的 输入变量与输出变量均为连续变量的预测问题称为回归问题 输出变量为有限个离散变量的预测问题称为分类问题 输入变量与输出变量序列的预测问题称为标注问题 联合概率分布 监督学习假设输入与输出的随机变量X和Y遵循联合概率分布P(X, Y) \\(P(X, \\ Y)\\)表示分布函数，或者分布密度函数 注意：在学习过程中，假定这一联合概率分布存在，训练数据与测试数据被看作是依联合概率分布\\(P(X, \\ Y)\\)独立同分布产生的。 统计学习假设数据存在一定的统计规律，X 和Y 具有联合概率分布的假设就是监督学习关于 数据的基本假设． 假设空间 监督学习目的在于学习一个由输入到输出的映射，这一映射由模型来表示 模型属于由输入空间到输出空间的映射的集合，该集合就是假设空间（hypothesis space） 假设空间的确定意味着学习范围的确定 监督学习的模型可以是概率模型或非概率模型，由条件概率分布\\(P(Y|X)\\)或决策函数（decision function）\\(Y = f(X)\\)表示，随具体学习方法而定。 对具体的输入进行相应的输出预测时，写作\\(P(y|x)\\)或\\(y = f(x)\\) 问题的形式化 监督学习利用训练数据集学习一个模型，再用模型对测试样本集进行预测（prediction） 这个过程中需要训练数据集，而训练数据集往往是人工给出的，称为监督学习 监督学习分为学习和预测两个阶段，由学习系统与预测系统完成 如果这个模型有很好的预测能力，训练样本输出\\(y_i\\)和模型输出\\(f(x_i)\\)之间的差就应该足够小．学习系统通过不断的尝试，选取最好的模型，以便对训练数据集有足够好的预测，同时对未知的测试数据集的预测也有尽可能好的推广． 1.3 统计学习三要素 方法 = 模型 + 策略 + 算法 模型 在监督学习过程中，模型就是所要学习的条件概率分布或决策函数 模型的假设空间（hypothesis space）包含所有可能的条件概率分布或决策函数 例如，假设决策函数是输入变量的线性函数，那么模型的假设空间就是所有这些线性函数构成的函数集合 假设空间用\\(F\\)表示，假设空间可以定义为决策函数的集合 \\[ F = \\{f \\ | \\ Y \\ = \\ f(X) \\} \\] 其中，\\(X\\)和\\(Y\\)是定义在输入空间和输出空间上的变量 这时\\(F\\)通常是由一个参数向量决定的函数族 \\[ F = \\{f \\ | \\ Y \\ = \\ f_{\\theta}(X), \\ \\theta \\ \\in \\ R^n \\} \\] 参数向量\\(\\theta\\)取值于\\(n\\)维欧式空间\\(R^n\\)，称为参数空间（parameter space） 假设空间也可以定义为条件概率的集合 \\[ F = \\{ P \\ | \\ P(Y | X) \\} \\] 其中，\\(X\\)和\\(Y\\)是定义在输入空间和输出空间上的随机变量 这时\\(F\\)通常是由一个参数向量决定的条件概率分布族 \\[ F = \\{P \\ | \\ P_{\\theta}(Y |X), \\theta \\in R^n \\} \\] 参数向量\\(\\theta\\)取值于\\(n\\)维欧式空间\\(R^n\\)，称为参数空间（parameter space） 本书称由决策函数表示的模型为非概率模型，由条件概率表示的模型为概率模型 策略 有了模型的假设空间，统计学习接着要考虑的是按照什么样的准则学习或选择最优的模型 统计学习的目标在于从假设空间中选取最优模型 损失函数和风险函数 损失函数度量模型一次预测的好坏 风险函数度量平均意义下模型预测的好坏 损失函数是\\(f(X)\\)和\\(Y\\)的非负实值函数，记作\\(L(Y, \\ f(X))\\) 常用的损失函数 0-1损失函数（0-1 loss function） \\[ \\begin{align*} \\begin{split} L(Y, f(X))= \\left \\{ \\begin{array}{ll} 1, &amp; Y \\ne \\ f(X) \\\\ 0, &amp; Y = f(X) \\\\ \\end{array} \\right. \\end{split} \\end{align*} \\] 平方损失函数（quadratic loss function） \\[ L(Y, f(X)) = (Y\\ - \\ f(X))^2 \\] 绝对损失函数（absolute loss function） \\[ L(Y, f(X)) = |Y \\ - \\ f(X)| \\] 对数损失函数（logarithmic loss function）或对数似然损失函数（loglikelihood loss function） \\[ L(Y, P(Y|X)) = -logP(Y|X) \\] 损失函数值越小，模型就越好 由于模型的输入、输出\\(（X,Y）\\)是随机变量，遵循联合分布\\(P(X, Y)\\)，所以损失函数的期望是 \\[ R_{exp}(f) = E_p[L(Y, f(X))] = \\int_{X \\times Y}L(y, f(x))P(x, y)dxdy \\] 这是理论上模型\\(f(X)\\)关于联合分布\\(P(X,Y)\\)的平均意义下的损失，成为风险函数（risk function）或期望损失（expected loss） 学习的目标就是选择期望风险最小的模型 由于联合分布\\(P(X,Y)\\)是未知的，\\(R_{exp}(f)\\)不能直接计算 这样一来，一方面根据期望风险最小学习模型要用到联合分布，另一方面联合分布又是未知的，所以监督学习就成为一个病态问题（ill-formed problem） 给定一个训练数据集 \\[ T = \\{(x_1, y_1), (x_2, y_2), \\dots , (x_N, y_N)\\} \\] 模型\\(f(X)\\)关于训练数据集的平均损失称为经验风险（empirical risk）或经验损失(empirical loss)，记作\\(R_{emp}\\) \\[ R_{emp}(f) = \\frac{1}{N} \\sum_{i=1} ^NL(y_i,f(x_i)) \\] 期望风险和经验风险的区别 期望风险\\(R_{exp}(f)\\)是模型关于联合分布的期望损失 经验风险\\(R_{emp}(f)\\)是模型关于训练样本集的平均损失 根据大数定律，当样本容量\\(N\\)趋于无穷时，经验风险\\(R_{emp}(f)\\)趋于期望风险\\(R_{exp}(f)\\)，所以很自然地想到用经验风险估计期望风险。 但是现实中训练样本数目有限，甚至很小，所以这么做往往并不理想 要对经验风险进行一定的矫正，这就关系到监督学习的两个基本策略：经验风险最小化和结构风险最小化 经验风险最小化与结构风险最小化 在假设空间、损失函数以及训练数据集确定的情况下，经验风险函数式就可以确定 经验风险最小化（empirical risk minimization，ERM） 该策略认为，经验风险最小的模型就是最优的模型 根据该策略，按照经验风险最小化来求最优模型就是求解最优化问题 \\[ \\min_{f \\in F} \\frac{1}{N}\\sum^N_{i=1}L(y_i, f(x_i)) \\] 其中，\\(F\\)是假设空间 当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用 如，极大似然估计（maximum likelihood estimation）就是经验风险最小化的一个例子，当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计 但是，当样本容量很小，经验风险最小化学习的效果未必很好，会产生“过拟合”现象 结构风险最小化（structural risk minimization，SRM） 为了防止过拟合而提出来的策略 结构风险最小化等价于正则化（rugularization） 结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term） \\[ R_{srm}(f) = \\frac{1}{N} \\sum^N_{i=1}L(y_i,f(x_i)) + \\lambda J(f) \\] 其中\\(J(f)\\)为模型的复杂度，是定义在假设空间\\(F\\)上的泛函 模型\\(f\\)越复杂，复杂度\\(J(f)\\)就越大，反之则相反 也就是说，复杂度表示了对复杂模型的惩罚 \\(\\lambda \\ge 0\\)是系数，用来权衡经验风险和模型复杂度 结构风险小需要经验风险与模型复杂度同时小 比如，贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation, MAP）就是一个结构风险最小化的一个例子。 当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计． 结构风险最小化的策略认为结构风险最小的模型是最优的模型，求最优模型就是求解最优化问题 \\[ \\min_{f \\in F} \\frac{1}{N}\\sum_{i=1}^NL(y_i,f(x_i)) + \\lambda J(f) \\] 监督学习问题就变成了经验风险或结构风险函数的最优化问题．这时经验或结构风险函数是最优化的目标函数 算法 算法是指学习模型的具体计算方法 统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型 统计学习方法就归结为最优化问题，统计学习的算法成为求解最优化问题的算法 如果最优化问题有显式的解析解，最优化问题就很简单，但通常解析解不存在 这就需要数值计算的方法求解，如何保证找到全局最优解，并使求解的过程非常高效，成为一个重要问题 统计学习可利用已有的最优化算法，有时也需要开发独立的最优化算法 统计学习方法之间的不同，主要来自其模型、策略、算法的不同．确定了模型、策略、算法，统计学习的方法也就确定了．这也就是将其称为统计学习三要素的原因． 1.4 模型评估与模型选择 训练误差与测试误差 当损失函数给定时，基于损失函数的模型的训练误差（training error）和模型的测试误差（test error）就自然成为学习方法评估的标准． 注意，统计学习方法具体采用的损失函数未必是评估时使用的损失函数． 当然，让两者一致是比较理想的 假设学习到的模型是\\(Y = \\hat{f}(X)\\)，训练误差是模型关于训练数据集的平均损失 \\[ R_{emp}(\\hat{f}) = \\frac{1}{N}\\sum^N_{i=1}L(y_i, \\hat{f}(x_i)) \\] 其中，\\(N\\)是训练样本容量 测试误差是模型关于测试数据集的平均损失 \\[ e_{test} = \\frac{1}{N} \\sum^{N^{`}}_{i=1}L(y_i, \\hat{f}(x_i)) \\] 其中，\\(N^`\\)是测试样本容量 当损失函数是0-1损失时，测试误差就变成了常见的测试数据集上的误差率(error rate)了 训练误差的大小，对判断给定问题是不是一个容易学习的问题是有意义的，但本质上不重要 测试误差反映了学习方法对未知的测试数据集的预测能力，是学习中的重要概念 通常将学习方法对未知数据的预测能力称为泛化能力（generalization ability） 过拟合与模型选择 当假设空间含有不同复杂度（例如，不同的参数个数）的模型时，就要面临模型选择（model selection）的问题 如果在假设空间中存在“真”模型，那么所选择的模型应该逼近真模型 具体地，所选择的模型要与真模型的参数个数相同，参数向量与真模型的参数向量相近 但是，如果 一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种现象成为过拟合（over-fitting） 过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象． 模型选择旨在避免过拟合并提高模型的预测能力 1.5 正则化与交叉验证 正则化（regularization） 正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项（regularizer）或罚项（penalty term） 正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大 比如，正则化项可以是模型参数向量的范数 正则化一般具有如下形式 \\[ \\min_{f \\in F} \\frac{1}{N}\\sum_{i=1}^N L(y_i, f(x_i)) +\\lambda J(f) \\] 其中，第1项是经验风险，第2项是正则化项，\\(\\lambda \\ge 0\\)为调整两者之间关系的系数 正则化项可以取不同的形式 例如，回归问题，损失函数为平方损失，正则化项可以是参数向量的\\(L^2\\)范数 \\[ L(w) = \\frac{1}{N}\\sum_{i=1}^N(f(x_i;w)-y_i)^2 + \\frac{\\lambda}{2} ||w||^2 \\] 也可以是参数向量的\\(L_1\\)范数 \\[ L(w) = \\frac{1}{N}\\sum_{i=1}^N(f(x_i;w)-y_i)^2 + \\lambda ||w||_1 \\] 正则化符合奥卡姆剃刀(Occam’s razor)原理．奥卡姆剃刀原理应用于模型选择时变为以下想法：在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的模型，也就是应该选择的模型 从贝叶斯估计的角度来看，正则化项对应于模型的先验概率．可以假设复杂的模型有较小的先验概率，简单的模型有较大的先验概率． 交叉验证（cross validation） 给定的样本数据充足，可随机地将数据集切分成三部分，分别为训练集（training set）、验证集（validation set）和测试集（test set） 训练集（training set）：用来训练模型 验证集（validation set）：用于模型的选择 测试集（test set）：用于最终对学习方法的评估 在学习到的不同复杂度的模型中，选择对验证集有最小预测误差的模型 由于验证集有足够多的数据，用它对模型进行选择也是有效的 简单交叉验证 随机地将已给数据分成两部分 一部分作为训练集 另一部分作为测试集 （例如，70%的数据为训练集，30%的数据为测试集） 用训练集在各种条件下（例如，不同的参数个数）训练模型 在测试集上评价各个模型的测试误差，选出测试误差最小的模型 S折交叉验证（S-fold cross validation） 首先随机地将已给数据切分为\\(S\\)个互不相交的大小相同的子集 然后利用\\(S-1\\)个子集的数据训练模型，利用余下的子集测试模型 将这一过程对可能的\\(S\\)种选择重复进行 最后选出\\(S\\)次评测中平均测试误差最小的模型 留一交叉验证 \\(S\\)折交叉验证的特殊情形是\\(S = N\\)，称为留一交叉验证（leave-one-out cross validation） 往往在数据缺乏的情况下使用 1.6 泛化能力 泛化误差 学习方法的泛化能力（generalization ability）是指由该方法学习到的模型对未知数据的预测能力，是学习方法本质上重要的性质 现实中采用最多的办法是通过测试误差来评价学习方法的泛化能力 这种评价依赖于测试数据集，而测试数据集是有限的，很有可能由此得到的评价结果是不可靠的 统计学习理论试图从理论上对学习方法的泛化能力进行分析 定义：如果学到的模型是\\(\\hat{f}\\)，那么用这个模型对未知数据预测的误差即为泛化误差（generalization error） \\[ R_{exp}(\\hat{f}) = E_p[L(Y,\\hat{f}(X))] = \\int_{X \\times Y}L(y,\\hat{f}(x))P(x,y)dxdy \\] 泛化误差反映了学习方法的泛化能力，如果一种方法学习到的模型比另一种方法学习的模型具有更小的泛化误差，则该方法更有效 事实上，泛化误差就是所学习到的模型的期望风险 泛化误差上界 学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为泛化误差上界（generalization error bound） 具体来说，就是通过比较两种学习方法的泛化误差上界的大小来比较它们的优劣 有以下性质 是样本容量的函数，当样本容量增加时，泛化上界趋于0 是假设空间容量的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大 1.7 生成模型与判别模型 监督学习方法可以分为生成方法（generative approach）和判别方法（discriminative approach），所学到的模型分别成为生成模型（generative model）和判别模型（discriminative model） 生成模型 生成方法由数据学习联合概率分布\\(P(X,Y)\\)，然后求出条件概率分布\\(P(Y|X)\\)作为预测的模型，即生成模型 \\[ P(Y|X) = \\frac{P(X, Y)}{P(X)} \\] 之所以被称为生成方法，是因为模型表示了给定输入\\(X\\)产生输出\\(Y\\)的生成关系 典型的生成模型：朴素贝叶斯法和隐马尔科夫模型 判别模型 判别方法由数据直接学习决策函数\\(f(X)\\)或者条件概率分布\\(P(Y|X)\\)作为预测的模型，即判别模型 判别方法关心的是对给定的输入\\(X\\)，应该预测什么样的输出\\(Y\\) 典型的判别模型：k近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、提升方法和条件随机场 比较 生成方法和判别方法各有优缺点，适用于不同条件下的学习方法 生成方法的特点： 生成方法可以还原出联合概率分布\\(P(X,Y)\\)，而判别方法不能 生成方法的学习收敛速度更快，即当样本容量增加的时候，学到的模型可以更快地收敛于真实模型 存在隐变量时，仍可以用生成方法学习 判别方法的特点： 判别方法直接学习的是条件概率\\(P(Y|X)\\)或决策函数\\(f(X)\\)，直接进行预测，往往学习的准确率更高 由于直接学习\\(P(Y|X)\\)或\\(f(X)\\)，可以对数据进行各种程度上的抽象、定义特征并使用特征，可以简化学习问题 1.8 分类问题 分类是监督学习的一个核心问题 当输出变量\\(Y\\)取有限个离散值时，预测问题便成为分类问题 输入变量\\(X\\)可以是离散的，也可以是连续的 监督学习从数据中学习一个分类模型或分类决策函数，称为分类器（classifier） 分类器对新的输入进行输出的预测（prediction），称为分类（classfication） 可能的输出称为类（class） 分类的类别为多个时，称为多类分类问题 分类问题包括学习和分类两个过程 学习过程中，根据已知的训练数据集利用有效的学习方法学习一个分类器 分类过程中，利用学习的分类器对新的输入实例进行分类 评价分类器性能的指标一般是 分类准确率（accuracy） 定义：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比 对于二类分类问题常用的评价指标是精确率（precision）与召回率（recall） 通常以关注的类为正类，其他类为负类，分布器在测试数据集上的预测或正确或不正确 4种情况： TP：将正类预测为正类数 FN：将正类预测为负类数 FP：将负类预测为正类数 TN：将负类预测为负类数 精确率： \\[ P = \\frac{TP}{TP+FP} \\] 召回率： \\[ R = \\frac{TP}{TP+FN} \\] \\(F_1\\)值：是精确率和召回率的调和均值 \\[ \\frac{2}{F_1} = \\frac{1}{P} + \\frac{1}{R} \\] 精确率和召回率都高时，\\(F_1\\)值也会高 1.9 标注问题 标注（tagging）是一个监督学习问题，可认为是分类问题的一个推广，它又是更复杂的结构预测（structure prediction）问题的简单形式 标注问题的输入是一个观测序列，输出是一个标记序列或状态序列 目标：学习一个模型，使它能够对观测序列给出标记序列作为预测 可能的标记个数是有限的，但其组合所成的标记序列的个数是依序列长度呈指数级增长的 标注问题分为学习和标注两个过程、 给定训练数据集：\\(T = \\{(x_1, y_1),(x_2,y_2),\\dots,(x_N, y_N)\\}\\) 这里，\\(x_i = (x_{i}^{(1)}, \\dots, x_i^{(n)})\\)，\\(i=1,2,\\dots,N\\)，是输入观测序列， \\(y_i = (y_i^{(1)},\\dots,y_i^{(n)})\\)是相应的输出标记序列，n是序列的长度，对不同样本可以有不同的值 学习系统基于训练数据集构建一个模型，表示为条件概率分布 \\[ P(Y^{(1)},Y^{(2)},\\dots,Y^{(n)}|X^{(1)}, X^2,\\dots,X^{(n)}) \\] 这里每一个\\(X^{(i)}，i=1,2,\\dots,n\\)的取值为所有可能的观测，每一个\\(Y^{(i)}\\)取值为所有可能的标记，一般\\(n \\ll N\\) 标注系统按照学习得到的条件概率分布模型，对新的输入观测序列找到相应的输出标记序列 具体地，对一个观测序列\\(x_{N+1}\\)找到使条件概率\\(P\\)最大的标记序列\\(y_{N+1}\\) 评价标注模型的指标与评价分类模型的指标一样，常用的有标注准确率、精确率和召回率，其定义与分类模型相同 标注常用的统计学习方法有：隐马尔科夫模型、条件随机场 标注问题在信息抽取、自然语言处理等领域被广泛应用，是这些领域的基本问题 1.10 回归问题 回归（regression）是监督学习的另一个重要问题。 回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。 回归模型正是表示从输入变量到输出变量之间映射的函数 回归问题的学习等价于函数拟合：选择一条函数曲线使其更好地拟合已知数据且很好地预测未知数据 回归问题分为学习和预测两个过程 首先给定一个训练数据集 学习系统基于训练数据构建一个模型，即函数\\(Y=f(X)\\) 对新的输入\\(x_{N+1}\\)，预测系统根据学习的模型\\(Y = f(X)\\)确定相应的输出\\(y_{N+1}\\) 回归问题按照输入变量的个数，分为一元回归和多元回归 按照输入变量和输出变量之间关系的类型即模型的类型，分为线性回归和非线性回归 回归学习最常用的损失函数是平方损失函数，在此情况下，回归问题可以由最小二乘法（least squares）求解 本章概要 习题 模型 策略 算法 极大似然估计 条件概率 经验风险最小化 求解析解 贝叶斯估计 条件概率 结构风险最小化 求数值解 伯努利模型 \\[ P(Y=1) = \\theta \\\\ P(Y=0) = 1 - \\theta \\] 极大似然估计 似然函数的对数 \\[ \\begin{align*} log(L(\\theta)) =&amp; \\ log(\\prod P(Y_i)) \\\\ =&amp; \\ log(\\theta^k * (1-\\theta)^{N-k}) \\\\ =&amp; \\ k*log\\theta + (N-k)*log(1-\\theta) \\end{align*} \\] 其中\\(N\\)为实验次数，\\(k\\)为出现1的次数 令对数似然的导数为0可以直接求出解析解： \\[ \\theta = \\frac{k}{N} \\] 贝叶斯估计 \\[ P(\\theta \\ | \\ Y_1, Y_2, \\dots, Y_n) = \\frac{P(Y_1,Y_2,\\dots,Y_n|\\theta) * P(\\theta)}{P(Y_1,Y_2,\\dots,Y_n)} \\] 根据先验概率\\(P(\\theta)\\)和\\(P(Y_1, Y_2, \\dots,Y_n)\\)估计后验概率，使后验概率最大化 所以贝叶斯估计得到的概率取决于所选择的先验概率 条件概率分布 \\[ f(X) = P(Y|X) = \\frac{P(X,Y)}{P(X)} \\] 对数损失的定义 \\[ L(Y, P(Y|X)) = -logP(Y|X) \\] 经验风险R为 \\[ \\begin{align*} R =&amp; \\ \\frac{1}{N} * \\sum^N_{i=1}L(Y_i, f(X_i)) \\\\ =&amp; \\ \\frac{1}{N} * \\sum^N_{i=1}L(Y_i, P(Y_i|X_i)) \\\\ =&amp; \\ \\frac{1}{N} * \\sum^N_{i=1}(-log(P(Y_i | X_i))) \\\\ =&amp; \\ -\\frac{1}{N} * log(\\prod^N_{i=1}\\frac{P(X_i,Y_i)}{P(X_i)}) \\end{align*} \\] 所以最小化经验风险R，相当于最大化似然估计\\(log(\\prod^N_{i=1}\\frac{P(X_i,Y_i)}{P(X_i)})\\)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://ye2222.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"统计学习方法","slug":"机器学习/统计学习方法","permalink":"https://ye2222.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}],"tags":[]},{"title":"趣谈Linux4","slug":"趣谈Linux4","date":"2023-04-10T11:46:37.000Z","updated":"2023-04-26T11:19:54.845Z","comments":true,"path":"posts/32268/","link":"","permalink":"https://ye2222.github.io/posts/32268/","excerpt":"","text":"进程 写代码：用系统调用创建进程 process.c函数 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;extern int create_process(char* program, char** arg_list);int create_process(char* program, char** arg_list)&#123; pid_t child_pid; child_pid = fork(); if (child_pid != 0) return child_pid; else &#123; execvp(program, arg_list); abort(); &#125;&#125; createprocess.c函数 12345678910111213141516171819// createprocess.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;extern int create_process(char* program, char** arg_list);int main() &#123; char* arg_list[] = &#123; &quot;ls&quot;, &quot;-l&quot;, &quot;/etc/yum.repos.d/&quot;, NULL &#125;; create_process(&quot;ls&quot;, arg_list); return 0;&#125; 进行编译：程序的二进制格式 Linux下面，二进制的程序有严格的格式，即为ELF（Executeable and Linkable Format，可执行与可链接格式） 根据编译结果的不同，分为不同的格式 ELF格式 文件后缀 可重定位文件 Relocatable File .o 可执行文件 Executeable File 无后缀 共享对象文件 Share Object .so 使用gcc进行编译 12gcc -c -fPIC process.cgcc -c -fPIC createprocess.c 在编译的时候，会先做预处理工作 如将头文件嵌入到正文中，将定义的宏展开 然后是真正的编译过程 最后编译成为.o文件，这就是ELF的第一种类型，可重定位文件（Relocatable File） 这里会生成process.o和createprocess.o两个文件 可重定位文件 文件格式如下： ELF文件的头是用于描述整个文件的，文件格式在内核中有定义，分别为strcut elf32_hdr和strcut elf64_hdr，ELF文件一个一个的section，叫做节 .text：放编译好的二进制可执行文件 .data：已经初始化好的全局变量 .rodata：只读数据，例如字符串常量、const的变量 .bss：未初始化全局变量，运行时会置0 .symtab：符号表，记录的则是函数和变量 .strtab：字符串表、字符串常量和变量名 注意点：为什么这里只有全局变量？ 局部变量是放在栈里面的，是程序运行过程中随时分配空间，随时释放的，现在讨论的是二进制文件，还没有启动，只需讨论在哪里保存全局变量 这些节的元数据信息需要有一个地方保存，就是最后的节头部表（Section Header Table） 在表里，每一个section都有一项，在代码里面也有定义的struct elf32_shdr和struct elf64_shdr 在ELF的头里面，有描述这个文件的节头部表的位置，有多少个表项等信息 可重定位的意义 编译好的代码和变量，将来加载到内存里面的时候，都是要加载到一定位置的，但是现在还是一个.o文件，不是一个可直接运行的程序，只是部分代码片段，将来被谁调用，在哪里调用都不清楚，所以.o里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的 .rel.text和.rel.data与重定位有关 要想让create_process函数作为库文件被重用，不能以.o的形式存在，而是要形成库文件，最简单的类型是静态链接库.a文件（Archives），仅仅将一系列对象文件（.o)归档为一个文件，使用命令ar创建 1ar cr libstaticprocess.a process.o 这里可以有多个.o，当有程序要使用这个静态链接库的时候，会将.o文件提取出来，链接到程序中 1gcc -o staticcreateprocess createprocess.o -L. -lstaticprocess 在这个命令中，-L表示在当前目录下找.a文件，-lstaticprocess会自动补全文件名，比如加前缀lib，后缀.a，变成libstaticprocess.a 找到这个.a文件后，将里面的process.o取出来，和createprocess.o做一个链接，形成二进制执行文件staticcreateprocess 这个链接的过程，重定位就起作用了，createprocess.o将process.o合并进来，就知道create_process函数的位置了 可执行文件 形成的二进制文件叫可执行文件，是ELF的第二种格式 文件格式如下： 与.o文件大致相似，分成一个个的section，并且被节头表描述 这些section是多个.o文件合并过的 这个时候，这个文件已经是马上就可以加载到内存里面执行的文件了，因此这些section被分成了几个部分 需要加载到内存里面的代码段、数据段 不需要加载到内存里面的部分 将小的section合成了大的段segment，并且在最前面加一个段表头(Segment Header Table) 在代码里面的定义为struct elf32_phdr和struct elf64_phdr，这里面除了有对于段的描述之外，最重要的是p_vaddr，这个是这段加载到内存的虚拟地址 在ELF头里面，有一项e_entry，也是个虚拟地址，是这个程序运行的入口 运行该程序后，会执行ls命令 12345678910[root@localhost ~]# ./staticcreateprocess[root@localhost ~]# total 40-rw-r--r--. 1 root root 1664 Oct 23 2020 CentOS-Base.repo-rw-r--r--. 1 root root 1309 Oct 23 2020 CentOS-CR.repo-rw-r--r--. 1 root root 649 Oct 23 2020 CentOS-Debuginfo.repo-rw-r--r--. 1 root root 314 Oct 23 2020 CentOS-fasttrack.repo-rw-r--r--. 1 root root 630 Oct 23 2020 CentOS-Media.repo-rw-r--r--. 1 root root 1331 Oct 23 2020 CentOS-Sources.repo-rw-r--r--. 1 root root 8515 Oct 23 2020 CentOS-Vault.repo-rw-r--r--. 1 root root 616 Oct 23 2020 CentOS-x86_64-kernel.repo 共享对象文件 静态链接库一旦链接进去，代码和变量的section都合并了，因而程序运行的时候，就不依赖这个库是否存在 但有一个缺点，就是相同代码段，被多个程序使用，在内存里面就有多份 而且一旦静态链接库更新，如二进制执行文件不重新编译，也不会随着更新 因此，出现了动态链接库（Shared Lirary） 不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享 1gcc -shared -fPIC -o libdynamicprocesss.so process.o 注意点： 当一个动态链接库被链接到一个程序文件中时，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存链接库的名称 创建可执行文件 1gcc -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess 当运行这个程序的时候，首先寻找动态链接库，然后加载它 默认情况下，系统在/lib和/usr/lib文件夹下寻找动态链接库，找不到就会报错 可以设定LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库 123456789101112[root@localhost ~]# export LD_LIBRARY_PATH=.[root@localhost ~]# ./dynamiccreateprocess[root@localhost ~]# total 40-rw-r--r--. 1 root root 1664 Oct 23 2020 CentOS-Base.repo-rw-r--r--. 1 root root 1309 Oct 23 2020 CentOS-CR.repo-rw-r--r--. 1 root root 649 Oct 23 2020 CentOS-Debuginfo.repo-rw-r--r--. 1 root root 314 Oct 23 2020 CentOS-fasttrack.repo-rw-r--r--. 1 root root 630 Oct 23 2020 CentOS-Media.repo-rw-r--r--. 1 root root 1331 Oct 23 2020 CentOS-Sources.repo-rw-r--r--. 1 root root 8515 Oct 23 2020 CentOS-Vault.repo-rw-r--r--. 1 root root 616 Oct 23 2020 CentOS-x86_64-kernel.repo 基于动态链接库创建出来的二进制文件格式还是ELF，但是稍有不同 首先，多了一个.interp的Segment，这里面是Id-linux.so，这是动态链接器，运行时的链接动作都是它做的 另外，ELF文件中还多了两个section 一个是.plt，过程链接表（Proced Linkage Table，PLT） 一个是.got.plt，全局偏移量表（Global Offset Table，GOT） 程序运行的时候，它们是如何将so文件动态链接到进程空间的？ dynamiccreateprocess这个程序要调用libdynamicprocess.so里的create_process函数 由于是运行时才去找，编译的时候不知道函数在哪里，所以就在PLT里面建立一项PLT[x] 这一项是一些代码，有点像一个本地的代理，在二进制程序里面，不直接调用create_process函数，而是调用PTL[x]里面的代理代码，这个代理代码会在运行的时候找真正的create_process函数 会使用GOT来找代理代码，这里面也会为create_process函数创建一项GOT[y] 这一项是运行时create_process函数在内存中真正的地址 如果这个地址在，dynamiccreateprocess调用PLT[x]里面的代理代码，代理代码调用GOT表中对应项GOT[y]，调用的就是加载到内存中的libdynamicprocess.so里面的create_process函数了 对于create_process函数，GOT一开始就会创建一项GOT[y]，但是这里面没有真正的地址，因为它也不知道，但它又回调PLT，告诉它，你里面的代码代理来找我要create_process函数的真实地址，但我不知道。 PLT这个时候会转而调用PLT[0]，即第一项，PLT[0]转而调用GOT[2]，这里面是ld-linux.so的入口函数 这个函数会找到加载到内存中的libdynamicprocess.so里面的create_process函数的地址，然后把这个地址放在GOT[y]里面 下次，PLT[x]的代理函数就能够直接调用了 运行程序为进程 我们现在知道了ELF这个格式，但这个时候它还是个程序，如何将这个文件加载到内存里面 在内核中，有一个数据结构被用来定义加载二进制文件的方法 12345678struct linux_binfmt &#123; struct list_head lh; struct module *module; int (*load_binary)(struct linux_binprm *); int (*load_shlib)(struct file *); int (*core_dump)(struct coredump_params *cprm); unsigned long min_coredump; /* minimal dump size */&#125;__randomize_layout; 对于ELF文件格式，有对应的实现 1234567static struct linux_binfmt elf_format = &#123; .module = THIS_MODULE, .load_binary = load_elf_binary, .load_shlib = load_elf_library, .core_dump = elf_core_dump, .min_coredump = ELF_EXEC_PAGESIZE,&#125;; 其中，load_elf_binary我们在加载内核镜像的时候，用的也是这种格式。 当前的具体调用过程为：do_execve -&gt; do_execveat_common -&gt; exec_binprm -&gt; search_binary_hander. 调用do_execve的是SYSCALL_DEFINE3函数，原理是exec这个系统调用最终调用的load_elf_binary exec比较特殊，它是一组函数： 包含p的函数（execvp，execlp）会在PATH路径下面寻找程序 不包含p的函数需要输入程序的全路径 包含v的函数（execv，execvp，execve）以数组的形式接受参数 包含l的函数（execl, execlp, execle）以列表的形式接受参数 包含e的函数（execve, execle）以数组的形式接受环境变量 进程树 所有的进程都是从父进程fork过来的，总有一个祖宗进程，就是系统启动的init进程 解析Linux的启动过程中，1号进程是/sbin/init 如果在CentOS 7里面，我们ls查看，可以看到，这个进程是被软链接到systemd的 12[root@localhost ~]# ls -la /sbin/initlrwxrwxrwx. 1 root root 22 Apr 10 03:53 /sbin/init -&gt; ../lib/systemd/systemd 系统启动之后，init进程会启动很多的daemon进程，为系统运行提供服务，然后启动getty，让用户登录，登录后运行shell，用户启动的进程都是通过shell运行的，从而形成了一棵进程树 通过ps -ef命令查看当前系统启动的进程 PID 1的进程是init进程systemd PID 2的进程是内核线程kthreadd 用户态的不带中括号，内核态的带中括号 进程号依次增大，但是会看到所有带中括号的内核态的进程，祖先都是2号进程，用户态的进程的祖先都是1号进程 TTY一列，是问号的，说明不是前台启动的，一般都是后台的服务 pts的父进程是sshd，bash的父进程是pts，ps -ef的父进程是bash 12345678910111213141516171819202122232425[root@localhost ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Apr10 ? 00:00:02 /usr/lib/systemd/systemd --switched-root --system --droot 2 0 0 Apr10 ? 00:00:00 [kthreadd]root 4 2 0 Apr10 ? 00:00:00 [kworker/0:0H]root 6 2 0 Apr10 ? 00:00:00 [ksoftirqd/0]root 7 2 0 Apr10 ? 00:00:00 [migration/0]root 8 2 0 Apr10 ? 00:00:00 [rcu_bh]root 9 2 0 Apr10 ? 00:00:00 [rcu_sched]root 10 2 0 Apr10 ? 00:00:00 [lru-add-drain]root 11 2 0 Apr10 ? 00:00:00 [watchdog/0]root 12 2 0 Apr10 ? 00:00:00 [watchdog/1]root 13 2 0 Apr10 ? 00:00:00 [migration/1]root 14 2 0 Apr10 ? 00:00:00 [ksoftirqd/1]root 16 2 0 Apr10 ? 00:00:00 [kworker/1:0H].....root 922 792 0 Apr10 ? 00:00:00 /sbin/dhclient -d -q -sf /usr/libexec/nm-dhcp-helperroot 1116 1 0 Apr10 ? 00:00:00 /usr/sbin/sshd -D.....root 2091 1116 0 Apr10 ? 00:00:00 sshd: root@pts/0root 2095 1116 0 Apr10 ? 00:00:00 sshd: root@nottyroot 2101 2091 0 Apr10 pts/0 00:00:00 -bash.....root 5532 712 0 00:03 ? 00:00:00 sleep 60root 5533 2101 0 00:03 pts/0 00:00:00 ps -ef 小结 首先通过图右边的文件编译过程，生成so文件和可执行文件，放在硬盘上 左边的用户态的进程A执行fork，创建进程B 在进程B的处理逻辑中，执行exec系列的系统调用 这个系统调用会通过load_elf_binary方法，将刚才生成的可执行文件，加载到进程B的内存中执行 线程 为什么需要线程 对于任何一个进程，即使我们没有主动去创建线程，进程也是默认有一个主线程的 线程是负责执行二进制指令的 进程要比线程管的多，除了执行指令之外，内存、文件系统等都要它来管 进程相当于一个项目，线程就是为了完成需求，建立的一个个开发任务 使用进程实现并发执行有两个主要问题 第一，创建进程占用资源太多 第二，进程之间的通信需要数据在不同的内存空间传来传去，无法共享 创建进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_OF_TASKS 5// 线程函数void *downloadfile(void *filename)&#123; printf(&quot;I am downloading the file %s!\\n&quot;, (char *)filename); sleep(10); long downloadtime = rand()%100; printf(&quot;I finish downloading the file within %d minutes!\\n&quot;, downloadtime); pthread_exit((void *)downloadtime);&#125;int main(int argc, char *argv[])&#123; char files[NUM_OF_TASKS][20] = &#123;&quot;file1.avi&quot;, &quot;file2.rmvb&quot;, &quot;file3.mp4&quot;, &quot;file4.wmv&quot;, &quot;file5.md&quot;&#125;; pthread_t threads[NUM_OF_TASKS]; int rc; int t; int downloadtime; // 声明线程对象，设置线程属性 pthread_attr_t thread_attr; pthread_attr_init(&amp;thread_attr); pthread_attr_setdetachstate(&amp;thread_attr, PTHREAD_CREATE_JOINABLE); for(t = 0; t &lt; NUM_OF_TASKS; t++) &#123; printf(&quot;createing thread %d, please help me to download %s\\n&quot;, t, files[t]); // 创建线程 rc = pthread_create(&amp;threads[t], &amp;thread_attr, downloadfile, (void *)files[t]); if(rc) &#123; printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc); exit(-1); &#125; &#125; // 销毁线程属性 pthread_attr_destroy(&amp;thread_attr); for(t = 0; t &lt; NUM_OF_TASKS; t++) &#123; // 等待线程结束 pthread_join(threads[t], (void**)&amp;downloadtime); printf(&quot;Thread %d downloads the file %s in %d minutes.\\n&quot;, t, files[t], downloadtime); &#125; pthread_exit(NULL);&#125; 一个运行中的线程可以调用pthread_exit退出线程 该函数可以传入一个参数转换为(void *)类型，是线程退出的返回值 主线程里 列了5个文件名，声明了一个数组，里面有5个pthread_t类型的线程对象 声明了一个线程属性pthread_attr_t，通过pthread_attr_init初始化这个属性，并且设置属性PTHTREAD_CREATE_JOINABLE，表示将来主线程等待这个线程的结束，并获取退出时的状态 接下来是一个循环，对于每一个文件和每一个线程，可以调用pthread_create创建线程。 一共有4个参数，第一个参数是线程对象，第二个参数是线程的属性，第三个参数是线程运行函数，第四个参数是线程运行函数的参数 主线程就是通过第4个参数，将自己的任务派给子线程 任务分配完成后，每个线程下载一个文件，主线程需要做的事情就是等待这些子任务完成 当一个线程退出的时候，就会发送信号给其他所有同进程的线程 使用pthread_join获取这个线程退出的返回值，线程的返回值通过pthread_join传给主线程，这样子线程就将自己下载文件所消耗的时间，告诉给主线程 多线程程序要依赖于libpthread.so 1gcc download.c -lpthread 编译后执行 123456789101112131415161718192021[root@localhost thread]# ./a.outcreateing thread 0, please help me to download file1.avicreateing thread 1, please help me to download file2.rmvbI am downloading the file file1.avi!createing thread 2, please help me to download file3.mp4createing thread 3, please help me to download file4.wmvI am downloading the file file2.rmvb!createing thread 4, please help me to download file5.mdI am downloading the file file3.mp4!I am downloading the file file4.wmv!I am downloading the file file5.md!I finish downloading the file within 83 minutes!Thread 0 downloads the file file1.avi in 83 minutes.I finish downloading the file within 86 minutes!I finish downloading the file within 77 minutes!I finish downloading the file within 15 minutes!I finish downloading the file within 93 minutes!Thread 1 downloads the file file2.rmvb in 15 minutes.Thread 2 downloads the file file3.mp4 in 77 minutes.Thread 3 downloads the file file4.wmv in 86 minutes.Thread 4 downloads the file file5.md in 93 minutes. 小结 线程的数据 线程访问的数据细分为3类 线程栈上的本地数据，如函数执行过程中的局部变量 栈的大小可以通过命令ulimit -a查看，默认情况下线程栈大小为8192（8MB） 可通过命令ulimit -s修改 对于线程栈，可通过函数pthread_attr_setstacksize，来修改线程栈的大小 1int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); 主线程在内存中有一个栈空间，其他线程栈也拥有独立的栈空间 为避免线程之间的栈空间踩踏，线程栈之间还会有小块区域用来隔离保护各自的栈空间，一旦另一个线程踏入隔离区，会引发段错误 在整个进程里共享的全局数据，如全局变量 如果同一个全局变量，两个线程一起修改，肯定会有问题，需要有一种机制保护他们 线程私有数据（Thread Specific Data） 可通过以下函数创建 1int pthread_key_create(pthread_key_t *key, void (*destructor)(void*)) 创建一个key，伴随着一个析构函数 一旦key被创建，所有线程都可访问它，但各线程可根据自身需要往key中填入不同的值，相当于提供了一个同名而不同值的全局变量 可通过下面的函数设置key对应的value 1int pthread_setspecific(pthread_key_t key, const void *value) 获取key对应的value 1void *pthread_getspecific(pthread_key_t key) 数据保护 互斥（Mutex，Mutual Exclusion） 在共享数据访问的时候，申请加把锁，谁拿到锁，谁就有访问权限，遵循谁先拿到谁访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_OF_TASKS 5int money_of_tom = 100;int money_of_jerry = 100;pthread_mutex_t g_money_lock;void *transfer(void *notused) &#123; pthread_t tid = pthread_self(); printf(&quot;Thread %u is transfering money!\\n&quot;, (unsigned int)tid); pthread_mutex_lock(&amp;g_money_lock); sleep(rand()%10); money_of_tom += 10; sleep(rand()%10); money_of_jerry -= 10; pthread_mutex_unlock(&amp;g_money_lock); printf(&quot;Thread %u finish transfering money!\\n&quot;, (unsigned int)tid); pthread_exit((void *)0);&#125;int main(int argc, char *argv[]) &#123; pthread_t threads[NUM_OF_TASKS]; int rc; int t; pthread_mutex_init(&amp;g_money_lock, NULL); for(t = 0; t &lt; NUM_OF_TASKS; t++) &#123; rc = pthread_create(&amp;threads[t], NULL, transfer, NULL); if(rc) &#123; printf(&quot;ERROR; return code from pthred_create() is %d\\n&quot;, rc); exit(-1); &#125; &#125; for(t = 0; t &lt; 100; t++) &#123; pthread_mutex_lock(&amp;g_money_lock); printf(&quot;money_of_tom + money_of_jerry = %d\\n&quot;, money_of_tom+money_of_jerry); pthread_mutex_unlock(&amp;g_money_lock); &#125; pthread_mutex_destroy(&amp;g_money_lock); pthread_exit(NULL);&#125; 如果没有加上mutex，那么中间的状态会很不正确，会出现超过200的情况 加上mutex后，可以保证两者之和永远都是200 使用Mutex，首先要使用pthread_mutex_init函数初始化这个mutex，初始化后，用它保护共享变量 pthread_mutex_lock()是抢那个锁的函数，抢到了，可以执行下一行程序，对共享变量进行访问；没抢到，被阻塞在那里瞪大 如不想被阻塞，可以使用pthread_mutex_trylock去抢锁 共享数据访问结束后，使用pthread_mutex_unlock释放锁，让给其他人使用 最后调用pthread_mutex_destroy销毁锁 小结 如果使用pthread_mutex_lock()，需要一直在那里等待 如果是pthread_mutex_trylock()，就不用等待，可以去干点别的 需要条件变量来进行通知，条件变量和互斥锁是配合使用的 条件变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM_OF_TASKS 3#define MAX_TASK_QUEUE 11char tasklist[MAX_TASK_QUEUE] = &quot;ABCDEFGHIJ&quot;;int head = 0;int tail = 0;int quit = 0;pthread_mutex_t g_task_lock;pthread_cond_t g_task_cv;void *coder(void *notused) &#123; pthread_t tid = pthread_self(); while(!quit) &#123; pthread_mutex_lock(&amp;g_task_lock); // 当前没有任务可以做了 while(tail == head) &#123; if(quit) &#123; pthread_mutex_unlock(&amp;g_task_lock); pthread_exit((void *)0); &#125; printf(&quot;No task now! Thread %u is waiting!\\n&quot;, (unsigned int)tid); // 这里会解锁，然后等待条件变量 pthread_cond_wait(&amp;g_task_cv, &amp;g_task_lock); printf(&quot;Have task now! Thread %u is grabing the task!\\n&quot;, (unsigned int)tid); &#125; char task = tasklist[head++]; pthread_mutex_unlock(&amp;g_task_lock); printf(&quot;Thread %u has a task %c now!\\n&quot;, (unsigned int)tid, task); sleep(5); printf(&quot;Thread %u finish the task %c!\\n&quot;, (unsigned int)tid, task); &#125; pthread_exit((void *)0);&#125;int main(int argc, char *argv[]) &#123; pthread_t threads[NUM_OF_TASKS]; int rc; int t; // 初始化 pthread_mutex_init(&amp;g_task_lock, NULL); pthread_cond_init(&amp;g_task_cv, NULL); for(t = 0; t &lt; NUM_OF_TASKS; t++) &#123; // 创建线程 rc = pthread_create(&amp;threads[t], NULL, coder, NULL); if(rc) &#123; printf(&quot;ERROR; return code from pthred_create() is %d\\n&quot;, rc); exit(-1); &#125; &#125; sleep(5); for(t = 1; t &lt;= 4; t++) &#123; pthread_mutex_lock(&amp;g_task_lock); // 分配任务 tail += t; printf(&quot;I am Boss, I assigned %d tasks, I notify all coder!\\n&quot;, t); // 操作了共享变量后，通知所有线程 pthread_cond_broadcast(&amp;g_task_cv); pthread_mutex_unlock(&amp;g_task_lock); sleep(20); &#125; pthread_mutex_lock(&amp;g_task_lock); quit = 1; pthread_cond_broadcast(&amp;g_task_cv); pthread_mutex_lock(&amp;g_task_lock); pthread_mutex_destroy(&amp;g_task_lock); pthread_cond_destroy(&amp;g_task_cv); pthread_exit(NULL);&#125; 有10个任务，每个任务一个字符 有两个变量head和tail，表示当前分配的工作从哪里开始，到哪里结束 如果head等于tail，则当前的工作分配完毕 如果tail加N，就是新分配了N个工作 总结 进程数据结构 有的线程只有一个线程，有的进程有多个线程，它们都需要由内核分配CPU来干活。但是CPU总共就那么几个，应该怎么管理，怎么进行调度呢 在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构task_struct进行管理 首先，Linux内核应该先弄一个链表，将所有的task_struct串起来 1struct list_head tasks 任务 任务ID 每一个任务都应该有一个ID，作为任务的唯一标识 task_struct里面涉及任务ID的，有以下几个 123pid_t pid;pid_t tgid;struct task_struct *group_leader; 为什么会有多个标识呢？是因为上面的进程和线程到了内核这里，统一变成了任务，带来了两个问题 任务展示 如ps命令可以展出所有的进程，到了内核，按照任务列表展出的话，所有的线程也会平摊开来 给任务下发指令 如kill命令可以给进程发信号，通知进程退出。如果只发给了其中一个线程，我们就不能只退出这个线程，而是应该退出整个进程，当然有时候，希望只给某个线程发信号 所以，在内核中，进程和线程虽然都是任务，但是应加以区分。 其中，pid是process id，tgid是thread group ID 任何一个进程，如果只有主线程，那pid是自己，tgid是自己，group_leader指向的还是自己 如果一个进程创建了其他线程，那么，线程有自己的pid，tgid就是进程的主线程的pid，group_leader指向的就是进程的主线程 信号处理 task_struct里面关于信号处理的字段 123456789struct signal_struct *signal;struct sighand_struct *sighand;sigset_t blocked;sigset_t real_blocked;sigset_t saved_sigmask;struct sigpending pending;unsigned long sas_ss_sp;size_t sas_ss_size;unsigned int sas__ss_flags; 定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand） 处理结果可以是忽略，可以使结束进程等等 信号处理函数默认使用用户态的函数栈，也可以开辟新的栈专门用于信号处理，这就是sas_ss_xxx这三个变量的作用 我们有一个struct sigpending pending，进入struct signal_struct *signal里面看的话，还有一个struct sigpending shared _pending，它们一个是本任务的，一个是线程组共享的 任务状态 在task_struct里面，涉及任务状态的是下面几个变量 123volatile long state;int exit_state;unsigned int flags; state(状态)可以取的值定义在include/linux/sched.h头文件中 12345678910111213141516171819202122/* Used in tsk-&gt;state: */#define TASK_RUNNING 0x00000000#define TASK_INTERRUPTIBLE 0x00000001#define TASK_UNINTERRUPTIBLE 0x00000002#define __TASK_STOPPED 0x00000004#define __TASK_TRACED 0x00000008/* Used in tsk-&gt;exit_state: */#define EXIT_DEAD 0x00000010#define EXIT_ZOMBIE 0x00000020#define EXIT_TRACE (EXIT_ZOMBIE | EXIT_DEAD)/* Used in tsk-&gt;state again: */#define TASK_PARKED 0x00000040#define TASK_DEAD 0x00000080#define TASK_WAKEKILL 0x00000100#define TASK_WAKING 0x00000200#define TASK_NOLOAD 0x00000400#define TASK_NEW 0x00000800#define TASK_RTLOCK_WAIT 0x00001000#define TASK_FREEZABLE 0x00002000#define __TASK_FREEZABLE_UNSAFE (0x00004000 * IS_ENABLED(CONFIG_LOCKDEP))#define TASK_FROZEN 0x00008000#define TASK_STATE_MAX 0x00010000 从定义的数值很容易看出，flags是通过bitset的方式设置的，也就是说，当前时什么状态，哪一位就至1（二进制） TASK_RUNNING并不是说进程正在运行，而是表示进程在时刻准备运行的状态 当处于这个状态的进程获得时间片的时候，就是在运行中 如果没有获得时间片，就说明它被其他进程抢占了，在等待再次分配时间片 在运行的过程，一旦要进行一些I/O操作，需要等待I/O完毕，这个时候会释放CPU，进入睡眠状态 Linux中有两种睡眠状态 一种是 TASK_INTERRUPTIBLE，可中断的睡眠状态。是一种浅睡眠的状态，也就是说，虽然在睡眠，等待I/O完成，但是这个时候一个信号来的时候，进程还是要被唤醒 但是唤醒后，不是继续刚才的操作，而是进行信号处理 当然，程序员可以根据自己的意愿，来写信号处理函数，例如收到某些信号，就放弃等待这个I/O操作完成，直接退出；也可收到某些信息，继续等待 另一种是 TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。是一种深度睡眠状态，不可被信号唤醒，只能死等I/O操作完成。一旦I/O操作因为特殊原因不能完成，谁也叫不醒这个进程了。 kill本身也是一个信号，kill信号也会被忽略，除非重启电脑 有了一种新的进程睡眠状态，TASK_KILLABLE，可以终止的新睡眠状态，进程处于这种状态中，运行原理类型与不可中断的睡眠状态，只不过可以响应致命信号 TASK_WAKEKILL用于在接受到致命信号时唤醒进程，而TASK_KILLABLE相当于这两位都设置了 1#define TASK_KILLABLE (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE) TASK_STOPPED是在进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后进入该状态 TASK_TRACED表示进程被debugger等进程监视，进程执行被调试程序所停止 当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态 一个进程结束的时候，先进入的是EXIT_ZOMBIE状态，但是此时它的父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程就成了僵尸进程 EXIT_DEAD是进程的最终状态 EXIT_ZOMBIE和EXIT_DEAD也可以用于exit_state 上面的进程状态和进程的运行、调度有关系，还有其他的一些状态，称为标志，放在flags字段中，这些字段被定义称为宏，以PF开头，下面是几个例子 123#define PF_EXITING 0x00000004#define PF_VCPU 0x00000010#define PF_FORKNOEXEC 0x00000040 PF_EXITING表示正在退出，当有这个flag的时候，在函数find_alive_thread中，找活着的线程，遇到有这个flag的，就直接跳过 PF_VCPU表示进程运行在虚拟CPU上。在函数 account_system_time 中，统计进程的系统运行时间，如果有这个 flag，就调用 account_guest_time，按照客户机的时间进行统计 PF_FORKNOEXEC表示fork完了，还没有exec。在 _do_fork 函数里面调用copy_process，这个时候把 flag 设置为 PF_FORKNOEXEC。当 exec 中调用了load_elf_binary 的时候，又把这个 flag 去掉。 进程调度 进程的状态切换往往涉及调度。 下面是一些关于调度的字段 12345678910111213141516171819// 是否在运行队列上int on_rq;// 优先级int prio;int static_prio;int normal_prio;unsigned int rt_priority;// 调度器类const struct sched_class *sced_class;// 调度实体struct sched_entity se;struct sched_rt_entity rt;struct sched_dl_entity dl;// 调度策略unsigned int policy;// 可以使用哪些CPUint nr_cpus_allowed;cpumask_t cpus_allowed;struct sched_info sched_info; 小结 运行统计信息 在进程的运行过程中，会有一些统计量，具体可看下面列表，有进程在用户态和内核态消耗的时间、上下文切换的次数等等 123456u64 utime; // 用户态消耗的CPU时间u64 stime; // 内核态消耗的CPU时间unsigned long nvcsw; // 自愿（voluntary）上下文切换计数unsigned long nivcsw; // 非自愿（involuntary）上下文切换计数u64 start_time; // 进程启动时间，不包含睡眠时间u64 real_start_time; // 进程启动时间，包含睡眠时间 进程亲缘关系 任何一个进程都有父进程，所以，整个进程其实就是一棵进程树，而拥有同一父进程的所有进程都具有兄弟关系 1234struct task_struct __rcu *real_parent; /* real parent process */struct task_struct __rcu *parent; /* recipient of SIGCHLD, wait4() reports */struct list_head children; /* list of my children */struct list_head sibling; /* linkage in my parent&#x27;s children list * parent 指向其父进程。当它终止时，必须向它的父进程发送信号。 children 表示链表的头部。链表中的所有元素都是它的子进程。 sibling 用于把当前进程插入到兄弟链表中。 通常情况下，real_parent和parent是一样的，但也有另外的情况存在 例如，bash创建一个进程，那进程的 parent 和 real_parent 就都是 bash 如果在 bash 上使用 GDB来 debug 一个进程，这个时候 GDB 是 real_parent，bash 是这个进程的 parent 进程权限 在Linux里面，对于进程权限的定义如下： 1234/* Objective and real subjective task credentials(COW): */const struct cred __rcu *real_cred;/* Effective (overridable) subjective task credentials(COW): */const struct cred __rcu *cred; Objective是被操作的对象，而Subjective是进行操作的对象 操作，就是一个对象对另一个对象进行某些动作 当动作要实施的时候，就要审核权限，当两边的权限匹配上，才可以实施动作 其中，read_cred是说明被操作的进程，cred是进行操作的进程 cred的定义如下，大部分是用户和用户所属的用户组信息 123456789101112131415161718struct cred &#123;...... kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */...... kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we&#x27;re permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */......&#125; __randomize_layout; 第一个是uid和gid，注释是read user/group id。 一般情况下，谁启动的进程，就是谁的ID 但是权限审核的时候，往往不比较这两个，说明不大起作用 第二个是euid和egid，注释时effective user/group id 是起作用的ID 当这个进程要操作消息队列、共享内存、信号量等对象的时候，其实就是在比较这个用户和组是否有权限 第三个是fsuid和fsgid，也就是filesystem user/group id 这个是对文件操作会审核的权限 一般来说，fsuid、euid和uid是一样的，fsgid、egid和gid也是一样的 因为谁启动的进程，就应该审核启动的用户到底有没有这个权限 特殊情况 以用户和用户组控制权限 用户A想运行用户B安装的游戏程序（权限为rwxr--r--），但A是没有权限运行该程序的，因此B必须要给用户A权限才行，设定程序为所有用户都能执行（权限为rwxr-xr-x） 用户A便可以运行游戏程序，游戏运行时，游戏进程的uid、euid、fsuid都是用户A 但是，用户A想保存通关数据的时候，发现游戏的玩家数据时保存在另一个文件里面的（权限为rw-------），只给用户B开了写入权限，而游戏进程的euid和fsuid都是用户A，写不进去 可以使用chmod u+s program，给游戏程序设置set-user-ID的标识位，将游戏的权限变为rwsr-xr-x 当用户A再启动游戏时，创建的进程uid是用户A，但是euid和fsuid是用户B，这样可以将游戏数据保存下来 在Linux里面，一个进程可以随时通过setuid设置用户ID，所以游戏程序的用户B的ID还会保存在一个地方，就是suid和sgid，这样就可以方便地使用setuid，通过设置uid或者suid来改变权限 capabilities机制 控制进程的权限，要么是高权限的root用户，要么是一般权限的普通用户 这时候的问题是，root用户权限太大，普通用户权限太小 有时候普通用户向做一点高权限的事情，得给他整个root的权限，实在不安全 因此引入新的机制capabilities，用位图来表示权限，可在capability.h找到定义的权限 1234567891011#define CAP_CHOWN 0#define CAP_KILL 5#define CAP_NET_BIND_SERVICE 10#define CAP_NET_RAW 13#define CAP_SYS_MODULE 16#define CAP_SYS_RAWIO 17#define CAP_SYS_BOOT 22#define CAP_SYS_TIME 25#define CAP_AUDIT_READ 37#define CAP_LAST_CAP CAP_AUDIT_READ..... 对于普通用户运行的进程，当有这个权限的时候，就能做相应的操作 cap_permitted：表示进程能够使用的权限，但真正起作用的是cap_effective cap_permitted中可以包含cap_effective中没有的权限 一个进程可以在必要的时候，放弃自己的某些权限，这样更加安全 cap_inheritable：表示当可执行文件的扩展属性设置了inferitable位时，调用exec执行该程序会继承调用者的inheritable集合，并将其加入到permitted集合 但在非root用户下执行exec时，通常不会保留inheritable集合 往往又是非root用户，才想保留权限，因此十分鸡肋 cap_bset：也就是capability bounding set，是系统中所有进程允许保留的权限 如果这个集合中不存在某个权限，那么系统中的所有进程都没有这个权限 即使以超级用户权限执行的进行，也是一样的 这样可以有很多好处，例如，系统启动以后，将加载内核模块的权限去除，那所有进程都不能加载内核模块，这样即使这台机器被攻破，也做不了太多有害的事情 cap_ambient：为解决cap_inheritable状况而加入的，也就是非root用户进程使用exec执行一个程序的时候，保留权限的问题。 当执行exec的时候，cap_ambient会被添加到cap_permitted中，同时设置到cap_effective中 内存管理 每个进程都有自己独立的虚拟内存空间，需要一个数据结构来表示，即mm_struct。 ps. 后面内存管理具体讲述 12struct mm_struct *mm;struct mm_struct *active_mm; 文件与文件系统 每个进程有一个文件系统的数据结构，还有一个打开文件的数据结构 ps. 后面文件系统具体讲述 1234/* Filesystem information: */struct fs_struct *fs;/* Open file information: */struct files_struct *files; 小结 在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。如何将用户态的执行和内核态的执行串起来呢？ 需要两个重要的成员变量 12struct thread_info thread_info;void *stack; 用户态函数栈 在用户态中，程序的执行往往是一个函数调用另一个函数。 函数调用都是通过栈来进行的。 在进程的内存空间里面，栈是一个从高地址到低地址，往下增长的结构 也就是说，上面是栈底，下面是栈顶 入栈和出栈的操作都是从下面的栈顶开始的 32位操作系统 在CPU里，ESP是栈顶指针寄存器","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/categories/Linux/"},{"name":"趣谈Linux操作系统","slug":"Linux/趣谈Linux操作系统","permalink":"https://ye2222.github.io/categories/Linux/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/tags/Linux/"}]},{"title":"趣谈Linux3","slug":"趣谈Linux3","date":"2023-04-06T11:40:12.000Z","updated":"2023-04-26T11:19:54.843Z","comments":true,"path":"posts/48205/","link":"","permalink":"https://ye2222.github.io/posts/48205/","excerpt":"","text":"计算机的基本结构和X86结构 CPU：中央处理器 包括三个部分：运算单元、数据单元、控制单元 运算单元：运算器等，做加法、做位移等 数据单元：如CPU内部的缓存和寄存器组，可暂时存放数据和运算结果 控制单元：统一的指挥中心 Bus：总线，高速通道 地址总线（Address Bus） 数据总线（Data Bus） Memory：内存，可保存中间结果 I/O：输入设备和输出设备 8086结构 数据单元 16位的通用寄存器：8个 AX、BX、CX、DX、SP、BP、SI、DI 可分成两个8位使用的寄存器：AX、BX、CX、DX 控制单元 IP寄存器：指令指针寄存器，指向代码段中下一条指令位置 16位的段寄存器：4个，指向不同进程的地址空间 CS、DS、SS、ES CS：代码段寄存器（Code Segment Register） DS：数据段寄存器 SS：栈寄存器 CS和DS两者都存储着一个段的起始地址 可知，一个段的大小为\\(2^{16}=64k\\) 注意点：8086的地址总线地址是20位，即空间为\\(1M\\)，而CS、DS都是16位，需要凑足20位，即“起始地址*16+偏移量” 32位处理器 地址总线变为32根，即内存变为\\(2^{32}=4G\\) 扩展通用寄存器：8个16位拓展到8个32位的，保留16位和8位的使用方式 重新定义段寄存器 内存中某个位置存储着一个表格，表格存储着多项段描述符，而段描述符存放着段起始位置 CS、SS、DS、ES仍为16位，但存储的是选择子（Selector），即段描述符（Segment Descriptor）在表格中的位置 实模式（Real Pattern）和保护模式（Protected Pattern） 前者是8086的段寻址方式，系统刚刚启动时，CPU是处于实模式的 后者是重新定义的段寻址方式，当需要更多内存时，便转为保护模式 通过切换模式进行兼容 BIOS到bootloader BIOS时期 全称：Basic Input and Output System，即基本输入输出系统 位于主板的ROM上，该ROM固化了一些初始化的程序 X86系统中，将1M空间最上面的0xF0000到0xFFFFF这64K映射给ROM，到这部分地址访问时，会访问ROM 电源刚加电的时候，会进行重置工作 CS设置为0xFFFF IP设置为0x0000 第一条指令会指向0xFFFF0，该指令有一个JMP命令，跳到ROM中做初始化工作的代码，BIOS便开始进行初始化的工作 首先，BIOS会检查系统的硬件 然后，建立中断向量表和中断服务程序 bootloader时期 操作系统安装在硬盘上，BIOS界面上有个启动盘的选项 启动盘一般位于第一个扇区，占512字节，且以0xAA55结束，会在512字节内启动相关的代码 Linux中有个叫Grub2的工具，是搞系统启动的 全称：Grand Unified Bootloader Version 2 配置系统启动的选项： 1grub2 -mkconfig -o /boot/grub2/grub.cfg 将启动程序安装到相应的位置： 1grub2 -install /dev/sda grub2第一个安装的是boot.img，它由boot.S编译而成，有512字节，正式安装到启动盘的第一个扇区，该扇区通常称为MBR（Master Boot Record，主引导记录/扇区） BIOS完成任务后，会将boot.img从硬盘加载到内存中的0x7c00来运行，boot.img会加载grub2的另一个镜像core.img core.img由lzma_decompress.img、diskboot.img、kernel.img和一系列模块组成，功能丰富 boot.img先加载的是core.img的第一个扇区，从硬盘启动的话，这个扇区存储着diskboot.img，对应代码为diskboot.S boot.img将控制权交给diskboot.img，diskboot.img的任务是将core.img的其他部分加载进来 首先是解压缩程序lzma_decompress.img，对应代码是stratup_raw.S，执行时，会调用real_to_prot，切换到保护模式 然后是kernel.img，它是压缩过的，执行时需要解压缩 最后是各个模块module对应的映像 从实模式切换到保护模式 启用分段 在内存里面建立段描述符表，将寄存器里面的段存储器变成段选择子，指向某个段描述符 启动分页 将内存分成相等大小的块 打开Gate A20 即第21根地址线的控制线 切换保护模式的函数DATA32 call real_to_prot会打开Gate A20 解压缩kernel.img，跳转到kernel.img开始运行 kernel.img对应代码为startup.S和一堆c文件 startup.S会调用grub_main，是grub kernel的主函数，该函数里的grub_load_config()会开始解析grub.conf文件中的配置信息 正常启动时，grub_main最后会调用grub_command_execute(\"normal\", 0, 0)，最终会调用grub_normal_execute()函数，该函数中的grub_show_menu()会显示出让你选择的操作系统的列表 选定启动某个操作系统后，就开始调用grub_menu_execute_entry()，解析并执行选择项 如linux16命令，表示装载指定的内核文件，并传递内核启动参数，grub_cmd_linux() 函数会被调用，会首先读取 Linux 内核镜像头部的一些数据结构，放到内存中的数据结构来，进行检查。如果检查通过，则会读取整个 Linux 内核镜像到内存 initrd 命令，用于为即将启动的内核传递 init ramdisk 路径。于是grub_cmd_initrd() 函数会被调用，将 initramfs 加载到内存中来。 然后，grub_command_execute(\"boot\", 0, 0)才开始真正启动内核 内核初始化 内核的启动 从入口函数strat_kernel()开始 在 init/main.c 文件中，start_kernel 相当于内核的 main 函数，里面是各种各样的初始化函数XXXX_init 进程列表初始化：创始进程 set_task_stack_end_magic(&amp;init_task) 也称为0号进程，是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个 Process List（进程列表） 中断初始化：trap_init()中设置了很多中断门（Interrupt Gate），用于处理各种中断，响应用户需求 其中有一个set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)，是系统调用的中断门 系统调用也是通过发送中断的方式进行的 64位的有另外的系统调用方法 内存初始化：mm_init()就是用来初始化内存管理模块的 调度初始化：sched_init()是用来初始化调度模块的 基于内存的文件系统rootfs的初始化：调用vfs_caches_init() 在该函数里面，会调用mnt_init()-&gt;init_rootfs()，其中有一行代码，register_filesystem(&amp;rootfs_fs_type)。在 VFS 虚拟文件系统里面注册了一种类型，我们定义为 struct file_system_type rootfs_fs_type 为兼容各种各样的文件系统，将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的结构，该抽象层即为VFS（Virtual File System），虚拟文件系统 其他方面的初始化：调用rest_init() 初始化一号进程 rest_init()的第一个大工作便是，用 kernel_thread(kernel_init, NULL, CLONE_FS) 创建第二个进程，这个是1 号进程。 该进程是用户态所有进程的祖先 1号进程将运行一个用户进程，一旦有了用户进程，资源便需要进行区分以及分配，所以x86提供了分层的权限机制，把区域分成了四个Ring，越往里权限越高，越往外权限越低 Ring0：存放访问关键资源的代码，也称为内核态（Kernel Mode） Ring3：存放普通的代码程序，也称为用户态（User Mode） 系统处于保护模式时，除了可访问空间变大，另一个功能便是保护，当处于用户态的代码想要执行更高权限的指令，这种行为是被禁止的 当用户态程序要访问核心资源时，可以进行系统调用，此时会暂停用户态程序的执行，进入内核态，内核完成相应操作后，系统调用结束，暂停的程序继续运行 暂停的实现：把程序运行的情况保存下来，把当前CPU寄存器的值暂存到一个地方，系统调用结束后，返回时再恢复回去 整个过程：用户态 -- 系统调用 -- 保存寄存器 -- 内核态执行系统调用 -- 恢复寄存器 -- 返回用户态继续运行 从内核态到用户态 在执行kernel_thread函数，即创建1号进程的时候，我们处于内核态 当需要到用户态去运行一个程序时 kernel_thread的一个参数为一个函数kernel_init，该进程会运行这个函数 在kernel_init里面，会调用kernel_init_freeable()，其中有段代码 12if(!ramdisk_execute_command) ramdisk_execute_command = &quot;/init&quot; 而在kernel_init函数中，有段代码块 1234567891011121314151617if(ramdisk_execute_command) &#123; ret = run_init_process(ramdisk_execute_command); ...&#125;if(!try_to_run_init_process(&quot;/sbin/init&quot;) || !try_to_run_init_process(&quot;/etc/init&quot;) || !try_to_run_init_process(&quot;/bin/init&quot;) || !try_to_run_init_process(&quot;/bin/sh&quot;)) return 0; // run_init_process代码static int run_init_process(const char *init_filename) &#123; argv_init[0] = init_filename; return do_execve(getname_kernel(init_filename), (const char __user *const __user *)argv_init, (const char __user *const __user *)envp_init);&#125; 这说明，1号进程运行的是一个文件，run_init_process函数中调用的是do_execve execve是一个系统调用，其作用是运行一个执行文件 它尝试取运行ramdisk的\"/init\"，或者普通文件系统上的\"/sbin/init\"、\"/etc/init\"、\"/bin/init\"、\"/bin/sh\"。不同版本的Linux会选择不同的文件启动，只要启动一个就可以了 利用执行init文件的机会，从内核态回到用户态，在运行init时，调用了do_execve，其中，do_execve -&gt; do_execveat_common -&gt;exec_binprm -&gt; search_binary_handler，这里面会调用一段代码： 1234567int search_binary_handler(struct linux_binprm *bprm) &#123; ...... struct linux_binfmt *fmt; ...... retval = fmt-&gt;load_binary(bprm); .....&#125; 也就是说，要运行一个程序，需要加载这个二进制文件，他是有一定格式的 Linux一个常用的格式是ELF（Executable and Linkable Format，可执行与可链接格式） 1234567static struct linux_binfmt elf_format = &#123; .module = THIS_MODULE, .load_binary = load_elf_binary, .load_shlib = load_elf_library, .core_dump = elf_core_dump, .min_coredump = ELF_EXEC_PAGESIZE,&#125;; 其实就是先调用load_elf_binary，最后调用start_thread 12345678910111213141516voidstart_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)&#123; set_user_gs(regs, 0); regs-&gt;fs = 0; regs-&gt;ds = __USER_DS; regs-&gt;es = __USER_ES; regs-&gt;ss = __USER_SS; regs-&gt;cs = __USER_CS; regs-&gt;ip = new_ip; regs-&gt;sp = new_sp; regs-&gt;flags = X86_EFLAGS_IF; force_iret();&#125;EXPORT_SYMBOL_GPL(start_thread); pt_regs便是寄存器，是在系统调用时内核用于保存用户态运行上下文的 将用户态的代码段CS设置为_USER_CS，将用户态的数据段DS设置为_USER_DS，还有指令指针寄存器IP和栈指针寄存器SP，补上了系统调用中保存寄存器的步骤 iret是用于从系统调用中返回，这时候会恢复寄存区，CS和IP恢复了，指向用户态下一个要执行的语句，DS和SP也恢复了，指向用户态函数栈的栈顶，下一条指令便从用户态开始运行 ramdisk的作用 init在上面步骤中从内核态到用户态了，一开始到用户态的是ramdisk的init，后来会启动真正根文件系统上的init，成为所有用户态进程的祖先 Linux访问存储设备，要有驱动才能访问，如果存储系统数目很有限，那驱动可直接放到内核中 但如果存储系统太多了，都放进内核，内核就太大了，因此，我们先弄一个基于内存的文件系统 内存访问是不需要驱动的，这个就是ramdisk，此时它便是根文件系统 运行ramdisk上的/init，等它运行完了就已经在用户态了 /init程序会先根据存储系统的类型来加载驱动，有了驱动就可以设置真正的根文件系统，ramdisk上的/init会启动文件系统上的init 接下来便是各种系统的初始化，启动系统的服务和控制台，用户便可以登录进来。 创建2号进程 rest_init第二件大事情便是第三个进程--2号进程 该进程统一管内核态的进程 kernel_thread(kthreadd, NULL, CLONE_FS|CLONE_FILES)又一次使用kernel_thread函数创建进程 从内核态来看，无论是进程还是线程，我们可以统称为任务(Task)，都使用相同结构 kthreadd函数，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先 小结 系统调用 glibc对系统调用的封装 glibc 作用 syscalls.list 罗列所有glibc的函数对应的系统调用 make-syscall.sh 根据syscalls.list配置文件，对封装好的系统调用生成文件 syscall-template.S 使用宏，定义了系统调用的调用方式 以系统调用open为例子，看系统调用是如何实现的，解析从glibc中是如何调用到内核的open 我们开始在用户态进程里面调用open函数，为了方便，大部分用户会选择使用中介，即调用的是glibc里面的open函数 12\\\\ open函数的定义int open(const char *pathname, int flags, mode_t mode) 在glibc的源代码中，有个文件syscalls.list，里面列着所有glibc的函数对应的系统调用 12# File name Caller Syscall name Args Strong name Weak names open - open Ci:siv __libc_open __open ope glibc还有一个脚本make-syscall.sh，可根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件 该文件里面定义了一些宏，例如#define SYSCALL_NAME open glibc还有一个文件syscall-template.S，使用上面这个宏，定义了这个系统调用的调用方式 123456T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS) retT_PSEUDO_END (SYSCALL_SYMBOL) #define T_PSEUDO(SYMBOL, NAME, N) PSEUDO (SYMBOL, NAME, N) 这里的PSEUDO也是一个宏，定义如下： 123456#define PSEUDO(name, syscall_name, args) \\ .text; \\ ENTRY (name) \\ DO_CALL(syscall_name, args); \\ cmpl $-4095, %eax; \\ jae SYSCALL_ERROR_LABEL 里面对于任何一个系统调用，都会调用DO_CALL，这也是一个宏，这个宏32位和64位的定义不同 32位系统调用过程 sysdep.h文件 12345678910111213141516* Linux takes system call arguments in registers: syscall number %eax call-clobbered arg 1 %ebx call-saved arg 2 %ecx call-clobbered arg 3 %edx call-clobbered arg 4 %esi call-saved arg 5 %edi call-saved arg 6 %ebp call-saved......*/#define DO_CALL(syscall_name, args) \\ PUSHARGS_##args \\ DOARGS_##args \\ movl $SYS_ify (syscall_name), %eax; \\ ENTER_KERNEL \\ POPARGS_##args 我们请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器eax中，然后执行ENTER_KERNEL 1# define ENTER_KERNEL int $0x80 int就是interrupt，中断的意思，int $0x80就是触发一个软中断，通过它可以陷入(trap)内核 内核启动的时候，有一个trap_init()，其中有这样的代码 1set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32) 这是一个软中断的陷入门，当接收到一个系统调用的时候，entry_INT80_32就被调用了 12345678910ENTRY(entry_INT80_32) ASM_CLAC pushl %eax /* pt_regs-&gt;orig_ax */ SAVE_ALL pt_regs_ax=$-ENOSYS /* save rest */ movl %esp, %eax call do_syscall_32_irqs_on.Lsyscall_32_done:.......Lirq_return: INTERRUPT_RETURN 通过push和SAVE_ALL将当前用户态的寄存器，保存在pt_regs结构里面 进入内核之前，保存所有的寄存器，然后调用do_syscall_32_irqs_on(即DO_CALL)，实现如下 1234567891011121314static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)&#123; struct thread_info *ti = current_thread_info(); unsigned int nr = (unsigned int)regs-&gt;orig_ax; ...... if (likely(nr &lt; IA32_NR_syscalls)) &#123; regs-&gt;ax = ia32_sys_call_table[nr]( (unsigned int)regs-&gt;bx, (unsigned int)regs-&gt;cx, (unsigned int)regs-&gt;dx, (unsigned int)regs-&gt;si, (unsigned int)regs-&gt;di, (unsigned int)regs-&gt;bp); &#125; syscall_return_slowpath(regs);&#125; 在这里，可以看到，将系统调用号从eax里面取出来，然后根据系统调用号，在系统调用表中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数 根据宏定义，#define ia32_sys_call_table sys_call_table，系统调用就是放在这个表里面 当系统调用结束之后，在entry_INT80_32之后，紧接着调用的是INTERRUPT_RETURN，找到它的定义，也就是iret 1#define INTERRUPT_RETURN iret iret指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等，此时用户态进程恢复执行 小结 64位系统调用过程 x86_64的sysdep.h文件 1234567891011121314/* The Linux/x86-64 kernel expects the system call parameters inregisters according to the following table:syscall number rax arg 1 rdi arg 2 rsi arg 3 rdx arg 4 r10 arg 5 r8 arg 6 r9......*/#define DO_CALL(syscall_name, args) \\ lea SYS_ify (syscall_name), %rax; \\ syscall 跟32位的步骤一样，将系统调用名称转换为系统调用号，放到寄存器rax。但是这里是真正进行调用，不是用中断了，改用syscall指令了，传递参数的寄存器也变了 syscall指令使用了一种特殊的寄存器，叫特殊模块寄存器（Model Specific Registers，简称MSR） 这种寄存器是CPU为完成某些特殊控制功能为目的的寄存器，其中就有系统调用 系统初始化的时候，trap_init除了初始化上面的中断模式，还会调用cpu_init-&gt;syscall_init，其中有段代码： 1wrmsrl(MSR_LSTAR, (unsigned long)entry_SYSCALL_64); rdmsr和wrmsr是用来读写特殊模块寄存器的 MSR_LSTAR是一个特殊的寄存器，当syscall指令调用的时候，会从寄存器里面拿出函数地址来调用，也就是调用entry_SYSCALL_64 在arch/x86/entry/entry_64.S中定义了entry_SYSCALL_64 123456789101112131415161718192021222324252627282930313233343536373839 ENTER(entry_SYSCALL_64) pushq $__USER_DS /* pt_regs-&gt;ss */ pushq PER_CPU_VAR(rsp_scratch) /* pt_regs-&gt;sp */ pushq %r11 /* pt_regs-&gt;flags */ pushq $__USER_CS /* pt_regs-&gt;cs */ pushq %rcx /* pt_regs-&gt;ip */ pushq %rax /* pt_regs-&gt;orig_ax */ pushq %rdi /* pt_regs-&gt;di */ pushq %rsi /* pt_regs-&gt;si */ pushq %rdx /* pt_regs-&gt;dx */ pushq %rcx /* pt_regs-&gt;cx */ pushq $-ENOSYS /* pt_regs-&gt;ax */ pushq %r8 /* pt_regs-&gt;r8 */ pushq %r9 /* pt_regs-&gt;r9 */ pushq %r10 /* pt_regs-&gt;r10 */ pushq %r11 /* pt_regs-&gt;r11 */ sub $(6*8), %rsp /* pt_regs-&gt;bp, bx, r12-15 not saved */ movq PER_CPU_VAR(current_task), %r11 testl $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, TASK_TI_flags(%r11) jnz entry_SYSCALL64_slow_path......entry_SYSCALL64_slow_path: /* IRQs are off. */ SAVE_EXTRA_REGS movq %rsp, %rdi call do_syscall_64 /* returns with IRQs disabled */return_from_SYSCALL_64: RESTORE_EXTRA_REGS TRACE_IRQS_IRETQ movq RCX(%rsp), %rcx movq RIP(%rsp), %r11 movq R11(%rsp), %r11......syscall_return_via_sysret: /* rcx and r11 are already restored (see code above) */ RESTORE_C_REGS_EXCEPT_RCX_R11 movq RSP(%rsp), %rsp USERGS_SYSRET64 这里先保存了很多寄存器到pt_regs结构里面，例如用户态的代码段、数据段、保存参数的寄存器 然后调用entry_SYSCALL64_slow_pat-&gt;do_syscall_64 1234567891011__visible void do_syscall_64(strcut pt_regs *regs) &#123; strcut thread_info *ti = current_thread_info(); unsigned long nr = regs-&gt;orig_ax;...... if(likely((nr &amp; __SYSCALL_MASK) &lt; NR_syscalls)) &#123; regs-&gt;ax = sys_call_table[nr &amp; __SYSCALL_MASK] ( regs-&gt;di, regs-&gt;si, regs-&gt;dx, regs-&gt;r10, regs-&gt;r8, regs-&gt;r9 ); &#125;&#125; 在do_syscall_64里面，从rax里面拿出系统调用号，然后根据系统调用号，在系统调用表sys_call_table中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数 无论是32位还是64位，都会到系统调用表sys_call_table这里来 系统调用返回时，执行的是USERGS_SYSRET64 123#define USERGS_SYSRET64 swapgs; sysretq; 返回用户态的指令变成了sysretq 小结 系统调用表 32位的系统调用表定义在arch/x86/entry/syscalls/syscall_32.tbl 以open的定义为例 15 i386 open sys_open compat_sys_open 64位的系统调用定义在另一个文件arch/x86/entry/syscalls/syscall_64.tbl里 12 common open sys_open 第一列数字是系统调用号 可看出，32位和64位的系统调用号是不一样的 第三列是系统调用的名字 第四列是系统调用在内核的实现函数 系统调用在内核中的实现函数要有一个声明，往往在include/linux/syscall.h文件中 123// sys_open的声明asmlinkage long sys_open(const char __user *filename, int flag, umode_t mode); 真正实现这个系统调用的一般在一个.c文件里面，例如sys_open的实现在fs/open.c里面 1234567SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)&#123; if (force_o_largefile()) flags |= O_LARGEFILE; return do_sys_open(AT_FDCWD, filename, flags, mode);&#125; SYSCALL_DEFINE3是一个宏系统调用，最多6个参数，根据参数的数目选择宏，具体定义如下 123456789101112131415161718192021222324#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)#define SYSCALL_DEFINEx(x, sname, ...) \\ SYSCALL_METADATA(sname, x, __VA_ARGS__) \\ __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)#define __PROTECT(...) asmlinkage_protect(__VA_ARGS__)#define __SYSCALL_DEFINEx(x, name, ...) \\ asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)) \\ __attribute__((alias(__stringify(SyS##name)))); \\ static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__)); \\ asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__)); \\ asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__)) \\ &#123; \\ long ret = SYSC##name(__MAP(x,__SC_CAST,__VA_ARGS__)); \\ __MAP(x,__SC_TEST,__VA_ARGS__); \\ __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__)); \\ return ret; \\ &#125; \\ static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS_ 把宏展开之后，实现如下，和声明是一样的 12345678910asmlinkage long sys_open(const char __user *filename, int flags, int mode) &#123; long ret; if(force_o_largefile()) flags |= O_LARGEFILE; ret = do_sys_open(AT_FDCWD, filename, flags, mode); asmlinkage_protect(3, ret, filename, flags, mode); return ret;&#125; 声明和实现都好了，接下来，在编译过程中，根据syscall_32.tbl和syscall_64.tbl生成自己的unistd_32.h和unistd_64.h。生成方式在arch/x86/entry/syscalls/Makefile中 这里面会使用两个脚本 第一个脚本arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成#define __NR_open 第二个脚本arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成__SYSCALL(__NR_open, sys_open) 这样，unistd_32.h和unistd_64.h是对应的系统调用号和系统调用实现函数之间的对应关系 在文件arch/x86/entry/syscall_32.c中，定义了这样一个表，里面include了这个头文件，从而所有的sys_系统调用都在这个表里面了 12345678__visible const sys_call_ptr_t ia32_sys_call_table[__NR_syscall_compat_max+1] = &#123; /* * Smells like a compiler bug -- it doesn&#x27;t work * when the &amp; below is removed. */ [0 ... __NR_syscall_compat_max] = &amp;sys_ni_syscall,#include &lt;asm/syscalls_32.h&gt;&#125;; 同理，在文件arch/x86/entry/syscall_64.c，定义了这样一个表，里面include了这个头文件，这样所有的sys_系统调用都在这个表里面了 12345678asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = &#123; /* * Smells like a compiler bug -- it doesn&#x27;t work * when the &amp; below is removed. */ [0 ... __NR_syscall_max] = &amp;sys_ni_syscall,#include &lt;asm/syscalls_64.h&gt;&#125;; 小结","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/categories/Linux/"},{"name":"趣谈Linux操作系统","slug":"Linux/趣谈Linux操作系统","permalink":"https://ye2222.github.io/categories/Linux/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/tags/Linux/"}]},{"title":"趣谈Linux2","slug":"趣谈Linux2","date":"2022-09-11T01:50:36.000Z","updated":"2023-04-26T11:19:54.844Z","comments":true,"path":"posts/31884/","link":"","permalink":"https://ye2222.github.io/posts/31884/","excerpt":"","text":"总览 进程管理 fork 分支 创建进程的系统调用叫fork，意为分支 在Linux中，要创建一个新的进程，需要一个老的进程调用fork来实现 其中老的进程叫做父进程 新的进程叫做子进程 一个进程的运行是要有一个程序的 当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。 如果不进行特殊的处理，父进程和子进程都按相同的程序代码进行下去，这样就没有意义了。 对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。 execve 运行新二进制文件 这样fork在返回值这里就有了一个区分，然后通过 if-else 语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用execve来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也即产生了一个分支（fork）了 waitpid 等待子进程结束 有个系统调用waitpid，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。 内存管理 进程内存空间 在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间 代码段 对于进程的内存空间来讲，放程序代码的这部分，我们称为代码段（Code Segment） 数据段 对于进程的内存空间来讲，放置进程运行中产生数据的这部分，我们称为数据段（Data Segment） 其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了； 也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。 每个进程看到的内存都是从0开始 只有进程要去使用部分内存的时候，才会使用内存管理的系统调用来登记，说自己马上就要用了，希望分配一部分内存给它，但是这还不代表真的就对应到了物理内存。 只有真的写入数据的时候，发现没有对应物理内存，才会触发一个中断，现分配物理内存。 brk和mmap 两个在堆里面分配内存的系统调用，brk和mmap 当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起 当分配的内存数量比较大的时候，使用 mmap，会重新划分一块区域 文件管理 文件操作中六个最重要的系统调用 open和close 对于已经有的文件，可以使用open打开这个文件，close关闭这个文件； creat 对于没有的文件，可以使用creat创建文件； lseek 打开文件以后，可以使用lseek跳到文件的某个位置； read和write 可以对文件的内容进行读写，读的系统调用是read，写是write。 Linux 里有一个特点，那就是一切皆文件。 启动一个进程，需要一个程序文件，这是一个二进制文件。 启动的时候，要加载一些配置文件，例如 yml、properties 等，这是文本文件； 启动之后会打印一些日志，如果写到硬盘上，也是文本文件。 但是如果我想把日志打印到交互控制台上，在命令行上唰唰地打印出来，这其实也是一个文件，是标准输出stdout 文件 这个进程的输出可以作为另一个进程的输入，这种方式称为管道，管道也是一个文件 进程可以通过网络和其他进程进行通信，建立的Socket，也是一个文件 进程需要访问外部设备，设备也是一个文件。 文件都被存储在文件夹里面，其实文件夹也是一个文件。 进程运行起来，要想看到进程运行的情况，会在 /proc 下面有对应的进程号，还是一系列文件。 每个文件，Linux 都会分配一个文件描述符（File Descriptor），这是一个整数。 有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。 文件操作是贯穿始终的，这也是“一切皆文件”的优势，就是统一了操作的入口 信号处理 经常遇到的信号有以下几种 在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出； 如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西 硬件故障，设备出了问题 用户进程通过kill函数，将一个用户信号发送给另一个进程 进程管理收到信号的时候，需要决定如何处理这些异常情况 对于一些不严重的信号，可以忽略 像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，可以执行对于该信号的默认动作 每种信号都定义了默认的动作，例如硬件故障，默认终止； 也可以提供信号处理函数，可以通过sigaction系统调用，注册一个信号处理函数。 进程间通信 进程比较大的时候，可能会分成多个进程，进程间需要进行通信 首先就是发个消息，不需要一段很长的数据，这种方式称为消息队列（Message Queue）。 消息队列是在内核里的 msgget创建一个新的队列 msgsnd将消息发送到消息队列 消息接收方可以使用msgrcv从队列中取消息。 当两个进程需要交互的信息比较大的时候，可以使用共享内存的方式 这时候可以通过shmget创建一个共享内存块 通过shmat将共享内存映射到自己的内存空间，然后就可以读写了。 当两个进程同时修改同一个数据时，需要有一种方式，让不同的人能够排他地访问，这就是信号量的机制Semaphore。 对于只允许一个人访问的需求，我们可以将信号量设为 1。 当一个人要访问的时候，先调用sem_wait。如果这时候没有人访问，则占用这个信号量，他就可以开始访问了。 如果这个时候另一个人要访问，也会调用 sem_wait。由于前一个人已经在访问了，所以后面这个人就必须等待上一个人访问完之后才能访问 当上一个人访问完毕后，会调用sem_post将信号量释放，于是下一个人等待结束，可以访问这个资源了。 网络通信 当一台Linux要与另一台Linux交流，就需要用到网络服务 不同机器的通过网络相互通信，要遵循相同的网络协议，也即TCP/IP 网络协议栈 Linux 内核里有对于网络协议栈的实现 网络服务是通过套接字 Socket 来提供服务的，在通信之前，双方都要建立一个 Socket。 可以通过 Socket 系统调用建立一个 Socket。Socket 也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。 查看源代码中的系统调用 Glibc 为了对用户更友好，我们还可以使用中介Glibc，有事情找它就行，它会转换成为系统调用，帮你调用 Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。 Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。 每个特定的系统调用对应了至少一个 Glibc 封装的库函数 比如说，系统提供的打开文件系统调用 sys_open 对应的是 Glibc 中的 open 函数。 Glibc 一个单独的 API 可能调用多个系统调用 比如说，Glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用。 多个 API 也可能只对应同一个系统调用 如 Glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/categories/Linux/"},{"name":"趣谈Linux操作系统","slug":"Linux/趣谈Linux操作系统","permalink":"https://ye2222.github.io/categories/Linux/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/tags/Linux/"}]},{"title":"李宏毅深度学习L4","slug":"李宏毅深度学习L4","date":"2022-06-20T02:03:18.000Z","updated":"2023-04-26T11:19:54.797Z","comments":true,"path":"posts/32343/","link":"","permalink":"https://ye2222.github.io/posts/32343/","excerpt":"","text":"GAN 将网络作为生成器(Generator) 给定一个分布，从分布sample出一些样本 网络作为generator，可以接收sample出来的样本和输入x，学习到一个复杂的分布，输出y。 为什么需要一个分布 以一个Video Prediction为例子 给定之前的帧，网络需要输出下一帧 但是这样会出现一个问题，网络采用一个多分类问题的解决形式时，输出可能会结合多种可能性，生成一种包含所有情况，只是概率大小不同的图 在这个例子中，你会看到小豆子分裂，一个往左，一个往右，网络没办法只选定一种可能 当给定一个分布sample出来的数值，网络便可以学习到一个分布，进行一个特定的选择 所有种类的GAN https://github.com/hindupuravinash/the-gan-zoo GAN的结构 GAN包括Generator和Discriminator两个结构 Generator根据输入和sample来在一个复杂的分布中sample出一个输出 Discriminator对于给定的输入，进行打分，判断其是否为真实的 GAN的思想 Generator想办法生成逼真的图片来骗过Discriminator Discriminator想办法辨别出真假图片 GAN的算法 初始化generator和discriminator 在每一个训练步骤中 Step1 固定generator G，更新discriminator D Discriminator学习给真实的图片高分，给生成的图片低分，即学会去分辨真假图片 Step2 固定discrimator D，更新generator G Generator要学会去欺骗discriminator GAN背后的理论 目标 让Generator生成的分布尽可能向数据的分布靠近 即 \\[ G^* = arg\\min_{G}Div(P_G,P_{data}) \\] 这里的\\(Div(P_G,P_{data})\\)是指两个分布之间的divergence(散度) Sampling 尽管我们不能确切地知道\\(P_G\\)和\\(P_{data}\\)的分布，但是我们从两个分布中sample出一些样本 Discriminator 这里的Discriminator是一个二分类的分类器 Training： \\[ D^* = arg\\max_{D}V(D,G) \\] 其实后面的\\(\\max_DV(D,G)\\)相当于一个JS散度 Objective Function: \\[ V(G,D)=E_{y\\sim P_{data}}[logD(y)]+E_{y\\sim P_G}[log(1-D(y))] \\] 其中，我们希望\\(logD(y)\\)能够尽可能地大，这样能够认出真实的图片；\\(log(1-D(y))\\)能够尽可能地小，这样可以辨别出生成地图片 我们可以将Generator中需要的散度换成Discriminator的目标函数，联合训练 其他的一些divergence Tips for GAN JS divergence并不适合GAN 在大部分情况下，\\(P_G\\)和\\(P_{data}\\)并不是重叠的(overlapped) 两者都是高维空间在低维空间的流形(manifold)，重叠部分可以忽略 取样问题，尽管两者之间有重叠但是取样不够多的话 JS divergence的问题 当两个分布不重叠的话，JS divergence总是\\(log_2\\) 这样会出现一个很严重的问题，当两个分布不重叠的时候，discriminator总是会实现百分百精度的分类，但这样GAN的训练就无法有一个明确的方向去优化了，因为只要不重叠，都是一样差的 Wasserstein distance Wasserstein distance可以用来衡量一个分布变换到目标分布的最小距离 这样GAN的优化就有一个明确的方向 WGAN 使用Wasserstein distance来优化\\(P_{data}\\)和\\(P_G\\) 如果没有D函数光滑的限制，D的训练将不会收敛 如上图所示，生成分布和数据分布没有重叠，discriminator可能会不断往无穷处进行打分，来更好地区分两者，无法收敛 让discriminator的函数保持光滑可以强制\\(D(y)\\)位于正无穷和负无穷之间 不同的做法 Origin WGAN -&gt; Weight 强制参数w位于c和-c之间 参数更新后，如果\\(w&gt;c\\)，\\(w = c\\)；如果\\(w &lt; -c\\)，\\(w = -c\\) Improved WGAN -&gt; Gradient Penalty 梯度惩罚 Spectral Normalization-&gt;Keep gradient norm smaller than 1 everywhere GAN仍然很难训练，Generator和Discriminator需要棋逢对手，不能有一方独大 用于序列生成的GAN 通常，generator是从一个从其他方法中学习的模型微调(fine-tuned)得到的 但是，通过足够的超参数调整和提示，ScarchGAN可以从头开始训练","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李宏毅","slug":"深度学习/李宏毅","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://ye2222.github.io/tags/DeepLearning/"}]},{"title":"趣谈Linux1","slug":"趣谈Linux1","date":"2022-06-14T13:28:39.000Z","updated":"2023-04-26T11:19:54.841Z","comments":true,"path":"posts/32204/","link":"","permalink":"https://ye2222.github.io/posts/32204/","excerpt":"","text":"Linux操作系统 组成 系统调用子系统 进程管理子系统 内存管理子系统 文件子系统 设备子系统 网络子系统 总览 几个命令 总览 设置密码 命令：passwd 创建新用户 命令：useradd + 用户名 为新建用户设置密码：passed + 用户名 /etc/passwd：查看用户 /etc/group：查看组 浏览文件 ls：列出当前目录下的文件 window的是dir window的cd ..表示切换到上一级目录 ls -l：用列表的方式列出文件 其中第一个字段的第一个字符是文件类型。如果是“-”，表示普通文件；如果是 d，就表示目录。 第一个字段剩下的 9 个字符是模式，其实就是权限位（access permission bits）。 3 个一组，每一组 rwx 表示“读（read）”“写（write）”“执行（execute）”。 如果是字母，就说明有这个权限；如果是横线，就是没有这个权限。 这三组分别表示文件所属的用户权限、文件所属的组权限以及其他用户的权限。 例子：-rw-r–r-- 就可以翻译为，这是一个普通文件，对于所属用户，可读可写不能执行；对于所属的组，仅仅可读；对于其他用户，也是仅仅可读。如果想改变权限，可以使用命令 chmod 711 hosts。 第二个字段是硬链接（hard link）数目 第三个字段是所属用户，第四个字段是所属组。第五个字段是文件的大小，第六个字段是文件被修改的日期，最后是文件名。 可以通过命令chown改变所属用户，chgrp改变所属组。 管理和安装软件 Linux常用的有两大体系 CentOS体系 Ubuntu体系 软件格式：前者使用rpm，后者使用deb CentOS rpm -- 程序管理(Redhat Package Manager) 本地安装rpm文件：rpm -i + rpm文件（安装一个下载到本地的软件包） 查看安装的软件列表：rpm -qa 将列出来的所有软件形成一个输出：rpm -qa | grep jdk 是管道，用于连接两个程序 前面 rpm -qa 的输出就放进管道里面，然后作为 grep 的输入，grep 将在里面进行搜索带关键词 jdk 的行，并且输出出来。 grep 支持正则表达式，因此搜索的时候很灵活，再加上管道，这是一个很常用的模式。 列出所有软件：rpm -qa | more 或者 rpm -qa | less more 是分页后只能往后翻页，翻到最后一页自动结束返回命令行，less 是往前往后都能翻页，需要输入 q 返回命令行，q 就是 quit。 删除：rpm -e (只是删除安装的文件) yum -- 软件管家 下载：yum install + 软件名 搜索：yum search + 关键字 卸载：yum erase + 软件名 下载地址配置文件：/etc/yum.repos.d/CentOS-Base.repo Ubuntu dpkg -- 程序管理(Debian package) 本地安装deb文件：dpkg -i + deb文件（安装一个下载到本地的软件包） 查看安装的软件列表：dpkg -l 将列出来的所有软件形成一个输出：dpkg -l | grep jdk 删除：dpkg -r(只是删除安装的文件) apt -- 软件管家 下载：apt-get install + 软件名 搜索：apt-cache search + 关键字 卸载：apt-get purge + 软件名 下载地址配置文件：/etc/apt/sources.list 下载 其实无论是先下载再安装，还是通过软件管家进行安装，都是下载一些文件，然后将这些文件放在某个路径下，然后在相应的配置文件中配置一下。 还有一种简单粗暴的方法，就是将安装好的路径直接下载下来，然后解压缩成为一个整的路径。 在 JDK 的安装目录中，Windows 有 jdk-XXX_Windows-x64_bin.zip，这是 Windows 下常用的压缩模式。 Linux 有 jdk-XXX_linux-x64_bin.tar.gz，这是 Linux 下常用的压缩模式。 Linux 上面有一个工具 wget，后面加上链接，就能从网上下载 解压缩 Linux 下面默认会有 tar 程序。如果是解压缩 zip 包，就需要另行安装。 tar.ge格式的，通过 tar xvzf jdk-XXX_linux-x64_bin.tar.gz 就可以解压缩。 配置环境变量 通过 tar 解压缩之后，也需要配置环境变量，可以通过 export 命令来配置。 export JAVA_HOME=/root/jdk-XXX_linux-x64 export PATH=$JAVA_HOME/bin:$PATH export 命令仅在当前命令行的会话中管用，一旦退出重新登录进来，就不管用了 在当前用户的默认工作目录，例如 /root 或者 /home/cliu8 下面，有一个.bashrc 文件 这个文件是以点开头的，这个文件默认看不到，需要 ls -la 才能看到，a 就是 all 每次登录的时候，这个文件都会运行，因而把它放在这里。 这样登录进来就会自动执行。当然也可以通过 source .bashrc 手动执行。 编辑.bashrc文件，可以使用文本编辑器 vi，也可以使用更加友好的 vim。 如果默认没有安装，可以通过 yum install vim 及 apt-get install vim 进行安装。 vim的使用 打开文件：vim + 文件名(路径) 如果没有这个文件，就创建一个 输入i：进入编辑模式 退出编辑模式：esc 输入: 后面是输入命令的 输入命令w：write 可以保存文本 输入q：退出 冒号!：是强制 运行程序 Linux 执行程序最常用的一种方式，通过 shell 在交互命令行里面运行。 只要文件有 x 执行权限，都能到文件所在的目录下，通过./filename运行这个程序。 当然，如果放在 PATH 里设置的路径下面，就不用./ 了，直接输入文件名就可以运行了，Linux 会帮你找。 缺点：一旦退出交互命令行，程序就停止运行了 Linux 运行程序的第二种方式，后台运行 nohup命令：当前交互命令行退出的时候，程序还要在 这个时候，程序不能霸占交互命令行，而是应该在后台运行。最后加一个 &amp;，就表示后台运行。 另外一个要处理的就是输出，后台运行时，输出到文件中。 最终命令的一般形式：nohup command &gt;out.file 2&gt;&amp;1 &amp; “1”表示文件描述符 1 “2”表示文件描述符 2，意思是标准错误输出 “2&gt;&amp;1”表示标准输出和错误输出合并了。合并到 out.file 里。 关闭进程 启动的程序包含某个关键字，那就可以使用下面的命令 ps -ef |grep 关键字 |awk '{print $2}'|xargs kill -9 ps -ef 可以单独运行，列出所有正在运行的程序 awk工具 可以很灵活地对文本进行处理 awk '{print $2}'是指第二列的内容，是运行的程序 ID。 可以通过 xargs 传递给 kill -9，也就是发给这个运行的程序一个信号，让它关闭 如果你已经知道运行的程序 ID，可以直接使用 kill 关闭运行的程序。 服务(systemd) Linux中的服务是程序运行的第三种方式，以服务的方式运行。 例如常用的数据库 MySQL，就可以使用这种方式运行。 Ubuntu 安装MySQL：apt-get install mysql-server 启动MySQL：systemctl start mysql 设置开机启动：systemctl enable mysql 之所以成为服务并且能够开机启动，是因为在 /lib/systemd/system 目录下会创建一个 XXX.service 的配置文件，里面定义了如何启动、如何关闭。 CentOS 安装MySQL：yum install mariadb-server mariadb 启动MySQL：systemctl start mariadb 设置开机启动：systemctl enable mariadb 同理，会在 /usr/lib/systemd/system 目录下，创建一个 XXX.service 的配置文件，从而成为一个服务。 重启关机 关机：shutdown -h now 重启：reboot","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/categories/Linux/"},{"name":"趣谈Linux操作系统","slug":"Linux/趣谈Linux操作系统","permalink":"https://ye2222.github.io/categories/Linux/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/tags/Linux/"}]},{"title":"李宏毅深度学习L3","slug":"李宏毅深度学习L3","date":"2022-06-01T07:23:07.000Z","updated":"2023-04-26T11:19:54.798Z","comments":true,"path":"posts/48150/","link":"","permalink":"https://ye2222.github.io/posts/48150/","excerpt":"","text":"Convolutional Neural Network （CNN） CNN，即卷积神经网络，主要适用于图片处理 图片分类 假设我们现在有一张彩色的图片，在电脑中它有红绿蓝三个通道，每个通道是一个100*100的矩阵 但是对于图片来说，如果我们使用全连接层的模型，参数会变得特别多 感受野 我们观察到对于图像分类来说，要抓住的是图像中物体的特征，需要去捕捉图片的局部信息 如图中鸟的特征：鸟喙、眼睛、鸟爪 所以我们设置一个感受野(Receptive field)区域，来提取这一区域覆盖的图片信息(局部信息)，并将信息给予一个神经元 kernel size(感受野或者叫卷积核的大小)：\\(n \\times n\\)，一般为\\(3\\times3\\) 区域可以重叠 stride：移动感受野到图片的下一个区域的跨步 padding：当感受野来到图片边界，剩下区域不够大时的填充 常规设置：每一个感受野有一组神经元（例如64个神经元） 相同特征在不同区域 给我们两张鸟的图片，它们都有鸟喙，但是它们的鸟喙在图片上的不同区域上，那对于每一个感受野来说，都需要配置一个专门的鸟喙检测的神经元吗？ 可以让所有感受野中相应的神经元来共享参数 好处 可以很好地处理图片 在图片中，一些重要的pattern比整张图片要小得多 在不同的图片中，相同的pattern会出现在图片的不同区域 卷积层 彩色：3个通道 黑白/灰：1个通道 假设我们的通道为1，现在我们拥有一张6*6图片，在给定的filter中，它们的值是不确定的，需要训练得到 进行卷积操作后得到的数据的结构 列数： \\[ (c - c_f + 1 + padding*2)\\ / \\ stride \\] 行数： \\[ (r - r_f + 1 + padding * 2)\\ / \\ stride \\] 其中， \\(c\\): 当前输入矩阵的列数 \\(c_f\\): filter的列数 \\(r\\): 当前输入矩阵的行数 \\(r_f\\): filter的行数 padding: 指在输入矩阵外圈填充的圈数 stride: 指filter在移动时跨越的步数 当所有的filter都对输入进行处理后，我们便获得了Feature Map，每一个filter都是对图片的不同解读，即拓展了查看图片的角度 我们可以将Feature Map投入到下一个卷积层中 感受野和滤波器的比较 拥有不同感受野的神经元会共享相同的参数 每个滤波器会在整张输入图片上进行卷积操作 Pooling 对像素进行子采样不会更改对象 子采样是一种选取原始数据的子集的方法，用来减小数据的大小 子采样会改变数据集的拓扑，当某些部分没有被选取时，会留下拓扑上的洞 Max Pooling 选取Filter中最大的值作为感受野的取值 小结 CNN能够捕捉局部信息，当使用CNN时，我们应该考虑我们的数据集和目标，是否适用CNN 例如Alpha Go中，在围棋中，我们需要去考虑局部的信息，而且在这种具体的情况中，pooling并不适用，子采样会损失围棋分布的信息 CNN在图像的放缩和旋转后，不能够正常的识别，需要我们进行数据增强(data augmentation) Recurent Neural Network(RNN) Slot Filling 输入一段语句，给出填空的答案 可不可以使用前向网络(Feedforward network)来实现 输入单词（使用单词编码），每一个单词用一个向量来表示 输出单词属于某一个空的概率 问题：网络无法结合上下单词，理解词汇的意义，如到达和离开的区别，只能捕捉到目的地单词 我们需要网络具有记忆的功能，能够记住前后的单词 单词编码 1-of-N encoding 向量长度为整个词库的词语数量 一个维度标记词库中的一个单词 对于某一个单词，它所在维度为1，其他维度为0 改进 Others 将其他不存在词库中的单词设置为“other” Word hashing 维度用来标记字母组合 RNN 存储前一个输入的信息 将隐藏层的信息存储起来，将该信息作为输入，让网络可以学习 例子 假设所有的权重为1，没有bias，激活函数都是线性的 输入序列： \\[ \\begin{equation} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} \\end{equation} \\] 初始的存储值为0 第一次输入: \\[ \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\] 两个存储值都会变为2 输出为 \\[ \\begin{bmatrix} 4 \\\\ 4 \\end{bmatrix} \\] 第二次输入： \\[ \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\] 两个存储值会变为6 输出为 \\[ \\begin{bmatrix} 12 \\\\ 12 \\end{bmatrix} \\] 小结 改变输入序列的顺序，会改变输出 反复使用这样的结构 如上图所示，当前输入，可以获得前一个输入的信息，可以简单区分出一些不同 可以将网络做深 类别 Elman Network：传递前一个输入的隐藏层信息 Jordan Network：传递前一个输出的信息 双向RNN 将前向输入和逆向输入相同位置上的隐藏信息拼合到一个，存储当前单词前后的信息 LSTM 结构 由4个部分组成 Input Gate：由信号控制是否接收输入 Memory Cell：存储记忆的信息 Forget Gate：由信号控制是否清除现在存储的信息 Output Gate：由信号控制是否输出 一共有4个输入，1个输出 输入：3个signal，1个正常输入 计算过程 激活函数f输出为0到1，可以用来控制是否接收信息 输入\\(z\\)和\\(z_i\\)，经过激活函数得到\\(g(z)\\)和\\(f(z_i)\\)，将两者相乘，即为\\(g(z)f(z_i)\\) 这一步用来控制输入 输入\\(z_f\\)，经过激活函数得到\\(f(z_f)\\)，与Memory Cell中存储的信息c进行相乘，即为\\(cf(z_f)\\) 这一步用来控制是否要清楚当前信息c 将前两步获得的数据相加获得新的存储信息\\(c^\\prime\\) \\[ c^\\prime = g(z)f(z_i) + cf(z_f) \\] 输入\\(c^\\prime\\)和\\(z_o\\)，经过激活函数得到\\(h(c^\\prime)\\)和\\(f(z_o)\\)，将两者相乘，得到输出a，即 \\[ a = h(c^\\prime)f(z_0) \\] 这一步用来控制输出 在RNN网络架构中，一般用LSTM代替神经元 缺点 参数过多 每一个LSTM都需要4个输入，需要4倍的参数*LSTM数目 解决方案：利用当前输入，生成4个向量，所有的LSTM使用对应位置上的同一向量 可以将上一个LSTM网络中的c拼合输入中 多层LSTM 学习目标 BPTT（Backpropagation through time） RNN训练较为困难 RNN参数的损失曲面十分陡峭 可以采用clip，剪切掉超过某一范围的参数，强制在一定范围内 损失曲面会抖动严重的原因 参数的细微改变，会导致后面的输出发生巨大变化（梯度爆炸），或者一直为0（梯度消失），学习率无法调节 LSTM的优势 可以解决梯度消失的问题（不是梯度爆炸） fotget gate关闭可以消除前面记录信息的影响，摆脱梯度消失 记录的信息和输入可以拼合 RNN的应用场景 Many to one Sentiment Analysis 语句分析，将其分类 输入：向量序列 输出：向量标签 Key Term Extraction 关键词的提取 输入：向量序列 输出：一个向量 Many to Many（输出序列较短） 输入和输出都是序列，输出序列较短 Speech Recognition 好棒棒这种叠词，可能无法识别 Connectionist Temporal Classification (CTC) 加入了额外的符号\\(\\phi\\)来代表空 CTC是识别每一个字母的 Many to Many （没有限制） 输入和输出都是序列，且长度没有限制，可以不一样 -&gt; Sequence to sequence learning Machine Translation Beyond Sequence Syntactic parsing Sequence-to-sequence Auto-encoder Text 要理解一个句子的意思，单词的顺序不可以忽略 Sequence-to-sequence Auto-encoder Speech 不定长度的序列的降维 发音相近的词语转换为向量后，会聚集在一定区域 音频归档分为可变长度的音频段，然后可以对语音进行检索 将语音片段转换为向量后，我们希望向量能够表示这个语音片段 Encoder和Decoder是联合训练的 Attention-based Model DNN/RNN可以通过Reading Head Controller在Memory中找到自己想要的相关信息 就像人类的大脑一样，可以去记忆中去搜索相关的知识 DNN/RNN同时也可以写入Memory 应用 Reading Comprehension 对文本进行语义分析，每一个句子转换为一个向量 DNN/RNN读取向量信息 Visual Question Answering 输入一张图片和一个问题，输出问题的答案 利用CNN将图片的每一个区域转换为一个向量 Speech Question Answering 听力考试 RNN和Structured Learning的比较 RNN，LSTM 非双向的RNN不能够考虑整个序列 Cost和eroor总是相关的 deep HMM，CRF，Structured Perceptron/SVM 使用了Viterbi，考虑了整个序列 但双向的RNN也可考虑 可以明确考虑标签依赖关系 Cost是error的下界 一起使用 Speech Recognition: CNN/LSTM/DNN + HMM Semantic Tagging: Bi-directional LSTM + CRF/Structured SVM Self-Attention 输入 输入是一个向量，经过模型后输出一个数字或者类别 输入时一组向量，经过模型后输出一组数字或者类别 输入时是一组向量 语句 语音 图（如关系图） 语句 如一句话“this is a cat”，我们需要对数据集进行编码处理，以便识别各个单词 One-hot Encoding 一键编码 有多少个单词，就构建一个多长的向量 这样做的后果是模型不知道单词之间的关系，它们是割裂的 Word Embedding 词嵌入 对词语进行编码处理，相似意义的词会聚集 语音 进行加窗处理 图 将每一个节点都视为一个向量 输出 每一个向量都有一个标签 例子 整个序列有一个标签 例子 模型自己决定有多少个标签（seq2seq） 思考 对于一段文本，我们需要考虑前后文，如判断\"I saw a saw\"中各个单词的词性 对于前后文问题，我们可以将一个窗口内的单词都输入一个全连接层中，但是这样较前面的和较后面的很难一起考虑 考虑整个句子，可以将整个句子丢入一个全连接层中，但是这样模型会变得很复杂 可以使用自注意力机制 自注意力 实现 考虑当前向量和序列中其他向量的关系 可以对两个要关联的向量进行某种运算 Dot-product Additive 对于当前向量，计算出一个query向量，对于其他的向量，各有一个key向量，可以分别计算得出注意力分数(attention score) 可以对注意力分数(attention score)进行softmax运算 然后基于注意力分数(attention score)，利用value向量，提取出信息 对于所有的向量，平行地进行运算 对于这样相同的运算，我们可以将这些向量拼合成矩阵，进行矩阵运算，加快运算 q，k，v的获取 query：\\(Q = W^q I\\) key：\\(K = W^k I\\) value：\\(V = W^vI\\) 注意力分数的获取 \\[ A = K^T Q \\\\ A \\mathop\\rightarrow^{softmax} A^` \\] 信息的获取 \\[ O = V A^` \\] 小结 Multi-head Self-attention 多头注意力机制 可以探索不同类型之间的联系 Positional Encoding 在注意力机制中，序列输入后，模型没有对于位置的信息，不同距离的两个向量对于模型来说是一样的 我们可以在向量中加入位置信息，每一个位置有一个独一无二的向量\\(e^i\\) 手工制作 从数据中学习 自注意力的应用 NLP 自然语言处理 语音处理：Truncated Self-attention 图像 Self-attention GAN DEtection Transformer(DETR) Self-attention和CNN的比较 CNN是简化版的self-attention CNN是可以只关注一个感受野的self-attention self-attention是复杂版的CNN Self-attention是具有可学习感受野的CNN Self-attention适合更多的数据，而CNN适合比较少的数据 Self-attention和RNN的比较 RNN不可以平行处理，而自注意力可以 Self-attention for Graph Transformer Seq2seq 对于序列到序列的模型，我们输入一段序列，模型会输出一段序列，且输出序列的长度取决于模型 语音识别(Speech Recognition) 机器翻译(Machine Translation) 语音翻译(Speech Translation) 文本转语音合成器(Text-to-Speech(TTS) Synthesis) Seq2seq for Chatbot 其他的一些应用 Seq2seq for Syntactic Parsing Seq2seq for Multi-label Classification Seq2seq for Object Detection Transformer Encoder-Decoder架构 结构 Encoder Layer Norm的调整 Decoder Transformer的Decoder是一个自回归的Decoder（Autoregressive Decoder） Masked Self-attention 在解码器中，第一个注意力机制是一个掩码的自注意力 这是因为解码器需要输出一个序列，它需要在不知道后面的信息的情况下，根据前面的信息，来预测当前的输出 所以我们在训练时，需要将后面的序列盖住 在训练时，我们给解码器的输入都是正确答案，帮助其完成训练 停止符号 为了让输出停止，我们需要定义一个停止符号，提示解码器停止输出 NAT 非自回归 AT需要前面的输出信息，才能给出当前的输出 NAT可以并行地给出输出，速度比AT要快，生成更加稳定 NAT解码器如何决定输出的长度 预测输出序列的长度(predictor) 输出一个固定长度的长序列，忽略终止符END后面的Token Cross attention Cross attention部分会将Encoder的最后一个输出转换为Decoder部分的\\(k\\)和\\(v\\)矩阵 不同的连接方式 训练Transformer Encoder和Decoder联合训练 使用softmax和cross entropy进行训练 Teacher Forcing模式 将输出数据作为Decoder的输入，使其向正确输出靠近 Tips Copy Machanism 复制机制 将一些不太需要翻译的人名、地名等直接复制 Guided Attention Monotonic Attention Location-aware attention 在一些任务中，输入和输出是单调排列的，顺序关系不可改变 例如下面的序列中，在输出时，第一个输出中，Attention关注的是后面的序列 Beam Search 在Attention Score中，模型会选择当前分数最高的，但是多次选择后，综合起来，不一定是最好的选择 Beam Search会综合考虑全局的分数，选择最好的结果 但是最好的选择不一定会产生很好的结果 Sampling 在一些任务中，生成序列时，Decoder需要一些噪声(Randomness)，sample是指从某些分布中sample中出来的噪声 Scheduled Sampling 采样由Decoder决定 Optimizing Evaluation Metrics 优化方案的选择 Cross Entropy BLEU score Reinforcement learning 各种各样的Attention 自注意力机制的运作 利用Query和Key构造一个Attention Matrix 自注意力只是一个大型网络的一个模块 当序列的长度N足够大的时候，自注意力在计算占主导 通常用于图像处理 人工干预来跳过一些Attention Matrix的计算 Local Attention/Truncated Attention 只计算标记的部位，其他位置设置为0 跟CNN有些相似 Stride Attention 选中从自身向左右两边跨越规定的步数的部位，进行计算 Global Attention 在原来的序列中添加special token 关注(attend)每一个token，可以收集全局信息 被每一个token关注(attend)，知道全局信息 图中前两个是special token 小结 可以在一个模型中同时使用不同的Attention 不同的head可以使用不同的模式 关注一些Matrix中关键的部分(Critical Parts) 小数值直接设置为0 如何快速估计注意力权重较小的部分 Clustering Reformer Routing Transformer 步骤1 基于相似度对query和key进行聚类标注 步骤2 相同类别的才计算attention weight 不同类别的设置为0 Learnable Patterns 通过学习来获取需要计算的部位 不需要完整的Attention matrix 可以减少key和value的长度 query的长度不变，因为输出长度需要不变 使用卷积 使用参数矩阵相乘 注意力机制计算 利用输入I获取Q、K、V进行运算，得到输出O 为加快运算，采用矩阵计算的形式 计算方式的不同 \\(K^TQ\\)先计算 \\(VK^T\\)先计算 三个矩阵计算顺序不同，进行乘法次数不同，结果相同 而Q、K、V三个矩阵的运算中， 正常进行计算，会进行\\((d+d^\\prime)N^2\\)次乘法运算 先计算\\(V K^T\\)的话，会计算\\(2d^\\prime dN\\)次乘法运算，小于正常运算次数，序列长度N是大于维度d的 注意力计算的变换 我们利用当前向量的\\(q\\)矩阵，来与自身和其他向量的\\(k\\)矩阵进行运算，再经过\\(softmax\\)运算，得到\\(\\alpha^{\\prime}\\)，即 \\[ \\alpha^{\\prime}_{1,i} = \\sum_{i=1}^{N}\\frac{exp(q^1\\cdot k^i)}{\\sum^N_{j=1}exp(q^1\\cdot k^j)} \\] 这里以\\(a^1\\)向量(\\(q^1\\)矩阵)为当前向量。 再将得到的\\(\\alpha^{\\prime}\\)与对应的\\(v\\)矩阵进行运算，合成起来得到\\(b^1\\)，即 \\[ b^1 = \\sum_{i=1}^{N}\\alpha^{\\prime}_{1,i}v^i = \\sum_{i=1}^{N}\\frac{exp(q^1\\cdot k^i)}{\\sum^N_{j=1}exp(q^1\\cdot k^j)}v^i \\] 在这里，我们可以对\\(softmax\\)的计算进行改变 \\[ exp(q\\cdot k) \\approx \\phi(q) \\cdot \\phi(k) \\] 这里的\\(\\phi\\)是一个变换，那么\\(b\\)的计算可以变换为 \\[ \\begin{equation} \\begin{aligned} b^1 = \\sum_{i=1}^{N}\\alpha^{\\prime}_{1,i}v^i &amp;=\\sum_{i=1}^{N}\\frac{exp(q^1\\cdot k^i)}{\\sum^N_{j=1}exp(q^1\\cdot k^j)}v^i \\\\ \\\\ &amp;= \\sum^N_{i=1}\\frac{\\phi(q^1)\\cdot\\phi(k^i)}{\\sum^N_{j=1}\\phi(q^1)\\cdot\\phi(k^j)}v^i \\\\ \\\\ &amp;= \\frac{\\sum^N_{i=1}\\phi(q^1)\\cdot\\phi(k^i)v^i}{\\sum^N_{j=1}\\phi(q^1)\\cdot\\phi(k^j)} \\end{aligned} \\end{equation} \\] 而分母项可以进一步进行调整 \\[ \\begin{equation} \\sum^N_{j=1}\\phi(q^1)\\cdot\\phi(k^j) = \\phi(q^1) \\cdot\\sum^{N}_{j=1}\\phi(k^j) \\end{equation} \\] 那么\\(b^1\\)的计算进一步调整 我们可以利用\\(k\\)和\\(v\\)提前计算好部分值，需要时直接调用即可 这样子，有一部分不用重复进行计算 这样利用\\(\\phi(k)\\)和\\(v\\)计算出来的M组向量相当于有M组模板，\\(\\phi(q)\\)与之相乘是在进行选择。 通过学习来构造Attention Matrix 注意力机制通过\\(q\\)和\\(k\\)来计算Attention Matrix，但是我们可以将整个矩阵是为网络的参数 小结","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李宏毅","slug":"深度学习/李宏毅","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://ye2222.github.io/tags/DeepLearning/"}]},{"title":"originL4-LabTalk","slug":"originL4-LabTalk","date":"2022-05-30T13:15:29.000Z","updated":"2023-04-26T11:19:54.734Z","comments":true,"path":"posts/54556/","link":"","permalink":"https://ye2222.github.io/posts/54556/","excerpt":"","text":"LabTalk的介绍 1. 什么是LabTalk？ LabTalk 是 OriginPro 原生脚本语言。 2. LabTalk能干什么？ 通过 LabTalk， 可以方便地进行自定义操作， 例如列值计算， 自定义拟合函数， 批量处理等。 3. 如何运行LabTalk？ 脚本窗口（窗口: 脚本窗口） 命令窗口（窗口: 命令窗口） 代码编译器（Code Builder，自定义程序按钮，查看: 代码编译器） 设置列值对话框 自定义拟合函数 等等 例子 1234567891011121314151617181920212223242526// 运行文件中的Main节run.section(Custom, Main); // Custom.ogs在用户文件夹下，不用指定路径，也不需要文件后续（.ogs） run.section(%YCustom.ogs, Main); // 也可以指定文件的全路径，%Y为用户文件夹的字符串存储器 // 运行文件run.file(MyLabTalk); run.file(%YMyLabTalk.ogs);//第一个例子代码：// 激活窗口中的book1window -a book1; // 命令语句newsheet name:=shifted cols:=11; // X-functioncolcopy irng:=1!1:2 orng:=2!1:2; // X-functionfor (int i = 3; i &lt;= 11; i++)&#123; range r1 = 2!2, r1i = 1!$(i), r2i = 2!$(i); // 命名范围，替换记法，对象 int id1 = list(max(r1), r1); // LabTalk 函数 int idi = list(max(r1i), r1i); // LabTalk 函数 int offset = idi - id1 + 1; range rresult = 1![]; r2i = rresult; r2i.lname$ = r1i.lname$; // 对象属性 r2i.unit$ = r1i.unit$; // 对象属性 r2i.comment$ = r1i.comment$; // 对象属性&#125; 基本特性 1. 数据类型与变量 有九种数据类型： double, int, constant, dataset, string, stringarray, range, tree, Graphic Object等 Numeric int在LabTalk中是按double类型存储的 constant一旦声明，就会保存在System Variable中，新的session也可以调用它 想要在新的session中使用constant，需要在CONST.CNF文件下定义这个constant 没有复数形式，如需要可以使用Origin C 0，NANUM， -1.0E-290到1.0E-290之间的值会在逻辑上判定为False 12type $(-1e-290?1:0); // Returns 0 (False)type $(1/0?1:0); // Returns 0 (False), where 1/0 == NANUM Dataset 该类型存储数字类型的array 2. 字符串变量 定义：双引号不是必须的 1string s = hello world; 美元符号（$）在定义时可有可无，在赋值时是必须的 1234567string str1$ = &quot;hello world&quot;;string str2 = str1;str2$ = ;// str1string str3 = str1$;str3$ = ; // hello world 赋值给另外一个变量时，在后面加上$，如str1 = s$ 调用字符串时，需要在后面加上$ 字符串寄存器： %H --&gt; 当前处于活动状态的窗口名称 %X --&gt; 当前项目所在目录 %Y --&gt; 用户文件夹 … 3. 语法 赋值语句，宏语句，命令语句，运算语句，函数语句 分号的使用：; 注释：//， /* */ 操作符：运算操作符，字符串连接，赋值操作符，逻辑关系操作符，条件操作符 条件语句：if, if else, switch, break, exit, continue 循环语句：repeat, loop, doc -e, for 对象 语法： 对象名.属性 对象名.方法(参数列表) 12345678910111213141516171819202122232425page.= // 查看对象的属性 // 层级包含关系 // page -&gt; worksheet -&gt; column page.active = // 当前窗口处于活动状态的表，可以查看，也可以设置 page.nlayers = // 有几个工作表 wks.ncols = // 工作表有几列 wks.addcol() // 调用对象的方法，工作表中添加列 wks.name$ = // 工作表的名称 wks.col2.lname$ = // 工作表第二列的长名称 wks.col2.unit$ = // 工作表第二列的单位 // 对当前工作簿窗口的所有工作表执行相应的代码 doc -e LW &#123; wks.ncols = 4; // 每个工作表都设置成4列 &#125; // 对当前图形窗口的所有图层执行相应的代码 doc -e LW &#123; layer.y.from = -1; // y轴刻度从-1开始 layer.y.to = 48; // y轴刻度结束于48 &#125; 命令 语法： 命令 [-选项] [参数列表] 123456789101112newbook; // X-Function，新建工作簿 string FileString$ = system.path.program$ + &quot;Samples\\Curve Fitting\\Linear Fit.dat&quot;; open -a %(FileString$); // 打开数据，-a为选项，%(FileString$)为参数 // 运行Python命令 run -py print(&quot;Hello Origin&quot;); // 对特定的对象群体执行给定的脚本 // document -e object &#123; script &#125; doc -e W &#123; // doc与document一样, W是项目里的所有工作表 type %H; // 打印工作表的名称 &#125; 命名范围 语法： range [-选项] RangeName = RangeString 1234567891011121314151617181920range rb = [Book2]; // 命名范围为Book2这个工作簿 range rs = [Book2]Sheet1!; // 命名范围为Book2这个工作簿下的Sheet1工作表 range rc1 = [Book2]Sheet1!col(1); // 工作表下的第一列 range rc2 = [Book2]Sheet1![]; // 工作表下A列的1至5行 range rc3 = [Book2]1![]; // 同上，这里用了索引的方式，第一个工作表的第一列 // 复制整列数据到另一个工作表 range r1 = [Book3]Sheet1!col(1); range r2 = [Book4]Sheet1!col(2); r2 = r1; // 循环每列，复制数据和长名称 win -a Book2; // 激活Book2为当前窗口 newsheet; // 当前工作簿里新建一个工作表 for (i = 1; i &lt;= 5; i++) &#123; // 从1循环到5 range r1 = Sheet1![]，第一列的第一行到最后一行 range r2 = Sheet2!$(i); // 第二个工作表的第i列 r2 = r1; // 复制数据 r2.lname$ = r1.lname$; // 复制长名称 &#125; 替换记法 %A-%Z 字符串寄存器是最简单的替换，在脚本执行过程中，寄存器被产生的内容替换。 1234FDLOG.open(A); // 打开的文件名存于%A%A = ;%B = FDLOG.path$; // 文件所在目录存于%B%B = ; %( ) 用于解析出%(str$)，%(range)，工作表信息，列名，单元格，图例等。 123456string str$ = Book5; range r1 = [%(str$)]1![]1!1; type %(r1); // 解析出r1 %([Book5]Sheet1, 3, 2) = ; // 解析出Book5里的Sheet1工作表中的第三列第二行 %([Book5]Sheet1, 5, 1) = %([Book5]Sheet1, 3, 2) * 2; $( ) 用于把数字表达式替换为相应的数字字符串。 1234567891011121314151617181920212223dataset ds1 = &#123;1, 3, 5, 7&#125;; // 定义数据集 type $(ds1); // 打印 type $(ds1, *2); // 两位有效数字 loop (ii, 1, 4) &#123; // 循环从1到4 wks.col$(ii).lname$ = col$(ii); // 设置当前工作表的1到4列的长名称 &#125; // 历遍项目里的所有工作簿和矩阵簿里的所有工作表和矩阵表 doc -e LB &#123; loop (var, 1, [%H]!wks.ncols) &#123; // 当前历遍表中的所有列循环 type &quot;此列为：[%H]%(page.active$)!%(wks.col$(var).name$)&quot;; &#125; &#125; /*此列为：[Book5]Sheet1!A此列为：[Book5]Sheet1!B此列为：[Book5]Sheet1!C此列为：[Book5]Sheet1!D此列为：[Book5]Sheet1!E此列为：[Book5]Sheet2!A此列为：[Book5]Sheet2!B*/ %n 用于给宏和脚本传递参数，n为整数，为1-5，即最多可传递5个参数。 1234def my_add &#123;type -b &quot;(%1 + %2) = $(%1 + %2)&quot;&#125; // 定义一个宏my_add 100 11; // 调用宏，并传递两个参数，100由%1处理，11由%2处理run.section(Custom, Main, 100 11); // 注意传递的参数是空格分隔，不是逗号 X-Function X-Function 是 Origin 里的一个框架，可以用于创建执行特定任务的工具。大部分 X-Function 都可以通过 LabTalk 脚本来运行。 Origin 里很多分析工具都是通过 X-Function 来实现的，包括在学习中心里的很多APP，也是由 X-Function 来做的。 123456win -a Book6; // 先把Book6设置为当前活动窗口 // 平滑 for (int ii = 2; ii &lt;= 4; ii++) &#123; // 从2到4历遍 range rr = $(ii); // 定义命名范围为当前工作表的第ii列，这里用到了$( )的替换法来定义 smooth -r 2 iy:=rr; // 调用smooth这个X-Function，-r 2是选项，iy:=rr是参数 &#125; 如何生成脚本？ 12newsheet -d; // -d选项可以打开对话框，然后在对话框里有相应的生成脚本的方式 smooth -d; 注意：有些 X-Function 设计时并不允许打开对话框，此时使用-d会出错！ 查找X-Function及帮助文档 123lx *norm*; // 查找带norm这几个字符的X-Function help smooth; // 打开smooth的帮助文档，是打开chm还是在线文档，取决于 帮助: 使用在线帮助文档 是否选中 smooth -h; // 直接显示文档内容 宏和函数 宏的定义与调用 1234567// 语法 define macroName &#123; script &#125; // define可简写成def // 例子 def helloOrigin &#123; // 定义一个叫helloOrigin的宏 type -b &quot;Hello Origin&quot;;&#125;helloOrigin; // 调用宏 内置函数 1234567891011// 数值类的函数 win -a Book7; // 激活Book7工作簿 range ra = col(A); range rb = col(B); rb = ave(ra, 5); // 调用ave函数 // 字符串类的函数 win -a Book8; // 激活Book8工作簿 range ra = col(A); range rb = col(B); rb = token(ra, 1, &quot;,&quot;); // 调用token函数 自定义函数 12345678910111213141516// 语法 function dataType funcName(Arg1, Arg2, ..., ArgN) &#123; script; &#125; // 例子 function int iCountDays(dataset ds, int iDay) &#123; // 定义 int iCount = 0; for (int ii = 1 ; ii &lt;= ds.GetSize() ; ii++) &#123; if (weekday(ds[ii], 1) == iDay) &#123; // 是否为星期五 iCount++; &#125; &#125; return iCount; &#125; win -a Book9; // 激活Book9工作簿 iVal = iCountDays(col(1), 6); // 调用 iVal = ; 实用例子 使用模板批量绘图 12345678910run.section(dofile.ogs, OnInstallTemplate, &quot;%XTemplatForBatch.otpu&quot;); // 安装模板// run.section(dofile.ogs, OnUnInstallTemplate, &quot;%XTemplatForBatch.otpu&quot;); // 卸载模板win -a Book10; // 激活Book10string bookName$ = %H; // 保存好Book10的名称for (int ii = 1; ii &lt;= 3; ii++) &#123; // 有三个工作表要历遍 string wksName$ = bookName$!layer$(ii).name$; // 拿到当前工作表的名字 plotxy iy:=[%(bookName$)]%(wksName$)![]; // 在模板的第一个图层画图 plotxy iy:=[%(bookName$)]%(wksName$)!(1,3) plot:=200 ogl:=2; // 在第二个图层画 plotxy iy:=[%(bookName$)]%(wksName$)!(1,4) plot:=200 ogl:=3; // 在第三个图层画&#125; 批量峰值分析 Book11的Sheet1工作表中的数据，从迷你图可以看到，C、E、F这三列Y数据，噪音比较多，不适合做峰值分析（会产生很多不准确的峰值），而现在又想对工作表中的Y数据进行峰值分析的批量处理，同时要把噪音过大的过滤掉，如何做？ 1.生成主题 选中B列，然后点菜单 分析: 峰值及基线: 峰值分析。 目标为峰拟合，在寻峰步骤，点 查找，然后下一步，再保存主题，关闭。 2.通过主题批量峰值分析 点菜单 分析: 峰值及基线: 通过主题批量峰值分析。 输入选择所有列，主题为刚保存的主题，结果表为峰属性。 在脚本的每次处理前运行脚本里输入改下脚本： 123456789dataset dr; // 定义一个数据集变量 fft_filters iy:=_ry filter:=high oy:=dr; // FFT高通滤波，可以获得噪音分量，_ry对应批处理时当前处理的y数据，输出结果噪音放到dr stats dr sd:=nSD; // 对噪音进行统计分析，并取得噪音的标准差放到变量nSD stats _ry sd:=sSD; // 对信号进行统计分析，并取得标准差放到变量sSD if (nSD^2 &gt; sSD^2 * 0.3) &#123; // 对比噪音的方差与信号的方差，如果噪音的方差大于信号方差的0.3倍，则认为此信号噪音太大，不适合做峰分析，跳过此信号 _skip=1; // _skip此变量标志是否要跳过当前的数据不处理 &#125; else &#123; _skip=0; // _skip为0，则表示当前数据不跳过，会被处理 &#125; 点确定按钮。 工作本脚本 1.工作表脚本 新建一个工作簿。 点菜单 工作表: 工作表脚本，打开工作表属性对话框。 在脚本选项卡下，在脚本触发条件框中，勾上两个复选框，并在第二个复选框下填上：1:end，表示任意数据的变动都触发。 脚本则使用下面的脚本： 123456789wks.userParam1 = 1; // 显示第一个用户自定义参数行 wks.userParam2 = 1; // 显示第二个用户自定义参数行 wks.userParam1$ = &quot;均值&quot;; // 设置第一个用户自定义参数行为均值 wks.userParam2$ = &quot;标准差&quot;; // 设置第二个用户自定义参数行为标准差 for (int ii = 2; ii &lt;= wks.ncols; ii++) &#123; // 第二列开始历遍工作表中的所有列 range rr = $(ii); // 取得第ii列的命名范围 col($(ii))[D1]$ = $(mean(rr), .2*); // 计算第ii列的均值，并把值取小数后两位放到自定义参数均值行 col($(ii))[D2]$ = $(stddev(rr), .2*); // 计算第ii列的标准差，并把值取小数后两位放到自定义参数标准差行 &#125; 导入一个数据看结果。 2.导入多个ASCII文件 打开导入多个ASCII文件对话框，选择多个要导入的ASCII文件。 在脚本分支下，把上面用过的同样的脚本复制粘贴到每个文件导入后运行脚本的文本框中。 点确定按钮。","categories":[{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"origin","slug":"画图/origin","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/origin/"}],"tags":[{"name":"origin","slug":"origin","permalink":"https://ye2222.github.io/tags/origin/"}]},{"title":"originL3-统计图表","slug":"originL3-统计图表","date":"2022-05-18T07:27:55.000Z","updated":"2023-04-26T11:19:54.711Z","comments":true,"path":"posts/10755/","link":"","permalink":"https://ye2222.github.io/posts/10755/","excerpt":"","text":"_post/originL1.md 箱线图 点击箱体，可以对箱体进行调节 多因子组箱线图 直方图 堆积直方图 XYY3D条状图 难点： 首先要理解XYY3D条状图，它的Y决定Z方向的条状高度 要想让柱形变扁，需要调整轮廓中的Z方向条状宽度为0 想让刻度显示名称，可以在刻度线标签中进行修改 分布图 简单的分布图 分布图加轴须 组边际图 边际直方图 组边际图","categories":[{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"origin","slug":"画图/origin","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/origin/"}],"tags":[{"name":"origin","slug":"origin","permalink":"https://ye2222.github.io/tags/origin/"}]},{"title":"origin图形分析技巧","slug":"origin图形分析技巧","date":"2022-05-09T07:24:36.000Z","updated":"2023-04-26T11:19:54.751Z","comments":true,"path":"posts/51426/","link":"","permalink":"https://ye2222.github.io/posts/51426/","excerpt":"","text":"注：标题中括号内是使用到的工具 几何 距离 任意两点之间的距离（Data Cursor -- 数据光标） 可使用数据光标对点进行标记，然后设置得出相对量，计算出距离 左边工具栏，图中红色框中的图标即为Data Cursor 右键数据信息，点击设置，修改标题报告为两个标记点坐标和相对量 也可以使用APP中的Distance Between Two Points 面积 计算曲线的面积 计算曲线面积（Gadgets:Integrate -- 快捷分析） 菜单栏上的快捷分析，积分选项，可调整输出和基线，以及是求绝对面积还是数学面积 计算闭合曲线面积（Polygon area -- 闭合曲线积分） 计算交叠区域面积（App Overlap area） 使用App：Overlap area 切线（APP：tangent） 使用App：tangent 分析 屏蔽数据 屏蔽散点 选择要屏蔽的点，可在下栏中选择隐藏 连接缺失部分 下图屏蔽了第三个点 在根部的Graph的显示选项中，选择跨缺失数据连接直线 拟合时自动更新设置 屏蔽点之后，拟合线仍不变 可以设置自动更新 分析范围 计算区域统计值（快速分析-统计） 快速分析-统计-打开对话框 可以选择起始和结束、以及平均线 快速分类（快捷分析-集群分析） 快捷分析-集群分析 对话框直接默认确定 自己选中区域然后创建分类 实现分类 设置分析范围（数据） 也可使用左侧工具栏中的数据选择器 例子：将函数分为两部分进行拟合 查找 交点 二维（快捷分析） 使用快捷分析 默认确定后可在图中自行调整ROI框的大小 点击箭头可以输出相交点的坐标到工作簿中 可在设置中选择交点标记，在图中绘制处交点坐标 三维（APP 3D Surfaces intersection） 红色区域即为交集 查找指定Y值处的X值 快速浏览多图层中指定X处所有曲线的值（APP Level Crossing） Crossing Level即为Y轴数值 可选择输出 将输出结果中的x,y值拖动到图中，再修改图像为散点图，可以显示交点 调整一下 批量标注X值处的Y值（快捷分析） 使用快捷分析 一些重要的点 高亮数据 左侧工具栏选用高亮工具 可在工具簿中选中数据，会在所有图中高亮显示，也可在图中选中数据点 对于选中的点可以进行创建子表、删除、屏蔽等操作，屏蔽可以反选没有选中的点","categories":[{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"origin","slug":"画图/origin","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/origin/"}],"tags":[{"name":"origin","slug":"origin","permalink":"https://ye2222.github.io/tags/origin/"}]},{"title":"origin-配色方案","slug":"origin-配色方案","date":"2022-05-08T06:38:28.000Z","updated":"2023-04-26T11:19:54.697Z","comments":true,"path":"posts/14571/","link":"","permalink":"https://ye2222.github.io/posts/14571/","excerpt":"","text":"配色 配色的分类 柔和的颜色：饱和度低 强烈的颜色：饱和度高 配色的基本原则 颜色为数据逻辑服务 有意义的颜色 显示分组 用不同的颜色来表达区别 用相近的颜色表示同一分组 用配色突出关键数据 多用相似色 同一色系或者色轮上相邻 多个数据的话不要超过三个色系 建议多用内置颜色或者参考成熟的配色方案 根据图面积选色 大面积的图使用柔和的颜色(柱状图/面积图) 小面积的图使用强烈的颜色(折线图/散点图) 用数据说话，用图片表达，用逻辑自洽 图片既包含数据，又必须体现出数据之间的逻辑关系以及数据和结论的逻辑关系 配色：突出关键数据，展示逻辑关系 配图：最好有一个主色调(1/3到一半)，然后使用近似色作为辅助色，其他颜色为互补色、组合色 尽可能使用柔和的颜色（明色、暗色、混色），避免使用亮绿亮蓝亮青亮紫（纯色） 近似色：光谱上相近的颜色 互补色：对比色 配色推荐 柱状图 不同形式及颜色设置方法 by Plot 简单柱状图 堆叠柱状图 堆叠分组柱状图 by Point 分组柱状图 1组柱状图 -- 1列数据 配色推荐 1列数据 单色 不要用标准色 ，避免明度高的颜色，即图中的标准色 饱和度高的颜色， 选用窄一些的柱体； 饱和度低的颜色， 选用宽一些的柱体 方法 直接采用柔和的颜色条中的颜色 在内置颜色条中选择饱和度低的颜色 设置透明度 常见的问题 给某个柱体单独设置颜色 单独选中这个柱体，添加特殊点(这样单独选中就添加了特殊点了)，进行颜色设置 把柱体对应到某个数据列 2组柱状图 -- 2列数据 配色推荐 内置颜色条随便用 注意不要选太接近的颜色就好 3组柱状图 -- 3组数据 配色推荐 相近的色系。 不要选用对比太强烈的颜色 不要滥用图案，不建议图案颜色共同使用 黑白图可以把灰度和图案进行搭配 常见的问题 画出有三维感的二维柱状体 点击柱体，在绘画属性中，选择渐变填充，单色，方向选择水平方向，从中心到两边 多组柱状图 -- 多组数据 这里以6组数据为例 堆叠柱状图配色推荐 面积小的部分使用比较深或者鲜明的颜色 多组数据配色推荐 类似的颜色(相近的色系， 或者相近的明度) 直接采用内置或者分享配色中的数量相近的颜色条 饼图 特点 颜色按点设置 通常颜色比较多 饼图配色推荐 面积小的部分使用比较深或者鲜明的颜色 用内置配色搭配 折线图 简单折线图 要点 交错重叠的折线不能太多。 如果超过四条， 建议改用堆叠折线图或者考虑其他表达方式。 使用强烈的颜色 线条设置得粗一些，一般设置为3 黑白图: 颜色， 线型，双线综合运用 折线图使用的颜色 Color4Line Candy Bold1 Bold2 strong14 strong_vangogh7 都是一些比较强烈的颜色 多条成组数据折线图 特点 连续变化的成组数据 配色推荐 渐变，使用Palette 适用于多条曲线的 Palette Bright Spetrum Rainbow_Modify Heatmap4ColorBlind Plasma Maple 散点图 普通散点图 配色推荐 空心圆点， 边缘用深灰色，中间填柔和的颜色 实心圆点， 用强烈的颜色加透明度 按需用大小和颜色表达第三第四维度数据 大小选择某一列数据映射，颜色选择某一列数据进行映射 种类繁多的散点图 方法 综合运用 形状和颜色 要点 数量多的用小点，少的用大点 可以复合两种样式表达 （例：圆圈+圆点，星星+圆点） 等高线图 配色推荐 使用 Pallette 如何使颜色过渡平滑：设置 minor level 热图 可以在设置颜色选项中选择 自定义配色 颜色管理器 可以选择是颜色列表还是调色板 导入颜色方案 新建颜色方案 提取图片中的颜色 模板提取 导入图片可以提取图片中的颜色 用滴管提取 Palette（调色板）的创建 数据点、数据线 配色注意点 单条数据线 最常用（保险）色：黑色、红色 最流行：深灰蓝、深紫蓝 不宜单独使用绿橙等中间颜色 需要叠加其他色彩信息的单条数据线，宜采用黑色 数据非常细密、跳变很多、噪声大，宜使用深灰色，更清晰 灰度图、伪彩色图中的线条、标记，宜使用红色、黄色、橙色、亮绿等较亮的色彩 多彩色中的同类型数据点，宜使用黑色 如果还不够清楚，加上白色或黑色轮廓 多彩色图中的线，宜采用与白色或者背景色对比较强的颜色 两条数据线 色彩对比：黑 -- 红/蓝/绿，常用于主次对比 红蓝对比：常用于对比数据对比 互补色对比：蓝-橙，紫红-青绿 深浅对比：黑-灰，深蓝-浅蓝等，通常表示同一个量的变化 饱和度对比：灰-红，灰-蓝，常用于上叠拟合线、平滑线 拟合（平滑）数据线：拟合线用彩色，背景数据用灰色 其他的用法 多条数据线 三条数据线常用：黑/灰-红-蓝（黑/灰表示次要） 组合配色 很多数据、成组数据 彩虹色渐变 近似色渐变 深浅渐变 组合渐变 常选颜色区域","categories":[{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"origin","slug":"画图/origin","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/origin/"}],"tags":[{"name":"origin","slug":"origin","permalink":"https://ye2222.github.io/tags/origin/"}]},{"title":"originL2","slug":"originL2","date":"2022-05-07T13:46:24.000Z","updated":"2023-04-26T11:19:54.732Z","comments":true,"path":"posts/51937/","link":"","permalink":"https://ye2222.github.io/posts/51937/","excerpt":"","text":"2022b新功能 导出图为SVG格式 支持导出图为SVG格式 窗口排列和窗口贴靠 新对话框可按所需顺序排列窗口 支持 theme 保存设置再次使用 拖拽窗口标题栏到工作 区边缘， 窗口自动贴靠一侧分屏显示 Shift + 拖拽，并排排列窗口 Alt + 拖拽，两窗口交换位置 支持GeoTIFF图片 GeoTIFF 文件的导入导出 对 GeoTIFF 图片进行图像处理并进一步绘图 (批量) 导入 GeoTIFF 格式的栅格数据进行处理分析 对RS/GIS数据的进一步支持 对堆叠矩阵或图像进行插值 添加 IDW 和 Kriging算法 导入 NC 时计算指定月份的年平均数据，例如夏季 （6-9月） 堆叠矩阵支持时间维度上计算周期性的数学计算 Notes窗口支持富文本及图片表格 优化了Symbol Map对话框 距离标注工具 一键添加小图编号 坐标轴支持统一的数量级设置 断开公式等数据链接，保留数值 跟着论文学绘图 原位拉曼光谱图 数据导入（多个数据文件的导入） 使用导入多个ASCII文件（菜单/数据/从文件导入/多个ASCII文件），选中需要导入的11个文件 数据筛除（删除重复的X列） 原数据中出现了重复的X列，进行删除 选择数据(菜单/编辑/选择) 选择跳行模式，设置好测试选中目标行，进行删除（隐藏只是将列隐藏，还是会存在） 设置X轴数据（时间） 将其插入到数据列的长名称中 绘制等高线图 全选数据，选择（菜单/绘图/等高线图/等高线图-颜色填充） X值：列标签，长名称 Y值：第一列 将图片的等高线去除 绘制三维网格图 转换数据为XYZ形式 将刚才的数据转换为XYZ数据（菜单/工作表/转换为XYZ数据） 设置X值为X数据跨列/列标签/长名称，Y值为第一列 XYZ数据网格化（插值处理） 将数据转换为矩阵（菜单/工作表/转换为矩阵/XYZ网格化） 在网格设置中，设置行数和列数，会平滑地插入相应位置的数据 绘图 选中矩阵，选择绘图/带投影的3D颜色映射曲面图 这时候绘制出来的是曲面的颜色映射填充 我们需要的是网格线的颜色映射 首先将曲面的填充设置为逐块填充，颜色设置为白 然后将网格的线条颜色的颜色映射开启，线条宽度设置为2 拼图 使用Layout，插入两张图片 砂石骨料的颗粒级配图 成品图 数据 直接全部选中绘制折线图 图形设置 接触三条线段的组合，可以对一条直线单独设置 设置坐标轴 x轴的范围为0.0625~8，我们可以使用Log2的类型 添加上轴和右轴，以及网格 使用B-样条让两条虚线变得光滑 网格设置为浅灰色，修改图例为长名称 球体密度剖面图 数据 通过测量得到同一个入射角不同半径下球体的密度数据。 希望画出球体密度剖面图，用不同颜色的圆环表达不同的密度 一个圈对应一组数据 数据处理 有5组数据，所以有5个圆，需要构造5个圆 绘图 利用前两列绘制出极坐标图 启用填充 采用颜色映射 线条宽度设置为0 中间区分度不够，增加色阶级别 删除中间的圆形轴，添加下轴 设置好的图形 多图层绘制攻略 图的结构 多轴图 绘制原理 重叠的图层 大小相等，上下重叠 图层相互链接 轴根据需要设为一一对应 绘图方法 直接在绘图菜单中选择所需要的模板绘图 双Y轴 绘图-多面板/多轴-双Y轴柱状图 三Y轴 下面图的绘制方法 先用取值范围差异较大的两列进行一个双Y轴柱形图的绘制 然后在图层管理中，添加第三列的柱形图到这张图中。 往图层中添加数据 将前一个例子中的前两列变成堆叠柱状图 需要将前两列作为一个组，才能进行堆叠操作，所以需要进行添加数据操作 在图层中选择使用累积堆叠后，便可以将前两列合成一列 画图之后修改绘图类型 绘图模板中3Y-YYs默认绘制的是折线图 我们可以对每条数据进行绘图类型的修改，达到我们想要的效果 将两列数据转换为柱形图后重叠 需要在Graph中勾选上红色框中的选项 工具栏或者菜单添加图层 激活图像窗口后，可以在菜单栏上的插入中选择插入新图层 也可以在右侧选择添加所需要的轴作为新图层 在关联坐标轴刻度中，自定义的X1和X2代表轴的两端 公式中的X1和X2是指关联图层X轴的两端 这里如果点在线的下面，可以在图层内拖动它们的顺序，来决定哪个在上方 APPs Double Y Toolbar Double X Plot 组合图 一些操作 对函数进行积分 选中图像后，在快速分析中，选择积分 可对积分区域、积分函数进行调整 列统计 可以选择分组进行列的统计 以某一些列作为分组的依据 可以选择保留的位数 横坐标的设置 在类型选项中，可以设置非线性的刻度，例如下图的Log2 色阶带的头尾去除 快速屏蔽一些列（隔一列删除一列） 对三维的数据进行插值 可以使用xyz网格化 在网格设置中，设置列数和行数，会根据行列数进行插值形成一个矩阵 三维谱图绘制 绘制要点 数据构造 数据导入 X值不一样时需插值(Analysis：Mathematics：Interpolate Y from X) 删除重复的X 为Y数据列设定采样时间 插值平滑（不是必须的） XYZ 网格化 从Virtual Matrix 转换为 XYZ 数据 （Worksheet: Convert to XYZ） XYZ Griding 平滑数据 (Worksheet: Convert to Matrix: XYZ Gridding) 3D Smooth app 绘图推荐 Y偏移堆积线图 瀑布图 等高线图 线框曲面图 在Word中插入Origin导出的图片 推荐使用EMF/WMF/SVG，其他的Word会限制分辨率，透明背景也可能会发黄 Origin导出图片到Word中， 复制页面 复制页面为图片 导出为EMF/WMF","categories":[{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"origin","slug":"画图/origin","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/origin/"}],"tags":[{"name":"origin","slug":"origin","permalink":"https://ye2222.github.io/tags/origin/"}]},{"title":"李宏毅深度学习L2","slug":"李宏毅深度学习L2","date":"2022-05-07T12:26:55.000Z","updated":"2023-04-26T11:19:54.795Z","comments":true,"path":"posts/31959/","link":"","permalink":"https://ye2222.github.io/posts/31959/","excerpt":"","text":"机器学习的任务攻略 对于我们的模型，首先要保证训练损失在一个可接受的范围，才去考虑测试集损失的问题 根据训练损失过大做出的模型调整 当查看我们的训练损失过大的时候，需要调整我们的模型，有几个方向可以考虑 Model bias 模型偏差 问题 我们的模型可能过于简单，模型的参数取值范围内只能构建一个比较小的函数集，没办法满足我们的需求，也就是模型的弹性不够 我们的最优解只是小范围函数集内的最优解 解决方案 重新设计模型，让它更加具有弹性，也就是范围更大 Optimization Issue 优化问题 问题 我们的模型使用优化方法是梯度下降，但是模型只是找到局部的最低点便停下来了 判断是Model Bias或者是Optimization Issue 这并不是过拟合，因为在训练的数据集上，深层的损失也比浅层的损失大 在构建模型的过程中，我们可以先尝试浅层的模型，它们比较容易优化，再尝试比较深层的模型 如果深层的模型的损失比浅层的损失要大，说明是优化问题 根据测试集损失过大做出的模型调整 Overfitting 过拟合 在训练损失小，测试集损失很大的情况下，就是overfitting（过拟合）发生了 一个极端的例子 分析 我们的数据是来自一个分布的，模型得到的函数会尝试根据所给的分布上的训练点集去拟合这个分布 解决 More training data 更多的训练数据集 Data augmentation 数据增强 要合理，不要让模型学到奇怪的特征 constrained model 限制模型 我们知道数据的分布是二次函数时，可以限制模型为二次函数，得到比较好的结果 方法： 更少的参数，或者共享参数 更少的features Early stopping Regularization Dropout CNN限制比较大，针对图片和影像 但是也不能给模型太大的限制 偏差-复杂度的权衡 Validation set 起因 Testing Set 有公开的和保密的，在训练模型时，大家会拿公开的Testing Set跑模型看结果怎么样，然后来调整模型，但是因为公开的Testing Set可以多次使用，可能会使你的模型对于公开的Testing Set更好地拟合，但是放到保密的Testing Set会得到比较糟糕的结果 解决 可以将用于训练模型的数据Training Set分为两部分，即Training Set和Validation Set，在Training Set上跑了之后，用Validation Set作为验证来调整参数，其实它相当于前面公开的Testing Set，然后再用来跑公开的Testing Set，就是说不要去过度地根据公开的Testing Set去调整模型，这样，用来跑保密的Testing Set结果基本能够跟公开的保持一致 如何划分Training Set 方法：N fold Cross Validation 分成n段，轮流当Validation Set来进行训练 Mismatching 不一致 训练集和测试集的分布是不一致的 Critical Point 当梯度变得十分小的时候，Optimization会变得十分困难，这时候有两种情况： local minima 局部最小值 saddle point 鞍点 它们统称为critical point 数学推导 泰勒近似 当\\(\\theta=\\theta^{`}\\)时，根据泰勒公式 \\[ L(\\theta) \\approx L(\\theta^{`}) + (\\theta - \\theta^{`})^{T}g + \\frac{1}{2}(\\theta-\\theta^{`})^{T}H(\\theta-\\theta^{`}) \\] 相当于函数泰勒公式中，f(x)在\\(x_1\\)处 \\[ f(x) = f(x_1) + \\frac{f^{`}(x_1)}{1!} (x-x_1) + \\frac{f^{``}(x_1)}{2!}(x-x_1)^2 + o((x-x_1)^2) \\] 其中， g：Gradient(梯度) （下图中绿色部分） 是一个向量 \\[ g = \\nabla L(\\theta^{`}) \\\\ g_i = \\frac{\\partial L(\\theta^{`})}{\\partial\\theta_i} \\] \\(g_i\\)是损失函数对某一个参数的梯度 H：Hessian（下图中红色部分） 是一个矩阵 \\[ H_{ij} = \\frac{\\partial^{2}}{\\partial\\theta_i\\partial\\theta_j}L(\\theta^{`}) \\] 而在Critical point上，g的部分等于0 \\[ L(\\theta) \\approx L(\\theta^{`}) + \\frac{1}{2}(\\theta-\\theta^`)^TH(\\theta - \\theta^`) \\] 有三种情况： Local minima Local maxima Saddle point Local minima 所有的特征值是正的 Local maxima 所有的特征值是负的 Saddle point 特征值有正有负 一个例子 最优点(L最小)在(1, 1)和(-1, -1)这两个位置上 损失函数 在(0, 0)处， ​ 宝可梦、数码宝贝分类器 根据宝可梦和数码宝贝原画线条数目的多少可以来进行区分 我们可以找到一个阈值h大于这个值为数码宝贝，小于这个值为宝可梦 \\(H\\)是指候选函数的数目，即这个模型的复杂度，能够表达的函数集的大小 损失函数 使用的是错误率，也可以使用交叉熵 数据集和训练 数据集的形式 如果我们收集了所有的宝可梦和数码宝贝(记为\\(D_{all}\\))，我们可以找到最好的阈值(记为\\(h^{all}\\))，即 \\[ h^{all} = arg \\mathop{min}_{h}(h,D_{all}) \\] 但现实是，我们一般只能从所有数据中获取到一部分数据，将其作为训练数据(记为\\(D_{train}\\))(独立且相同的分布) \\[ D_{train} = {(x^1, \\hat{y}^1), (x^2, \\hat{y}^2),\\cdots (x^N, \\hat{y}^N)} \\\\ \\\\ h^{train} = arg \\mathop{min}_{h}(h, D_{train}) \\] 我们希望的是训练得到的阈值\\(h^{train}\\)能够在整体的表现上能够接近\\(h^{all}\\)，即 \\[ L(h^{train}, D_{all}) \\rightarrow L(h^{all}, D_{all}) \\] 从所有的数据中我们得到\\(h^{all}=4824\\) 随机采样200个数据样本作为\\(D_{train1}\\)，得到\\(h_{train1}\\) 在总体上数据表现较好 再随机采样200个数据样本作为\\(D_{train2}\\)，得到\\(h_{train2}\\) 总体表现较差 我们想要的是在训练集上训练得到的\\(h^{train}\\)能够在总体数据上表现能够接近理想中的\\(h_{all}\\) \\[ L(h^{train}, D_{all}) \\rightarrow L(h^{all}, D_{all}) \\] 可以转化为 \\[ L(h^{train}, D_{all}) - L(h^{all}, D_{all}) \\le \\delta \\] 那么\\(D_{train}\\)要满足 \\[ \\forall h \\in H, |L(h, D_{train}) - L(h, D_{all})| \\le \\delta/2 \\] 上述公式的推导 我们想要的是好的\\(D_{train}\\)，即 \\[ \\forall h \\in H, |L(h, D_{train}) - L(h, D_{all})| \\le \\epsilon \\\\ \\epsilon = \\delta/2 \\] 训练失败的概率 每一个点都是一个训练集 如果一个训练集\\(D_{train}\\)是坏的，至少有一个\\(h\\)会让 \\[ |L(h, D_{train}) - L(h, D_{all})| \\gt \\epsilon \\] \\[ P(D_{train}\\ is \\ bad) = \\mathop\\cup_{h\\in H}P(D_{train} \\ is \\ bad \\ due \\ to \\ h) \\\\ \\le \\mathop\\sum_{h\\in H}P(D_{train} \\ is \\ bad \\ due \\ to \\ h) \\] 这里概率加起来是会大于1的，那说明会经常发生 可以推导出 怎么使\\(P(D_{train} \\ is \\ bad)\\)变小 更大的N和更小的H 即更大的样本容量和更加简单或者说限制比较多的模型 更大的N 样本容量越大，越能够更好地接近总体的分布情况 更小的H H变小了，那么参数h的数目就会变少，一些表现较差的参数也会被筛除 一个例子 那如果模型的参数是连续的，该怎么选择 计算机内的一切都是离散的 如果使用更小的H就可以获取好的结果，那么为什么不直接使用很小的H 使用很小的H，我们的模型可能在数据上表现就是很差，去接近理想状态也没有意义 陷入了两难的境地 可以使用深度学习 训练的建议 -- Batch和Momentum Batch 批量 批量优化 将一个数据集分成多个batch，可以多次更新参数 小的batch和大的batch 现在我们有20个样本(N=20) batch size = N = 20，即整个数据集 batch size = 1 大的batch一般不需要更长的时间来计算梯度，除非batch实在太大了 小的batch需要更多的时间，在每一个epoch中计算梯度，即需要更多的时间来查看整个数据集 实例 小的batch有着更好的表现，而大的batch可能会导致Optimizaiton Fails Momentum 让梯度下降保持一个动量，可以跨过平坦的Local minima 当前参数的变化不仅取决当前的梯度，还取决于之前的变化 在损失函数到达一个比较平缓的梯度区间时，可以因为之前向右移动的趋势，而向右边移动 小结 小的batch size和Momentum可以帮助逃离critical points Optimization的总结 一些符号标记 SGD SGD with Momentum \\[ \\theta_t = \\theta_{t-1} - \\eta m_t \\\\ m_t = \\beta_1m_{t-1}+(1-\\beta_1)g_{t-1} \\] Adagrad \\[ \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{\\sum^{t-1}_{i=0}(g_i)^2}}g_{t-1} \\] 这种会累积之前所有的梯度，遇到一些需要你Learning Rate大的情况处理不了(如RMSProp中的图) RMSProp \\[ \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{v_t}}g_{t-1} \\\\ v_1 = g^2_0 \\\\ v_t = \\alpha v_{t-1} + (1-\\alpha)(g_{t-1})^2 \\] Adam 是SGDM和RMSProp的结合 \\[ \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{\\hat{v_t}}+\\epsilon}\\hat{m_t} \\] \\[ \\hat{m_t} = \\frac{m_t}{1-\\beta_1^t} \\\\ \\hat{v_t} = \\frac{v_t}{1-\\beta_2^t} \\] \\[ \\beta_1 = 0.9 \\\\ \\beta_2 = 0.999 \\\\ \\epsilon = 10^{-8} \\] Adam和SGDM的对比 Adam 训练快速 较大的差别（训练集和测试集） 不稳定 SGDM 稳定 很小的差别 更好的收敛 深度学习 我们想要的是 深度和宽度的对比","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李宏毅","slug":"深度学习/李宏毅","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://ye2222.github.io/tags/DeepLearning/"}]},{"title":"李宏毅深度学习L1","slug":"李宏毅深度学习L1","date":"2022-05-07T12:26:28.000Z","updated":"2023-04-26T11:19:54.794Z","comments":true,"path":"posts/32151/","link":"","permalink":"https://ye2222.github.io/posts/32151/","excerpt":"","text":"机器学习 基本任务 Regression 回归，预测一个值，期望其与实际值相等 损失函数一般使用平均方差（Mean Square Error） Classification 分类，输出多个概率值，判断输入属于哪一个类别 输出值可使用Soft-max将其转换为概率值 classfication的损失函数使用交叉熵（Cross-entropy） 交叉熵可以很好地衡量两个概率值之间的差异 一些概念 Soft-max 将多个Classification的多个输出值转换为概率值 激活函数（Activation function） Sigmoid 函数： 导数： 图像： ReLU 函数： \\[ f(X) = max(0,X) \\] 图像： 基本步骤 Function(Model) with unknown 函数的集合 Define loss from training data 计算一个函数得到的输出与预期值的差距 输入：一个函数（参数） 输出：函数的优劣程度 Error surface 图中的每一个点都是一个函数，颜色代表L(w,b)的大小 Optimization 可以通过梯度下降来寻找使损失函数变得最小的参数w，b 一些概念 Generalization 一般化 我们真正关心的是模型在新数据(testing data)上的错误率 使用更加复杂的模型 使用更加复杂的模型会使我们在训练的数据上表现的更好 但是这往往会造成在测试集数据上过拟合（overfitting） 使用Sigmoid函数构建非线性模型 Gradient Descent \\[ \\theta^* = arg \\mathop{min}{\\theta}L(\\theta) \\] 考虑一个参数w $$ \\[\\begin{equation} w^* = arg\\mathop{\\min}_{\\theta}L(w) \\end{equation}\\] $$ 步骤： 随机选取一个初始值\\(w^0\\) 计算梯度(导数)\\(\\frac{dL}{dw}|_{w=w0}\\) 如果为负，增加w 如果为正，减少w 更新参数： \\[ w^1 \\leftarrow w^0 - \\eta\\frac{dL}{dw}|_{w=w0} \\] 这里的\\(\\eta\\)称为学习率（learning rate） 考虑两个参数w和b \\[ w^*, b^* = arg \\mathop{min}_{w, b}L(w, b) \\] 它们的梯度： 步骤： 在线性回归模型中，损失函数是凹的，没有局部最优点 求梯度 \\[ L(w, b)=\\sum^{10}_{n=1} (\\hat{y}^n-(b+w *x^n_{cp}))^2 \\] \\[ \\frac{\\partial L}{\\partial w} = \\sum^{10}_{n=1}2(\\hat y^n-(b+w*x^n_{cp}))(-x^n_{cp}) \\] \\[ \\frac{\\partial L}{\\partial w} = \\sum^{10}_{n=1}2(\\hat y^n-(b+w*x^n_{cp})) \\] Learning Rate 学习率 步子太大的话容易错过最优点 步子太小速度太慢 Adaptive Learning Rates 可调整的学习率 基本思想：在每一个epoch中通过一些因素来减小学习率 一开始，我们离目标很远，所以要使用较大的学习率 在几个epoch之后，我们接近了目标，所以减少学习率 学习率不可能是one-size-fits-all 给了不同的参数，应该有不同的学习率 Vanilla Gradient descent \\[ \\eta^t=\\frac{\\eta}{\\sqrt{t+1}} \\\\ g^t=\\frac{\\partial L(\\theta^t)}{\\partial w} \\\\ w^{t+1} \\leftarrow w^t - \\eta^tg^t \\] Adagrad 使用了root mean square 将每个参数的学习率除以其先前导数的均方根（\\(\\sigma^t\\)） \\[ \\eta^t=\\frac{\\eta}{\\sqrt{t+1}} \\\\ g^t=\\frac{\\partial L(\\theta^t)}{\\partial w} \\\\ \\sigma^t = \\sqrt{\\frac{1}{t+1}\\sum^t_{i=0}(g^i)^2} \\\\ w^{t+1} \\leftarrow w^t - \\frac{\\eta^t}{\\sigma^t}g^t \\\\ \\] 化简 分子与分母作用相反，越大的梯度，我们应该走更大的步才对 最佳的步骤 Adagrad是在尝试用一阶导去估计二阶导 Backpropagation 参数\\(\\theta = {w_1, w_2, \\dots, b_1, b_2, \\dots}\\)，不断进行更新 链式法则 向前传递 向后传递 \\[ \\frac{\\partial{C}}{\\partial{z}} = \\frac{\\partial{a}}{\\partial{z}}\\frac{\\partial{C}}{\\partial{a}} \\\\ \\\\ \\frac{\\partial{C}}{\\partial{a}} = \\frac{\\partial{z^`}}{\\partial{a}}\\frac{\\partial{C}}{\\partial{z^`}}+ \\frac{\\partial{z^{``}}}{\\partial{a}}\\frac{\\partial{C}}{\\partial{z^{``}}} \\\\ \\\\ \\frac{\\partial{z^`}}{\\partial{a}} = w_3 \\\\ \\frac{\\partial{z^{``}}}{\\partial{a}} = w_4 \\\\ \\\\ 现在的问题是\\frac{\\partial{C}}{\\partial{z^`}}和\\frac{\\partial{C}}{\\partial{z^{``}}}的取值 \\] 情况一：有输出层 情况二：不是输出层，只是中间层 只能不断地往后算，直到输出层，然后向后传播 小结 \\[ 在拥有\\frac{\\part z}{\\part w}和\\frac{\\part C}{\\part z}的条件下，我们可以通过链式法则得到输出关于参数的梯度\\frac{\\part C}{\\part w} \\] Stochastic Gradient Descent(SGD) 随机梯度下降 对比 在每次更新时用1个样本来计算梯度，然后更新参数 随机也就是说我们用样本中的一个例子来近似我所有的样本，来调整θ Loss function L(f) = L(w,b) 衡量一组参数的好坏 常用的损失函数 Mean Square Error(MSE) Cross-entropy Classification: Probabilistic Generative Model 概率生成模型 分类任务 二元分类问题 给生成模型一个x，模型给出一个类别 Regression 输出1代表类别1，输出-1代表类别2 靠近1代表更大可能属于类别1，反之则是类别二 实际上就是划分出一道线，左边为类别1，右边为类别2 但是如果有一些分布得太远的点，会造成更大的错误 且只能区分两个类别 理想的选择 假设两个类别分别为两个箱子 Box1是类别1，Box2是类别2 \\(P(B_1)\\)代表数据集中\\(B_1\\)占总数的比例，则\\(P(B_2)\\)代表数据集中\\(B_2\\)占总数的比例 所以，我们拿到一个蓝色的球，它属于\\(B_1\\)的概率为 使用高斯分布 输入：向量x 输出：采样x的概率 方程的形状取决于平均值\\(\\mu\\)和协方差矩阵\\(\\sum\\) 假设我们数据集的点分布符合高斯分布 选用不同的平均值和协方差矩阵，会有不同的可能（different likelihood） 最大似然估计 最大似然原则就是选择使该概率最大的参数 进行分类 改进 使用相同的协方差矩阵 先验概率 Logistic Regression 逻辑回归 线性的二分类的分类模型 步骤一：函数集（Function Set） 函数集： \\[ f_{w,b}(x)=P_{w,b}(C_1|x) \\] 寻找\\(P_{w,b}(C_1|x)\\)，即拿到x，x属于\\(C_1\\)的概率 如果\\(P_{w,b}(C_1|x)\\ge0.5\\)，输出\\(C_1\\)，否则输出\\(C_2\\) \\[ z = w \\cdot x +b \\\\ P_{w,b}(C_1|x) = \\sigma(z) \\] \\[ \\sigma(z) = \\frac{1}{1+exp(-z)} \\] 步骤二：函数的优良程度（Goodness of a Function） 我们拥有n个数据集和它们对应的标签 假设数据是根据\\(f_{w,b}(x)=P_{w,b}(C_1|x)\\)生成的，对应给定的w和b，生成这些数据的概率为 \\[ L(w,b) = f_{w,b}(x^1)f_{w,b}(x^2)(1-f_{w,b}(x^3))\\cdots f_{w,b}(x^N) \\] 根据最大似然估计，最好的参数\\(w^*\\)和\\(b^*\\)会使\\(L(w,b)\\)最大，即 \\[ w^*,b^*=arg \\mathop{max}_{w,b}L(w,b) \\] 为了计算，我们将两个标签$C_1和C_2 $转换为1和0，然后进行最大似然估计 转换为两个伯努利分布的交叉熵 步骤三：找到最好的函数（Find the best function） 求导数 第一部分 第二部分 最后的结果 小结 两种方法参数更新的式子是一样的，但是函数的输出和目标不一样 使用不同的损失函数 如果我们使用的损失函数是Square Error 会出现一些问题 当我们的输出接近目标时，导数接近0 当我们的输出远离目标时，导数接近0 使用Cross Entropy时，我们可以快速地朝目标地方向走，但是Square Error则会比较平坦 离散模型和生成模型的对比 离散模型：直接寻找参数w和b 生成模型：学习到一个概率分布 相同的函数集，相同的数据集，但是会找到不同的函数 一个例子 使用Naive Bayes 生成模型的优点 在概率分布的假设下，需要的训练数据更少 在概率分布的假设下，对噪声更鲁棒 先验和类依赖概率可以从不同的来源估计 多分类 逻辑回归的局限性 逻辑回归是线性的分类模型 深度学习 基本步骤 Neural Network 不同的联系会指向不同的网络结构 网络的参数\\(\\theta\\)：神经元中所有的权重(weights)和偏差(biases) 给定网络结构，定义一个函数集 矩阵的操作 输出层 goodness of function 定义一个损失函数，找到一个函数，能够使损失函数的值最小化，起始也就是找到合适的参数 pick the best function 使用梯度下降，来寻找能让损失函数降到最小的参数 深度学习的一些建议 在训练集上表现不好 在训练集上表现好，测试集上表现不好 可能是Overfitting（过拟合） 各自的解决方法 新的激活函数 梯度消失问题 浅层的梯度较小，学习非常慢，几乎是随机的 与此同时，深层的梯度很大，学习很快，几乎要收敛了 这有可能是激活函数的原因，如图 因为链式法则不断乘小于1的数，导致梯度非常小的现象 sigmoid函数的导数，是在0~0.25这个区间的，这意味着，当网络层数越深，那么对于前面几层的梯度，就会非常的小 使用ReLU ReLU：Rectified Linear Unit 优点 计算快 解决消失梯度问题 ReLU的变种 Leaky ReLU Parametric ReLU 使用Maxout ReLU是Maxout的一种特殊例子 Adaptive Learning Rate 可调整的学习率 详情见L2 RMSProp Momentum Adam Early stopping Regularization 正则化 对参数进行惩罚--权重衰退 防止过拟合 L2 regularization L1 regularization \\[ \\theta = |w_1| + |w_2| + \\dots \\] Dropout 在每一层丢弃一些神经元 改变了网络的结构 pytorch实战部分 数据集 pytorch中主要使用的是Dataset和DataLoader 1from torch.utils.data import Dataset, DataLoader 我们可以构建自己处理数据集的类(继承Dataset) 12345678910111213141516171819202122# 数据集处理及读取class COVID19Dataset(Dataset): def __init__(self, x, y=None): if y is None: self.y = y else: self.y = torch.FloatTensor(y) self.x = torch.FloatTensor(x) # 这一部分读入并处理数据 def __getitem__(self, idx): if self.y is None: return self.x[idx] else: return self.x[idx], self.y[idx] # 这一部分提供为DataLoader返回一个数据的函数 def __len__(self): return len(self.x) # 这一部分为DataLoader返回数据集的长度 train_dataset = COVID19Dataset(x_train, y_train) DataLoader可以构建一批一批的数据集合，批量加载数据 123# 数据集的批量读取器train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True, pin_memory=True) 模型结构 pytorch中主要使用的是torch.nn 1import torch.nn as nn 我们可以构建自己模型结构的类(继承nn.Module) 1234567891011121314151617181920# 模型结构class My_model(nn.Module): def __init__(self, input_dim): super(My_model, self).__init__() self.layer1 = nn.Linear(input_dim, 128) self.layer2 = nn.ReLU() self.layer3 = nn.Linear(128, 32) self.layer4 = nn.ReLU() self.layer5 = nn.Linear(32, 1) # 模型的layers def forward(self, x): out = self.layer1(x) out = self.layer2(out) out = self.layer3(out) out = self.layer4(out) out = self.layer5(out) out = out.squeeze(1) # (B, 1) -&gt; (B) return out # 正向传播 损失函数 使用平均方差 1criterion = nn.MSELoss(reduction=&#x27;mean&#x27;) 优化器 更新参数 1optimizer = torch.optim.SGD(model.parameters(), lr=1e-5, momentum=0.9) 训练过程 12345678910# 训练过程for epoch in range(3000): model.train() train_pbar = tqdm(train_loader, position=0, leave=True) for x,y in train_pbar: pred = model(x) loss = criterion(pred, y) loss.backward() # 计算梯度 optimizer.step() # 更新参数 optimizer.zero_grad() # 清零梯度 简单的保存数据为csv文件 123456def save_in_csv(file,res): file_csv = codecs.open(file, &#x27;w+&#x27;, &#x27;utf-8&#x27;) writer = csv.writer(file_csv) for x in res: writer.writerow(x) print(&#x27;保存成功&#x27;)","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李宏毅","slug":"深度学习/李宏毅","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://ye2222.github.io/tags/DeepLearning/"}]},{"title":"originL1","slug":"originL1","date":"2022-05-05T01:42:14.000Z","updated":"2023-04-26T11:19:54.698Z","comments":true,"path":"posts/52129/","link":"","permalink":"https://ye2222.github.io/posts/52129/","excerpt":"","text":"基本界面 界面和语言设置 基本图像类型及要求 位图 位图也称为像素图，使用像素点来描述图像 特点：可呈现照片般的真实效果，其清晰度与分辨率直接相关 格式：TIFF JPG BMP 矢量图 矢量图以数学向量方式记录图像 特点：清晰度与分辨率无关 格式：EPS PDF PS WMF 等 科技期刊图版格式要求 绘图基础 数据导入 工作簿 矩阵工作簿 数据文件类型 ACSCII文件的导入 导入 来源和标题线 Digitizer 数据连接 连接到文件：Text/CSV、 Excel 、 MATLAB 等 连接到网页：使用数据连接器导入在线的第三方数据文件 连接到数据库 图形的绘制和导出 图形窗口层次结构 页面 图形窗口背景（白色区域） 图形 包含一个或者多个图层 图层 三要素 坐标轴 数据图 与之关联的图例或文本 内置的模板库 基本绘图方法 设置列的类型，选择列来绘制图形 选中列右键选择设置为 在下方菜单栏 选中当前的工作簿，选择想要绘制的图形 图表绘制对话框绘图 注意这里的点击添加！！！！ 图层管理对话框 小结 在工作表中选择数据绘图 导入数据，设置列类型 选择数据列（选中要绘制的列） 应用菜单 栏（工具栏 ）适宜的绘图模板 利用图表绘制对话框绘图 可在项目文件范围内选取不同工作表的数据列，绘制在同一图形上 可忽略工作表中数据列类型，为其重新指定列类型 图形定制 数据点 坐标轴 图层 图形对象 绘图细节对话框 在菜单栏的格式选项中 X、Y坐标轴 图例 工具和对象编辑工具栏 导出图形 导出图形选择项目管理器，选择想要导出的图形右键菜单，点击导出图形，也可以全部导出，在菜单栏上的文件中有导出的选项 一些快捷键和操作 赋予某一列函数公式 选择一列 Ctrl+Q，或者右键F(x)=这一行，选择对话框 在输入框内赋予该列关于某列的一个函数 设置图像的模板 对于你要保存的图像模板，右键选择保存模板或者保存模板为，可以命名模板和规定模型文件类型 将当前图像的绘制方法复制到其他工作簿中 右键图像选择复制(批量绘图) 选择你要绘画的工作簿 对图像放大和平移 z+鼠标滚轮：刻度的放大和缩小 x+左右移动：左右平移 ctrl+R：复原 更新图例 选中图例，右键，图例 图例的自动译码模型，可以选择自定义 自定义格式旁边右箭头可以添加格式，构成自己的图例样式 用色彩影射点 先选择添加色彩标尺，图中左边工具栏中四条色彩杆的图标 双击图像空白处可以弹出图像属性对话框 创建复制图后对原图修改，对复制图进行一键修改 对一张图像进行复制后，我们可以调整X轴、Y轴对应的数据，然后对原图进行修改，一键对所有复制图进行样式的同步 对原图的样式进行复制 在菜单栏的编辑中，选择粘贴格式(高级) 应用格式，选择适用范围 合并多个图像 在图层管理中修改图像中各个图像之间的间隔 默认情况下，如果拖动图形层并调整其大小，或者在合并时调整了该层的大小，则文字字体和其他图形对象将重新调整大小。将“缩放模式”设置为“固定因子”可以防止在调整图层大小时缩放字体大小/线条厚度。（此行为也可以在“打印详细信息”对话框（图层级别）的“大小”选项卡中进行控制。） 数据筛选器 以某一列的数值作为筛选值，选择右上方的漏斗图标，如图中所示 点击列左上角的绿色漏斗可以选择筛除数据 直接粘贴图像到Word 点击要复制的图像，Ctrl+J复制 在Word或者PPT中，Ctrl+V进行粘贴 可以在Word中选择编辑，打开Origin对图像进行调整 可以传送图像到PPT中 3D图像的叠加 双击图层1的图标 选中相同的短名称的，选择图像，按右箭头添加 利用矩阵导入图像 新建一个矩阵工作簿,点击数据，选择图像到矩阵","categories":[{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"origin","slug":"画图/origin","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/origin/"}],"tags":[{"name":"origin","slug":"origin","permalink":"https://ye2222.github.io/tags/origin/"}]},{"title":"hexo-更换图床-GitHub","slug":"hexo-更换图床-GitHub","date":"2022-04-10T05:38:49.000Z","updated":"2023-04-26T11:19:54.684Z","comments":true,"path":"posts/9183/","link":"","permalink":"https://ye2222.github.io/posts/9183/","excerpt":"","text":"简介 PicGo+GitHub+Typora图床设置 GiTee挂了，改用GitHub，借用CDN加速快速访问图片 步骤 1.PicGo的下载 从GitHub上下载PicGo的exe安装包，然后下载 PicGo下载地址 重装的话，记得从控制面板卸载，不然会出现错误 2.GitHub的注册和设置 注册的话都会吧 建立一个公共仓库 注意：GitHub仓库的默认分支是main 在账户设置里面生成一个token 在账户的settings里面往下拉找到Developer settings 在右边选择Personal Access tokens ​ 名字随意，Expiration是限制期限，选个无限期就可以了 下面的选择范围勾选个repo就可以了 生成后保存这个token，用于PicGo设置 3. PicGo的设置 这个就简单了，GitHub图床不需要在PicGo中下载插件 仓库名：就那个点开自己仓库上方的名字 用户名/仓库名 分支默认是main，也可以自己换一个，但没必要 Token就填上刚才那个生成的token 路径默认为空吧，加上自定义域名后失效了，没有放到images文件夹中，不过问题不大 自定义域名：这个是关键，使用了jsdelivr作为cdn加速，改变域名就可以 格式：https\"//cdn.jsdelivr.net/gh/[用户名]/[仓库名]@main @后面加的是分支名 这样就设置好了 4. Typora的设置 打开偏好设置-图像 选择上传图片，勾选上对应的选项 上传服务设定好之后测试 5. 测试 图片加载成功，而且速度挺快的","categories":[{"name":"hexo搭建","slug":"hexo搭建","permalink":"https://ye2222.github.io/categories/hexo%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ye2222.github.io/tags/hexo/"}]},{"title":"操作系统L22","slug":"操作系统L22","date":"2022-01-05T07:33:13.000Z","updated":"2023-04-26T11:19:54.775Z","comments":true,"path":"posts/27878/","link":"","permalink":"https://ye2222.github.io/posts/27878/","excerpt":"","text":"Page Replacement Mechanism 页面守护进程在开始时初始化； 页面守护进程定期检查页面使用情况（100ms）；如果免费页面数量不足，它将释放更多页面 四种类型的页面： unreclaimable 不可恢复：例如，锁定的页面、内核模式堆栈； swappable 可交换：回收前必须回写 syncable：脏的必须写回 discardable 可丢弃：可立即回收。 Page Replacement Algorithm 使用增强的LRU算法，每页维护两个标志：活动/非活动和引用或未引用。 在第一次扫描中，页面的参考位被清除。 如果在第二次扫描期间，页面被引用，则页面将被移动到不太可能回收的状态。否则，页面将移动到更有可能回收的状态。 Linux I/O Linux将设备(I/O)集成到文件系统中，称为特殊文件 special files 阻止特殊文件 block special files -- 磁盘等。 字符特殊文件 character special files -- 键盘、打印机、鼠标等。 Input/Output System Calls in Linux Linux系统中的每个I/O设备通常都有一个与之关联的特殊文件。 大多数I/O都可以通过使用适当的文件来完成。 某些特殊文件需要特殊的POSIX调用。 Implementation of Input/Output in Linux 每个特殊文件都与处理相应设备的设备驱动程序相关联。 主要设备编号——用于识别设备类型 次要设备编号——用于识别相同类型的设备 系统将索引到字符设备的哈希表中以选择适当的结构，然后调用相应的函数来执行工作。 The Linux File System 文件可以在目录中分组；目录存储为文件；目录可以包含子目录。 根目录名为/（斜杠），并且/字符也用于分隔目录名。 Stat System Call 对于每个文件，Linux都会记录其文件类型、大小、上次修改时间等，可以使用stat系统调用查看这些文件 Some System Calls for Directories mkdir，rmkdir：创建和销毁目录（目录只有在为空时才能删除） link：创建链接；取消链接：删除链接 chdir:更改工作目录 opendir、closedir、readdir、rewinddir：用于读取目录 The Linux Ext2 File System block 0:包含启动计算机的代码 superblock：包含有关文件系统布局的信息（i节点数、磁盘块数等） group descriptor：包含有关位图位置、组中空闲块和i节点的数量等信息。 two bitmaps：分别跟踪空闲块和空闲i节点 i-nodes：包含记帐信息以及足够的信息来定位保存文件数据的所有磁盘块 data blocks：存储所有文件和目录的区域 目录文件允许最多255个字符的文件名。 每个目录都由整数个磁盘块组成，因此可以将目录以原子方式写入磁盘。 文件和目录的条目在目录中按未排序的顺序排列。 条目不能跨越磁盘块。 The Structure of I-Node i-node放在i-node表中，i-node表是一种内核数据结构，用于保存当前打开的文件和目录的所有i-node。 如果一个块大小为1KB，地址长度为4字节，那么一个文件最多可以包含以下i节点索引多大 Ans： 16843020KB ≈ 16448.3MB ≈ 16.1GB Security in Linux Linux系统的用户社区由一定数量的注册用户组成，每个用户都有一个唯一的UID（用户ID），它是一个介于0和65535之间的整数。 用户可以被组织成多个组，这些组也用称为GID（组ID）的16位整数进行编号。 Linux中的基本安全机制很简单。每个进程都携带其所有者的UID和GID。 Security System Calls in Linux chmod：最常用的一种，用于更改保护模式 access：查看是否允许使用真实UID和GID进行特定访问 getuid、geteuid、getgid、getegid：返回真实有效的uid和gid chown、setuid、setgid：仅允许超级用户更改文件的所有者，以及更改进程的UID和GID 问题 守护进程优先级很低 block 0 no","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L21","slug":"操作系统L21","date":"2022-01-05T07:33:02.000Z","updated":"2023-04-26T11:19:54.774Z","comments":true,"path":"posts/28070/","link":"","permalink":"https://ye2222.github.io/posts/28070/","excerpt":"","text":"The Layers in a Linux System 操作系统控制硬件并为用户程序提供系统调用； Linux还提供POSIX所需的许多实用程序。 Linux集成程序 Linux Kernel 内核 内核直接位于硬件上，由以下部分组成： I/O设备组件 I/O devices Component 内存管理组件 Memory Management Component 进程管理组件 Processes Management Component 与Linux进程相关的概念 守护进程 Daemon：后台运行的一种特殊进程； 父进程 Parent process：分叉进程； 子进程 Child process：fork系统调用创建的新进程； PID：过程标识符，非零； 过程组 Process group：由其父代、后代、兄弟姐妹、子代和后代组成； 信号 signal：一个进程发送给另一个进程的信息、参数等。 进程实现 由操作系统维护以实现流程模型的表。（每个进程一个条目(entry)，称为进程控制块） 跟进程有关的系统调用 创建进程 fork系统调用创建原始进程的精确副本 父进程和子进程中的文件描述符、寄存器和其他所有内容都是相同的 PID用于区分过程。 调用过程会捕获内核并创建一个任务结构和一些其他伴随的数据结构； 然后Linux查找可用的PID，并更新PID哈希表条目以指向新的任务结构； 内存分配给子级的数据和堆栈段，并制作父级段的精确副本； 子进程开始运行。 POSIX Shell 基于系统调用fork、waitpid和exec的shell实现 ls Commands shell通过分叉自身的克隆来创建一个新进程。然后，新的shell调用exec，用可执行文件ls的内容覆盖其内存 POSIX Threads Thread Scheduling Linux线程是内核线程，因此调度基于线程，而不是进程。 常见的进程/线程调度算法： 先到先得 最短工作优先 循环调度 优先级调度 … Scheduling in Linux: O(1) Scheduler 两种队列：活动队列、过期队列 O（1）时间复杂度：从活动队列中选择优先级最高的任务。如果任务的时间量过期，它将移动到过期列表。 高优先级任务具有更大的时间量。 Memory Management in Linux 虚拟内存（VM）： 允许多个进程共享物理内存； 允许执行大流程。 提高虚拟机效率的技术： TLB，多级页表 Multiple Level Page Table 每个虚拟地址分为五个字段。每个目录项的值都是指向下一级目录之一的指针。 Linux中的内存管理是基于分页的；进程可以共享文本段。 Memory-mapped Files Linux中的进程可以通过内存映射文件访问文件数据，以便它们可以同时映射相同的文件。 Memory Allocation Mechanism 分配物理内存的新页帧的主要机制是页分配器。 页面分配器使用众所周知的buddy算法进行操作。 问题 Unix：1969 Linux：1991 A table include the process and all the information that process needs","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L20","slug":"操作系统L20","date":"2022-01-05T07:03:13.000Z","updated":"2023-04-26T11:19:54.772Z","comments":true,"path":"posts/44391/","link":"","permalink":"https://ye2222.github.io/posts/44391/","excerpt":"","text":"Malicious code （Malware） 恶意代码 传统计算机病毒(viruses)的定义：一组可以破坏计算机功能或数据并自我复制的计算机指令或程序，这些指令或程序被编程为或插入到程序中。 计算机病毒的官方定义不包括新的恶意代码。 恶意代码的定义：旨在破坏硬件或软件、窃取用户信息或未经授权干扰用户的软件或代码。 分类 传统计算机病毒 viruses 感染操作系统引导加载程序 感染可执行文件 感染数据文件 其他恶意代码 特洛伊木马，蠕虫，流氓软件，后门，移动恶意代码… Virus 病毒：一种特殊的程序，它可以通过将代码附加到另一个程序上而自我复制。一旦执行，病毒可以对受害者的计算机造成任何损害。 病毒=可以自我复制的程序 附加到另一个程序 损害赔偿 病毒作者的目的 迅速蔓延 难以察觉 难以删除 Worms 蠕虫：一种利用系统漏洞进行自我复制的恶意软件。无需附加到其他程序，它可以独立执行。 蠕虫会导致网络拥塞。 蠕虫由两个程序组成： 引导 the bootstrap 蠕虫本身 the worm proper 蠕虫首先隐藏其存在，然后试图将其引导传播到连接到主机的其他计算机。 Trojan Horses 通过名为特洛伊木马程序的特定程序控制受害者的计算机。 没有自我复制；没有自愿感染 通过隐藏在人们自愿下载的软件或网页中，闯入受害者的计算机。 一旦下载的特洛伊木马程序被执行，mal可以窃取受害者的文件，远程控制受害者的计算机 组成： 控制终端程序、特洛伊木马程序和特洛伊木马配置程序 特征： 隐身性：主要特征；无图标，不显示在软件管理器中等。 自动运行 欺诈：欺骗性的名字，常用的图标 自动恢复 自动打开特定端口 Mobile malicious code 移动恶意代码 新型病毒以手机为感染目标，以手机网络和计算机网络为平台，利用病毒信息攻击手机，造成异常。 How Viruses Work (I) 病毒通常用汇编语言编写，并使用一种称为“滴管”的工具插入程序 一旦安装在受害者的机器上，病毒就处于休眠状态，直到被感染的程序被执行。 一旦启动，它通常首先感染机器上的其他程序，然后执行其有效负载。 How to spread the viruses 将病毒放在经常进行复制操作的地方 复制后 感染硬盘上的程序 可能会在局域网上传播 作为电子邮件附件播放 使用电子邮件列表传播病毒 反病毒和抑制反病毒技术 完整性检查 integrity checking 行为检查 behavioral checking 病毒规避 提供高度安全性的操作系统 仅安装可靠制造商提供的软件 买一个好的防病毒软件包。 不要单击电子邮件的附件 对关键文件进行频繁备份 从病毒攻击中恢复 关闭计算机，在安全磁盘上重新启动计算机，然后运行防病毒软件 构建一个安全的操作系统是可能的，但并不实用 用户不愿意放弃原来的操作系统 用户希望拥有更多的功能，这意味着更复杂 可信系统：正式声明的安全要求并满足这些要求 可信计算基础：由执行所有安全规则所需的硬件和软件组成 Covert Channels 隐蔽通道 隐写术 封装的服务器仍然可以通过隐蔽通道泄漏给协作者。 问题 Data integrity System available 1.检查呼叫信息，不要接听异常号码的呼叫 2.小心地从网上下载文件 3.拒绝异常消息，尤其是带有链接的消息 4.在不必要时关闭无线和蓝牙 5.注意安全信息并采取预防措施 提高安全意识，使用保护工具并小心下载文件） 网络流量检测 更新软件并安装修补程序 备份重要文件 Check calling information and do not answer calls from abnormal numbers Download files from the Internet carefully Reject abnormal messages, especially messages with links Turn off wireless and Bluetooth when unnecessary Pay attention to safety information and take precautions","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L19","slug":"操作系统L19","date":"2022-01-05T04:44:42.000Z","updated":"2023-04-26T11:19:54.768Z","comments":true,"path":"posts/23463/","link":"","permalink":"https://ye2222.github.io/posts/23463/","excerpt":"","text":"The Security Environment Threats 威胁 目标和威胁： Data confidentiality Data integrity System availablity 排除外来者：病毒接管系统 Intruder 入侵者 入侵者：在他们没有生意的地方打听的人 常见类别： 非技术用户的随意窥探。 被内部人士窥探。 下定决心要赚钱。 商业或军事间谍活动。 Accidental Data Loss 意外数据丢失 常见的原因 自然灾害： 火灾，洪水，地震，战争 硬件或软件错误： CPU故障，不可读的磁盘或磁带，程序错误。 人类错误： 数据输入不正确，丢失磁盘。 Basic of Cryptography 密码学基础 编码： \\(C = E(P,K_E)\\) P：明文 \\(K_E\\)：加密密匙 C：秘文 E：加密算法 解码：\\(P = D(C,K_D)\\) P：明文 \\(K_D\\)：解密密匙 C：秘文 D：解密算法 Kerckhoffs的原则：加密算法应该是公开的，保密性应该只存在于密钥中。 Secret-Key Cryptography 私钥加密技术 单字母替换：使用键表将每个字符替换为新字符。 密钥加密也称为对称密钥加密，因为在给定加密密钥的情况下很容易找到解密密钥，反之亦然。 如果密钥足够长，则密钥加密是相对安全的。 Public-Key Cryptography 公钥加密技术 所有用户都使用一对加密密钥和解密密钥。加密密钥可以公开，而私有解密密钥可以保密。 加密密匙和解密密匙是不同的 给定一个精心选择的加密密钥，不可能发现相应的解密密钥。 步骤1：发送方使用加密密钥对单据进行编码 步骤2：接收方使用解密密钥对文档进行解码。 缺点：需要大量的计算成本。 Public-Key Encryption (RSA) RSA：最着名的公钥加密算法 一种方法 单向函数： 一个事实：对计算机来说，将真正大的数字相乘要比将真正大的数字因式分解容易得多。 Digital Signatures 数字签名 步骤1）发送方公开加密密钥并使用解密密钥对哈希值D进行编码 步骤2）接收器使用解码的加密密钥，并将其与计算的哈希值进行比较。如果值一致，则接受。 Authentication 认证 基本规则： 唯一身份验证 在用户访问系统之前完成 三项原则： 用户知道的东西 Something the user knows 用户拥有的东西 Something the user has 用户是什么 Something the user is 存储加密文件 使用salt来阻止加密密码的预计算 要检查用户拥有的某些物理对象， 磁条卡、磁卡、IC卡 测量用户难以伪造的物理特征。 Insider Attacks Logic Bombs 逻辑炸弹：公司的程序员可能故意在程序中隐藏bug， 例如，一种只要程序员输入每日密码就什么也不做的设备，而当程序员突然被炒鱿鱼而第二天又不输入密码时，它就会关机。 Trap door 插入到程序中的一段附加代码，以便绕过一些正常的检查。 Login Spoofing 一种通过提供类似但虚假的登录窗口窃取用户登录名和密码的方法 Outsider Attacks Buffer Overflow Attacks 问题 A：Data confidengially B：Data integrity C：System availability D：System availability C、B、A","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L18","slug":"操作系统L18","date":"2022-01-05T01:49:22.000Z","updated":"2023-04-26T11:19:54.766Z","comments":true,"path":"posts/39782/","link":"","permalink":"https://ye2222.github.io/posts/39782/","excerpt":"","text":"File System Performance 高速缓存 块高速缓存(block cache)或缓冲区高速缓存(buffer cache)是逻辑上属于磁盘但保留在内存中以提高性能的块的集合。 以前的所有分页置换算法都可用于确定在需要新块且缓存已满时应写入哪个块。 不希望数据块在高速缓存中放很久之后才写入磁盘 应定期写出所有数据块（例如，写出全天工作的）。 UNIX-系统调用syn会强制性地将修改的块立即写入磁盘。同步期间，更新每30秒在后台运行一次 MS-DOS-直写缓存=&gt;立即写入所有修改的块。 写入一个1K的块，一次写入一个字符 UNIX在高速缓存中保存全部字符，每30秒把该块写回磁盘一次 MS-DOS一次写入1B 块提前读 Block read ahead 在需要用到块之前，将块放入高速缓存，从而提高命中率； 适用于按顺序读取的文件； 如果文件被随机访问，预读没有帮助； 它会将磁盘带宽用于读取无用的块，并从缓存中删除可能有用的块； 减少磁盘臂运动 读取块需要一个访问I-Node和一个用于块的访问。 磁盘碎片整理 Defragmenting Disks 随着时间的推移，文件被创建和删除，磁盘变得碎片化，到处都是文件和漏洞。 创建新文件时，用于该文件的块可能分布在整个磁盘上，从而导致性能低下。 通过移动文件使其连续，并将所有（或至少大部分）可用空间放在磁盘上一个或多个大的连续区域中，可以恢复性能。 Windows有一个程序，defrag，正是这样做的。Windows用户应该定期运行它，SSD除外。 文件系统实例 MS-DOS文件系统 许多数码相机和MP3播放器都使用它。 使用固定大小的32字节目录项。 FAT文件系统总共有FAT-12、FAT-16、FAT-32三个版本，取决于磁盘地址包含有多少进制位 FAT-32只用到了地址空间中的低28位 \\(0.5KB \\ \\cdot \\ 2^{12} \\ = \\ 2MB\\) The UNIX V7 File System 问题 每一个磁盘块：1KB 每一个磁盘块号大小：4B 一个磁盘块可索引的磁盘块数量：1KB/4B = \\(2^8\\) 使用的是二级间接索引，所以文件最大大小为：\\(2^8\\cdot2^8\\cdot1KB \\ =2^6MB = 64 MB\\) 经过/读取一个块：27/9 = 3ms","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L17","slug":"操作系统L17","date":"2022-01-04T13:33:58.000Z","updated":"2023-04-26T11:19:54.765Z","comments":true,"path":"posts/40742/","link":"","permalink":"https://ye2222.github.io/posts/40742/","excerpt":"","text":"文件系统管理类和优化 Disk space management 磁盘空间管理 文件通常存放在磁盘上 存储 n 字节文件的策略 分配n个连续字节的磁盘空间 如果文件增长，则必须将其移动到磁盘上，这是一项昂贵的操作并会导致外部碎片化。 分配 [n/k] 个大小为 k 字节的块 块不需要相邻。 block size 块大小 当块大小增加时，磁盘空间利用率降低 内部碎片化，空间效率降低 这意味着每个文件，甚至一个1字节的文件，都要占用一整个柱面，小的文件浪费了大量的磁盘空间 当块大小减小时，数据传输速率降低 时间效率降低 大文件会跨越多个块，需要多次寻道与旋转延迟才能读出它们 通常大小 k = 512 字节、1k (UNIX) 或 2k Keeping Track of Free Blocks 记录空闲块 使用位图 bit-map Free blocks -&gt;1, Allocated blocks -&gt; 0 具有 (n) 个块的磁盘需要具有 (n) 位的位图 空闲块由 1 表示 已分配块由 0 表示 16GB 磁盘有 \\(2^{24}\\)个 1-KB 并且需要 \\(2^{24}\\) 位 → 2048 个块 使用链表 =\\(2^{24}\\)/255 = 65793 个块 使用磁盘块的链表 具有 1 KB 块和 32 位磁盘块号。 每个块保存尽可能多的空闲磁盘块号。 → 1024 * 8/32 = 256 个磁盘块编号 → 255 个空闲块（和）1 个下一个块指针. File System Backup 文件系统备份 备份是为了处理：从灾难或愚蠢中恢复。 备份的注意事项 整个或部分文件系统 Incremental dumps 增量转储：仅转储已更改的文件 压缩 Compression 备份活动文件系统 安全 转储磁盘的两种策略： Physical dump 物理转储： 从块 0 开始到最后一个磁盘块，按序输出到磁带上 优点：简单快捷 缺点：备份一切 Logical dump 逻辑转储： 从一个或多个指定目录开始，并递归转储自某个给定基准日期以来已更改的所有文件和目录 File System Consistency 文件系统一致性 大多数操作系统都有一个实用程序，称为文件系统检查器，用于测试文件系统的一致性。 例如，UNIX 中的 fsck，Windows 中的 sfc 可以进行两种类型的一致性检查： 块的一致性检查 文件的一致性检查 块一致性检查 构建两个表，每张表中为每个块设立一个计数器，都初始化为 0 第一个表中的计数器跟踪每个块在文件中出现的次数。 第二个表的计数器记录在空闲表或空闲位图中的出现次数， 然后，程序读取所有 i 节点并使用 i 节点构建文件中使用的所有块的列表（在读取每个块时在其文件计数器+1）。 检查空闲列表或位图以查找所有未使用的块（为空闲列表中的每个块在其空闲列表计数器+1） 文件系统状态 一致 每一块在第一个表计数器中为1，或者在第二个表计数器中为1 块丢失 将丢失的块添加到空闲列表 空闲列表中的重复块 磁盘块4在空闲块中出现了两次，重新建立空闲表 重复数据块 将数据块复制到空闲块 检查目录 使用一张计数器表，一个文件对应于一个计数器，从根目录开始检验，递归检查每个目录，对每个目录的每个文件，将文件使用计数器加1。完成后，会得到一张由i节点号索引的表，说明每个文件被多少个目录包围。 从根目录开始保留每个文件的计数器列表，递归检查每个目录。 对于每个文件，增加文件 i-node 的计数器 将计算值与存储在每个 i 节点中的链接计数进行比较。 i-node 链接计数 &gt; 计算值 = 目录条目数。 即使删除所有文件，i-node 链接计数 &gt; 0。因此不会删除 i-node。 解决方案：设置 i-node 链接计数 = 计算值 i-node 链接计数 &lt; 计算值 目录将指向未使用的 i-node 解决方案：设置 inode 链接计数 = 计算值 问题 Check Points Please describe the two methods for keeping tracks of free blocks. freelist bitmap Please describe the two strategies for dumping a disk. physical logical Please describe the two types of consistency checks . block file","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L16","slug":"操作系统L16","date":"2022-01-04T12:13:55.000Z","updated":"2023-04-26T11:19:54.773Z","comments":true,"path":"posts/24551/","link":"","permalink":"https://ye2222.github.io/posts/24551/","excerpt":"","text":"File Allocation 文件的实现 续 链表分配 Linked List Allocation 保持磁盘块的链表 缺点 随机存取速度慢 一个块中的数据量不是2的幂 由于指针占去了一些字节，每个磁盘块存储数据的字节数不再是2的整数次幂 采用内存中的表进行链表分配 Linked List Allocation using an index 从每个块中取出表指针字并将它们放入内存中的索引表FAT（File Allocation Table 文件分配表）中。 好处 整个块可用于数据 存储在内存中，速度快 缺点 占用大量内存。需要将整个表放在内存中 对于 200-GB 磁盘，该表将占用 600M 或 800M 内存。 I-node (index-node) 是一种数据结构，给每个文件赋予一个i节点 列出文件块的属性和磁盘地址 给定i节点，就能找到文件的所有块 这种机制有很大的优势，即只有在对应文件打开时，其i节点才在内存中 占用空间比FAT小 i节点的问题 Directories 目录的实现 打开文件时，文件系统使用路径名来定位目录条目(directory entry)。 目录：提供查找磁盘块所需的信息。 整个文件的磁盘地址（连续块） 第一个块的数量（链表） I-node的数量（I-node） 在哪里存储属性？ 在目录中还是在 I 节点中？ 两种存储属性的方法 目录条目中的固定大小条目、磁盘地址和属性 (MS-DOS/Windows) 每个条目仅引用一个 I 节点的目录 (UNIX) 处理目录中的长文件名 Fixed-length names 定长名称（浪费空间） In-line 行（删除文件时，会引入一个可变大小的间隙（a）） Heap 堆（堆管理需要额外的努力（b）） 如何搜索每个目录中的文件？ Linearly 线性（慢） Hash table 哈希表（更快的查找但更复杂的管理） Cache the results of searches 缓存搜索结果 Shared files 共享文件 共享文件用于允许文件出现在多个目录中。 目录和共享文件之间的连接称为链接(link)。 文件系统是有向无环图 (DAG)。 问题： 如果目录包含磁盘地址，则必须在目录 B 中制作C目录中的磁盘地址的副本。如果 C 或 B 往文件中添加内容，新的数据块将仅出现在添加工作的用户的目录中。 解决方案： 不要在目录中列出磁盘块地址，而是在一个小的数据结构中，目录指向这个数据结构。例如，索引节点、i节点 创建一个类型为 link 的新文件，其中包含链接到的文件的路径名 → 符号链接(symbolic linking) 两种方法的缺点 数据结构 符号链接 Virtual File Systems 虚拟文件系统 定义：虚拟文件系统（或虚拟文件系统交换机）是内核中的软件层，为用户空间程序提供文件系统接口。 从“the”文件系统到许多文件系统类型 示例 – Ext2、UFS(Solaris)、NFS、Ext3、Veritas、ReiserFS、XFS、ISO9660 (CD)、UDF (DVD) 等。 不同类型文件系统的相同 API 将文件系统通用操作与实现细节分开 系统调用程序到 VFS API 而不是特定的 FS 接口 非常灵活的用例： 远程用户文件和本地系统文件？ 从 USB 启动？ 网络？ 问题 文件如果很大，i节点块的大小需要变大，可能还需要指向另一块包含额外块地址的块的地址，所以B、C、D有关 Check Points Please describe the advantages and disadvantages of contiguous allocation. 随机读取速度快，实现简单，性能好（无需寻道） 需要提前知道文件大小，文件删除后留下碎片 Please describe the advantages and disadvantages of linked listed allocation. 文件大小可拓展，充分利用磁盘空间 随机存储慢，数据大小不是2的幂次 Please describe the advantages and disadvantages of FAT. 随机存储速度快，文件大小可拓展 占用内存大量空间，","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L14","slug":"操作系统L14","date":"2022-01-04T06:27:07.000Z","updated":"2023-04-26T11:19:54.762Z","comments":true,"path":"posts/40550/","link":"","permalink":"https://ye2222.github.io/posts/40550/","excerpt":"","text":"Redundant Array of Independent Disk (RAID) 独立磁盘冗余阵列 SLED：单个大容量昂贵磁盘 SCSI盘：采用SCSI接口的硬盘，SCSI是Small Computer System Interface（ 小型计算机系统接口 ）的缩写，接口速度快CPU占用率低 关键思想：数据分布在驱动器上，以允许并行操作。 这叫做划分条带（striping） Error Handling 错误处理 为什么总是出错？ 一旦制造技术改进到可以在特定密度下完美运行的程度，磁盘设计者就会转向更高的密度来增加容量。 两种解决方案：用备用扇区替换坏扇区，或者移动扇区。 Stable Storage 稳定存储器 RAID 首先不能对将坏数据写下的写错误提供保护，也不能对写操作期间的崩溃提供保护 在某些应用程序中，数据永远不会丢失或损坏是至关重要的。 稳定存储：目标是不惜一切代价保持磁盘的一致性 定义了三种操作 稳定写 -- stable write 稳定读 -- stable read 崩溃恢复 -- crash recovery 稳定写 将块写入驱动器 1 上，然后读取它以进行验证。 如果出了什么问题，再写和重读 n 次，直到它们起作用为止。 在连续 n 次失败后，该块被重新映射到备用块上并重复该操作（写和重读操作）直到成功。 写入驱动器 1 成功后，对驱动器 2 上的相应块进行写入和重新读取，如果需要，重复，直到它也最终成功。 稳定读 读取驱动器 1 上的块，如果这产生不正确的 ECC，则再次尝试读取，最多 n 次。 如果所有 n 次都失败，则从驱动器 2 读取。 同一块在两个驱动程序上都变坏的可能性可以忽略不计。 崩溃恢复 Clock 时钟 Clock Hardware 时钟硬件 可编程时钟 三个部件 晶体振荡器 计数器 存储寄存器 晶体振荡器可以产生几百MHz范围内的周期信号。 两种模式：一次性模式和方波模式 时钟滴答：由可编程时钟引起的周期性中断。 Clock Software 时钟软件 时钟驱动的功能 为了满足多个计时请求，操作系统需要用一个时钟模拟多个虚拟定时器。 Input Software: Keyboard 输入软件：键盘 按下或释放键时会产生中断。 键盘驱动程序从 I/O 端口提取扫描码，并将其转换为 ASCII 码。 两种模式：规范模式、非规范模式。 Mouse Software 两种常见类型： 带橡皮球的鼠标 光电鼠标 当鼠标移动了某个最小距离或按下或释放按钮时，就会向计算机发送一条消息。 (Dx, Dy, 按钮状态) Output Software：Text Windows 输出软件： 文本窗口 转义序列：escape sequences Output Software: GUI Windows GUI（图形用户界面）有四个基本元素：窗口、图标、菜单和指点设备。 Draw points, lines, rectangles: The Win32 SDK contain many APIs for GUI development. Bismap 位图: Copying bitmaps using Bitblt. Fonts：每个 Truetype 字体由围绕其周边的一系列点定义。 所有的点都相对于 (0,0) 原点。 Power Management 最常见的节省电池的方法是将设备设计为具有多种状态： 打开、睡眠和关闭。 以全时钟速度运行。 将电压降低 2 倍，时钟速度降低 2 倍，功耗降低 4 倍。 通过接受一些质量下降，用户可以使用给定的电池运行更长时间。 放弃颜色信息，以黑白显示视频。 使用无线电链接将任务发送到其他设备。 交易图像质量以减少传输过载。 问题 Summary Two kinds of I/O devices. The components of I/O device. Three ways to communicate with I/O. Disks: Magnetic disks (components, disk arm scheduling), RAIDs Clocks Terminals: Text windows, GUI Windows Power Management","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L13","slug":"操作系统L13","date":"2022-01-04T03:04:55.000Z","updated":"2023-04-26T11:19:54.761Z","comments":true,"path":"posts/23591/","link":"","permalink":"https://ye2222.github.io/posts/23591/","excerpt":"","text":"Interrupt Handlers 中断处理程序 中断处理程序隐藏中断效果最好：让驱动程序启动一个 I/O 操作块，直到中断通知完成 启动一个I/O操作的驱动程序阻塞起来，直到I/O操作完成并且产生一个中断 中断程序完成它的任务，然后解开启动它的驱动程序 中断完成后，必须在软件中执行以下步骤： Device Drivers 设备驱动程序 每个连接到计算机上的I/O设备都需要某些设备特定的代码来对其进行控制 Device-Independent I/O Software 与设备无关的I/O软件 独立于设备的软件的基本功能 执行所有设备共有的 I/O 功能 并为用户级软件提供统一的接口。 设备驱动程序的统一接口 缓冲 Modem：调制解调器 盘 Magnetic Disk 磁盘 Hard disks and floppy disks 硬盘和软盘 Organized into cylinders, tracks, and sectors. 组织成圆柱体、磁道和扇区 Disk Hardware 所有现代磁盘现在都支持一种称为逻辑块寻址的系统 磁盘扇区从0开始连续编号，不管磁盘的几何规格如何 Disk Formatting 磁盘格式化 在使用磁盘之前，应对磁盘进行低级格式化(low-level format)操作。 每个磁道由多个扇区组成，扇区之间的间隔很短。 Cylinder Skew 柱面斜进 Cylinder skew：当低级格式被放下时，每个磁道上扇区0的位置与前一磁道的偏移 Disk Interleaving 磁盘交错 动机：当复制到内存完成时（需要一些时间成本），控制器将不得不等待几乎整个旋转时间才能让第二个扇区再次出现。 单交错：可以在连续的扇区之间给控制器以喘息的空间以便将缓存区复制到主存 Disk Arm Scheduling Algorithms 磁盘臂调度算法 读取或写入磁盘块所需的时间由 3 个因素决定 寻找时间 seek time 旋转延迟 rotational delay 实际数据传输时间 actual transfer time 寻道时间占主导地位 错误检查由控制器完成 FIFO 先进先出 Shortest Seek First, SSF 最短寻道优先 Elevator Algorithm 电梯算法 问题 Check Points Briefly describe the structure of a disk. What is cylinder skew? What is interleaving? What are the three factors that determine the time of reading data from disk? Briefly describe two disk arm scheduling algorithms? Number the sectors in a staggered manner seek time rotational delay actual tr","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L11","slug":"操作系统L11","date":"2022-01-03T13:03:58.000Z","updated":"2023-04-26T11:19:54.759Z","comments":true,"path":"posts/40358/","link":"","permalink":"https://ye2222.github.io/posts/40358/","excerpt":"","text":"内容 与分页内存管理相关的一些问题 Segmentation 分段 Paged Memory Management 分页内存管理 CPU生成的地址被分为 Page number(p) 用作页表的索引，页表包含物理内存中每个页面的基址 Page offset(d) 结合基地址来定义发送到内存单元的物理内存地址 p是到页表的索引 d是页表上的偏差 分页系统中的设计问题 Local versus Global Allocation Policies 本地与全局分配策略 全局算法在所有可运行进程之间动态分配页框。 本地算法为单个进程分配页面。 全局算法用于防止颠簸(thrashing)并将分页率保持在可接受的范围内： A: 太高 -&gt; 为进程分配更多的页框。 B: 太低 -&gt; 分配进程较少的页框。 Page Size 页面大小 small page size 优点：内部碎片较少 内部碎片 internal fragmentation 随便选择一个正文段、数据段或堆栈段很可能不会恰好装满整个页面，多余的空间就被浪费了，这种浪费便是内部碎片 缺点：程序需要很多页 -&gt; 更大的页表 由于页表和内部碎片造成的开销 Separate Instruction and Data Spaces 分离的指令空间和数据空间 大多数计算机只有一个地址空间，既存放程序也存放数据 大多数系统将指令（程序文本）和数据的地址空间分开。 一个进程在其进程表中可以有两个指针： 一个指向指令页，一个指向数据页。 一个共享代码可以被两个进程指向。 Shared Pages 共享页面 Cleaning Policy 清除策略 Paging Daemon（分页守护进程）： 一个后台进程，大部分时间处于休眠状态； 定期唤醒以检查内存状态 当空闲页框太少时，使用替换算法选择要驱逐的页面 Page Fault Handling 缺页中断处理 Locking Pages in Memory 锁定内存中的页面 Process通过系统调用从设备读取数据到缓冲区 在等待 I/O 时，另一个进程启动 有一个缺页中断 第一个进程的缓冲可能会被选择置换出 如果通过I/O处于对该页面进行DMA传输的过程中，将这个页面移出，会导致部分数据写入它们所需的缓存区中，而部分数据被写入到最新装入的页面中。 在这种情况下，页面需要被钉住（pinning） Backing Store 后备存储 在磁盘上分配页面空间的两种方法： 1）分页到静态交换区 2）使用磁盘映射动态备份页面 Segmentation 分段 对程序的虚拟地址进行分段，映射到物理地址时，物理地址也被分段了 在机器上提供多个互相独立的称为段(segment) 程序员不知道这些将有多大，或者它们将如何增长，并且不想管理它们在虚拟内存中的位置 Compiler with One-dimensional Address Space 具有一维地址空间的编译器 Compiler with Segmentation 带分段的编译器 分段为每个进程维护多个独立的虚拟地址空间 允许每个表独立增长或收缩 Pure Segmentation 段(segment)是逻辑上独立的地址空间 段可能有不同的大小 它们的大小可以动态变化 地址空间使用二维内存地址并且有2部分：(段#，段内偏移) 段可以有不同的保护 允许共享程序和进程之间的数据。 分段和分页结合：MULTICS 问题","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L10","slug":"操作系统L10","date":"2022-01-03T11:18:13.000Z","updated":"2023-04-26T11:19:54.758Z","comments":true,"path":"posts/23911/","link":"","permalink":"https://ye2222.github.io/posts/23911/","excerpt":"","text":"Page Replacement Algorithms 页面置换算法 页面错误（page fault）强制选择 哪一页必须被移除 remove 为到来的页制造空间 make room 即在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间 换出的页面 如果被修改过，必须将其写回磁盘以更新该页面在磁盘上的副本 saved 如果没有被修改过，直接覆盖即可 overwritten 最好不要选择经常使用的页面 很可能在很短时间内又被调入内存中 总览 Optimal Page Replacement Algorithm 最优页面置换算法 替换将在最远点引用的页面 最优但是不可能实现 Not Recently Used Page Replacement Algorithm 最近未使用页面置换算法 简称NRU 系统为每一页面设置了两个状态位 当页面被访问(读或写)时设置R位 当页面被写入(即修改)时设置M位 这些位包含早每个页表项中 当一个进程启动时，所有页面的R和M都设置为0 周期性的，R位会清零 页面被分为4类 NRU算法随机地从类编号最小地非空类中挑选一个页面淘汰 FIFO Page Replacement Algorithm 先进先出页面置换算法 开销较小 由操作系统维护一个所有当前在内存中地页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头 发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾 优点：易于实现 缺点：经常使用的页面可能会被清除 Second Chance Page Replacement Algorithm 第二次机会页面置换算法 在FIFO基础进行修改，检查最老页面的R位 R位是０，页面既老又没有被实现，可以立刻置换掉 R位是1，就将R位清０，并把该页面放到链表的尾端，修改它的装入时间使它像刚装入的一样 本质上是在寻找一个在最近的时钟间隔内没有被访问过的页面 The Clock Page Replacement Algorithm 时钟页面置换算法 把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面 Least Recently Used (LRU) 最近最少使用页面置换算法 假设最近使用过的页面很快就会再次使用 丢弃最长时间未使用的页面 软件解决方案 必须保持一个页面的链表：最近使用在前面，在后面最少；每次内存引用更新这个列表 太贵了 可以使用硬件解决方案 - 为硬件配备 64 位计数器 - 在每条指令执行完后自动加１ - 计数器值存储在刚刚引用的页的页表条目中 - 每个页表项必须有一个足够容纳这个计数器值的域 - 发生缺页中断后，选择计数器值最低的页面 - 选择计数器值最低的页面 - 问题：页表非常大，变得更大 - 为具有n 个页框的机器维护一个n x n 位的矩阵 - 引用页框 K 时： - (i) 将第 K 行设置为全 1。 - (ii) 将 K 列设置为全 0。 - 实质上就是在被引用时， - 将自己那一行变为1，让自己变大 - 让自己所在所有行即对应的列置为０，让其他变小 - 二进制值最小的行是 LRU 页 用软件模拟LRU 只有非常少的计算机拥有这种硬件，需要一种能用软件实现的解决方案 一种可能的方案称为NFU(Not Frequently Used, 最不常用)算法 NFU 该算法将每个页面与一个软件计数器相关联，计数器的初值为0 每次时钟中断时，扫描所有页面时，将每个页面的R位(0/1)加到它的计数器上 计数器大体跟踪各个页面被访问的频繁程度 发生缺页中断时，则置换计数器值最小的页面 问题：从不忘记任何事情，所以很久以前的页面引用频率可能有最高的计数器 解决：修改为NFU with Aging NFU with Aging 老化算法 在每次时钟中断时 计数器右移一位 R 位添加到最左边的位 这样，我们可以对最近的 R 值给予更高的优先级 Working-Set Model 工作集页面置换算法 页面仅按需加载。 这种策略称为请求调页(demand paging) 在执行阶段，进程引用其页面的一小部分。 这称为参考位置(locality of reference) 进程当前使用的页面集称为其工作集(working set) 每隔几条指令就导致页面错误的程序被称为颠簸(thrashing) 分页系统在让进程运行之前将每个进程的工作集保存在内存中。 这种方法称为工作集模型(working set model) 工作集是随着时间变化的 在让进程运行之前加载页面称为预先调页(prepaging) 工作集算法 这个想法是检查最近的页面引用，这个想法是检查最近的页面引用。 进程的工作集是它在虚拟时间（进程实际使用的 CPU 时间量）的过去 \\(\\tau\\) 秒内引用的页面集。 工作集时钟页面置换算法 Modeling Page Replacement Algorithms 建模页面替换算法 Belady’s anomaly：页框越多，页面错误不总是越少。 建模LRU算法： 当一个页面被引用时，它总是被移动到内存中页面的顶部条目。 如果引用的页面已经在内存中，则其上方的所有页面都向下移动一个位置。 引用页面下方的页面不会移动 Stack Replacement Algorithms 如果 k 帧内存中的页面集始终是 (k+1) 帧内存中页面的子集，则页面替换算法称为堆栈替换算法 M是内存数组的集合，处理完引用字符串中的每一项后，m是页框数，则M(m)⊆ M(m 1) 问题 虚拟地址空间大小：\\(8 * 1024 = 2^{13}\\) 内存空间：\\(32\\cdot1024=2^5\\cdot2^{10}=2^{15}\\) 页面和页框的大小是一样的 Demand paging 是按需要的加载，二分查找需要整个空间 最后顺序为：2 4 8 5 Check Points What is the drawback of FIFO? What is working set? What is thrashing? What is Belady’s anomaly ? What is demand paging?","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L8","slug":"操作系统L8","date":"2022-01-02T12:49:53.000Z","updated":"2023-04-26T11:19:54.790Z","comments":true,"path":"posts/57634/","link":"","permalink":"https://ye2222.github.io/posts/57634/","excerpt":"","text":"死锁避免 动机 在大多数系统中，一次请求一个资源。 希望系统可以决定授予资源是否安全 有没有一种算法可以做出正确的决定？ 我们可以避免死锁，但前提是可以提前获得某些信息 Resource Trajectories 资源轨迹图 进入I1、I2、I5、I6包围的矩形时，系统一定会向着造成死锁的矩形区域移动，从而造成死锁 Safe and Unsafe States 安全状态和不安全状态 安全状态 定义 如果存在某种调度顺序，即使所有进程突然请求最大数量的资源，每个进程都可以运行完成，（没有死锁发生），则状态是安全的 a可以通过资源分配逐步完成所有进程，说明他是安全的 b是不安全的，他不可以完成A和C 安全状态和不安全状态的区别 从安全状态，系统可以保证所有进程都将完成； 但是从不安全的状态，就不能给出这样的保证。 单个资源的银行家问题 银行家：操作系统 客户：进程 贷款项目：资源 银行家向一群客户分别承诺了一定的贷款项目 判断对请求的满足是否会导致进入不安全状态 如果是，就拒绝 如果不是，则分配 a、b是安全的，b可以将空闲资源分配给C，从而获取其他进程所需要的资源 c是不安全的，此时没办法满足任何一个进程 多个资源的银行家系统 总结 银行家算法就是对每一个请求进行检查，检查满足后是否会进入不安全状态。 Starvation 定义：一个进程永远被剥夺必要的资源来处理它的工作 即永远执行不了 Starvation vs Deadlock Starvation：线程无限期等待 可能结束，但没有外部干预，僵局无法结束 Deadlock：循环等待资源。 是Starvation，反之不成立 死锁并不总是确定性的 Deadlock Detection, Deadlock Avoidance, and Deadlock Prevention的比较 Deadlock Detection: 确定是否有死锁 Deadlock Avoidance: 确定系统是否会进入不安全状态 Deadlock Prevention:确保至少一个死锁的必要条件永远不能成立 Deadlock Prevention 死锁预防 确保至少一个死锁的必要条件永远不能成立 破坏互斥条件 Attacking the Mutual Exclusion Condition 如果资源不被一个进程所独占，那么死锁肯定不会产生。 破坏占有并等待条件 Attacking the Hold and Wait Condition 要求进程在启动前请求所需要的所有资源 问题：很难在运行开始知道需要多少资源 破坏不可抢占条件 Attacking the No Preemption Condition 如果一个进程持有一些资源并请求另一个无法分配给它的资源，那么所有资源都会被释放。 问题：该方法可以应用于状态可以在以后保存和恢复的资源，例如内存。 不能应用于打印机等资源 破坏环路等待条件 Attacking the Circular Wait Condition 方法一：一个进程在任何时候都只能使用一个资源。 方法二：强加所有资源类型的总排序，并要求每个进程以枚举递增的顺序请求资源。 其他问题 两阶段加锁 two-phase locking 第一阶段： 进程试图对所有所需的记录进行加锁，一次锁一个记录 如果发现需要的记录被锁了，重新启动 加锁成功则开始第二阶段 第二阶段： 完成更新 释放锁 非资源死锁 Non-resource Deadlocks Communication Deadlock 可能在信号量中发生 问题 （1）D asks for one more unit：safe state （2）C asks for one more unit：unsafe state 安全状态一定不会发生死锁 不安全状态可能是资源数不够满足所有进程造成的，不一定是死锁这种状态 死锁一定是不安全状态 死锁检测是看当前拥有的资源和请求的资源 死锁避免是看当前拥有的资源和进程所需要的最多资源 a = 1， b = 2 p*(m - 1) &lt; r ​","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Git","slug":"Git","date":"2021-12-29T03:07:37.000Z","updated":"2023-04-26T11:19:54.626Z","comments":true,"path":"posts/25246/","link":"","permalink":"https://ye2222.github.io/posts/25246/","excerpt":"","text":"Git是分布式版本控制工具 集中式版本控制式工具，集中提交到一个中央服务器上进行版本控制 GIt 分布式版本控制 可以在本机库进行版本控制 Git的工作机制 远程库 使用git push 从本地库推送到远程库 GIt的常用命令 设置用户 git config --global user.name + 用户名 设置用户签名 git config --global user.email + 邮箱 设置用户签名 签名的作用是区分不同操作者的身份 与账号无关系 初始化本地库 git init 查看本地库状态 git status 分支 提交命令 需要提交的文件 添加到暂存区 git add + 文件名 添加所有文件：git add . 提交到本地库 将暂存区的文件提交到本地库 git commit -m + \"日志信息\" + 文件名 修改文件 vim + 文件名 建立文件 :wq 保存 cat + 文件名 打开文件 tail -n 1 + 文件名 查看最后一行 历史版本 查看历史记录 git reflog git log 详细的 版本穿梭（切换版本） git reset --hard 版本号 版本穿梭 版本号通过历史记录查看 git的切换版本，底层其实是移动的HEAD指针，指向当前的版本 Git分支操作 分支 在版本控制过程中，同时推进多个任务，为每个任务创建一个单独分支。 使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的进行 分支的操作 查看分支 git branch -v 创造分支 git branch 分支名 切换分支 git checkout 分支名 删除分支 删除本地分支：git branch -d + 分支名 删除远程分支：git push origin -d + 分支名 合并分支（正常合并） git merge + 要合并的分支 合并到当前分支 合并分支（冲突合并） 冲突：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个，必须人为决定新代码内容 进入文件手动修改 修改后提交(commit)不要添加文件名，要先add该文件 团队协作 团队内协作 push：从本地库推送到远程库 clone：从远程库克隆到本地库 pull：拉取远程库，更新本地库 git pull 本地和远程出现冲突 1error: Your local changes to the following files would be overwritten by merge: 如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来） 123git stashgit pull origin mastergit stash pop 如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull： 12git reset --hardgit pull origin master 跨团队协作 fork：将远程库的代码复制到另一个远程库 pull request：拉取请求，经过审核后进行合并 merge：合并 GitHub操作 创建远程库别名 git remote -v 查看当前所有远程地址别名 git remote add + 别名 + 远程地址 推送本地库到远程库 git push + 别名/链接 + 分支 拉取远程库到本地库 git pull + 别名/链接 + 分支 克隆远程库到本地 git clone + 远程地址 邀请加入团队 团队内 可以邀请加入共同编辑一个远程库 然后就可以推送内容到这个远程库中 跨团队 点击fork，可以将别人的库复制一份，变成自己的一个库 在自己的库中修改，但原来的库不会变化 可以发送pull request，经过同意后可以合并改变原来的库 ## SSH免密登录 ssh-keygen -t rsa -C + 邮箱 生成密钥 然后添加到账号里面的ssh列表里 创建.ignore文件 忽略与代码无关的编译器文件内容 第一步，创建.ignore文件 123456789101112131415161718192021222324252627282930# Complied class file*.class# Log file*.log# BlueJ files*.ctxt# Moblie Tools for java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget.idea*.iml 第二步，添加到.gitconfig文件中 12345[user] name = Ye22 email = 12554804@qq.com[core] excludesfile = C:/Users/36382/git.ignore Idea内git操作 创建本地库 在VSM中点击create git respository 切换版本 在Log中点击checkout进行切换","categories":[{"name":"杂学","slug":"杂学","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/"},{"name":"Git","slug":"杂学/Git","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ye2222.github.io/tags/Git/"}]},{"title":"hexo-搭建图床","slug":"hexo-搭建图床","date":"2021-12-27T03:43:16.000Z","updated":"2023-04-26T11:19:54.683Z","comments":true,"path":"posts/8908/","link":"","permalink":"https://ye2222.github.io/posts/8908/","excerpt":"","text":"这篇使用的Gitee已经失效了，可以参考另一篇使用GitHub 下载PicGo 从GitHub上下载PicGo的exe安装包，然后下载 PicGo下载地址 重装的话，记得从控制面板卸载，不然会出现错误 插件设置 下载这个插件 图床设置 repo：在管理中查看，填上正确的仓库名（用户名/仓库名） gitee仓库建立后不会设置分支，可以生成README文件来创建master分支 token：在个人设置中生成私人密钥 Typora设置 在图像设置中选择上传图片 勾选上面两个选项 设置好PicGo路径 然后进行测试","categories":[{"name":"hexo搭建","slug":"hexo搭建","permalink":"https://ye2222.github.io/categories/hexo%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ye2222.github.io/tags/hexo/"}]},{"title":"计网L12","slug":"计网L12","date":"2021-12-20T06:06:01.000Z","updated":"2023-04-26T11:19:54.830Z","comments":true,"path":"posts/39063/","link":"","permalink":"https://ye2222.github.io/posts/39063/","excerpt":"","text":"DNS -- 域名系统 概述 域名系统名字空间和层次结构 域名解析过程","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L11","slug":"计网L11","date":"2021-12-20T05:07:57.000Z","updated":"2023-04-26T11:19:54.828Z","comments":true,"path":"posts/39383/","link":"","permalink":"https://ye2222.github.io/posts/39383/","excerpt":"","text":"传输层的位置 不同终端上的进程如何通信 -- 套接字Socket 传输层和网络层的关系 传输层依赖网络层服务，并扩展网络层服务 传输层提供的服务 进程标识 主机地址 主机上与该进程关联的端口号 端口号（port number）：端口号被用来区分同一个主机上的不同进程 应用编程接口：socket API 传输层复用和分用 传输层基本服务：将主机间交付扩展到进程间交付，通过复用和分用实现 （发送端）复用：传输层从多个套接字收集数据，交给网络层发送 （接收端）分用：传输层将从网络层收到的数据，交付给正确的套接字 套接字的标识和端口号 套接字端口号的分配 客户端自动分配： 服务器指定端口号创建套接字： UDP分用 TCP服务器使用的套接字 一个TCP服务器为了同时服务很多个客户，使用两种套接字 监听套接字 连接套接字 UDP UDP报文结构 校验和 为什么需要UDP TCP 概述 TCP报文段结构 发送序号和确认序号的含义 TCP可靠数据传输 TCP发送端 重传场景 TCP接收端 TCP流量控制 TCP接收端 TCP连接管理 建立TCP连接 TCP三次握手建立连接 两次握手建立连接 两次握手失败的例子 TCP是三次握手建立连接 关闭TCP连接","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L10","slug":"计网L10","date":"2021-12-20T01:39:54.000Z","updated":"2023-04-26T11:19:54.829Z","comments":true,"path":"posts/22806/","link":"","permalink":"https://ye2222.github.io/posts/22806/","excerpt":"","text":"内容 Hierarchical routing Broadcast routing Multicast routing Mobile routing Adhoc routing P2P Hierarchical Routing Broadcast Routing 可能的应用： 分发天气报告、股票市场更新、现场广播节目。 广播路由可以通过以下五种方式之一完成： 通过向每个目的地发送唯一的数据包来广播每个数据包。 用数据包flood网络，以便每台机器都能接收到它。 使用多目的地路由(multi-destination routing)将数据包发送到网络上的特定机器。 使用sink tree（或spanning tree）来引导数据包 使用反向路径转发(reverse path forwarding)来帮助控制“flood”。 Reverse path forwarding 基本思想：当广播数据包从通常用于发送数据包到广播源的线路到达路由器时，它被转发到除它到达的那条线路之外的所有线路上。 否则，它被丢弃。 Internet Multicasting 组播 源主机给网络中的一部分目标用户发送数据包 IP 支持多播，使用 D 类地址。 每个 D 类地址标识一组主机。 28位可用于识别组，因此支持2.5亿组。 IP multicast很重要： Member management（IGMP/MLD）路由器获悉该网段的组播组成员 Multicast routing table（PIM-DM/SM） 组播是由特殊的组播路由器实现的。 应用层组播 Multicast routing Routing for Mobile Hosts 什么是移动主机？ 我们包括： 物理连接到网络的迁移主机，但会四处移动（我们的笔记本电脑，固定的）。 漫游主机实际上在运行中计算并希望在它四处移动时保持其连接 所有主机都有一个永久的host location和一个永久的home address，可用于确定他们的家庭位置。 具有移动用户的系统中的路由目标是使使用他们的家庭地址向移动用户发送数据包成为可能，并使数据包无论他们身在何处都能有效地到达他们。 世界被分成小区域 每个区域都有一个或多个foreign agents(外地代理)，负责跟踪所有访问该区域的移动用户。 每个区域也有一个home agent（家乡代理），它会跟踪住家在该区域但当前正在访问另一个区域的用户。 Mobile Host Registration Procedure 每个外地代理定期广播一个数据包，宣布它的存在和地址。 移动主机向外地代理注册，给出其家乡地址、当前数据链路层地址和一些安全信息。 外地代理联系移动主机的家乡代理，通知用户当前在外地区域。 家乡代理检查外地代理提供的安全信息，如果信息正确，则通知外地代理继续。 当外地代理得到家乡代理的确认时，它在其表中创建一个条目并通知移动主机它现在已注册。 当用户离开一个区域时，它应该注销自己。 Packet Routing For Mobile Hosts (tunnel) 移动主机的数据包路由（隧道） Routing in Ad Hoc Networks -- Ad Hoc 网络中的路由 Ad hoc 网络（或 MANET，Mobile Ad hoc NETworks）涉及主机和路由器都是移动的： 战场上的军车 - 没有基础设施 海上的舰队 - 一直在移动 地震应急工程 - 基础设施被毁。 一群拿着笔记本电脑的人 - 在一个缺乏 802.11 的地区。 对于自组织网络，拓扑可能一直在变化，自组织网络中的路由与其固定对应网络中的路由完全不同。 Peer-to-Peer Networks 点对点（或 P2P）计算机网络是一种主要依赖网络中参与者的计算能力和带宽而不是将其集中在数量相对较少的服务器上的网络。 所有节点都是对称(symmetric)的，没有中央控制或层次结构。 没有人愿意托管和维护一个中心化的数据库，甚至一个中心化的索引。 点对点网络的优势 所有客户端都提供资源，包括带宽、存储空间和计算能力。 点对点网络的分布式特性也提高了纯 P2P 系统出现故障时的鲁棒性 非结构化和结构化 P2P 网络 非结构化P2P网络 为了在网络中找到所需的数据，必须通过网络泛洪查询，以便找到尽可能多的共享数据的对等点。 大多数流行的 P2P 网络，如 Napster、Gnutella 和 KaZaA，都是非结构化的。 结构化 P2P 网络 维护分布式哈希表 (DHT) 并允许每个对等方负责网络中内容的特定部分。 一些著名的结构化 P2P 网络是 Chord、Pastry、Tapestry、CAN 和 Tulip P2P: centralized directory P2P: problems with centralized directory Single point of failure 单点故障 Performance bottleneck 性能瓶颈 Copyright infringement 侵犯版权 Gnutella：protocol 利用异质性：KaZaA 每个对等点要么是group leader，要么是指派给一个group leader。 peer 与其 group leader之间的 TCP 连接。 一些group leader对之间的 TCP 连接。 group leader跟踪其所有子项中的内容。 KaZaA: Querying 每个文件都有一个哈希值和一个描述符 客户端向其group leader发送关键字查询 group leader回应匹配： 对于每个匹配项：元数据、哈希、IP 地址 如果group leader将查询转发给其他group leader，他们会回复匹配项 客户端然后选择要下载的文件 使用哈希作为标识符的 HTTP 请求发送给持有所需文件的对等方 Node Lookup in Chord -- Chord 中的节点查找 Chord 系统由 n 个参与用户组成。 每个用户节点都有一个 IP 地址，可以使用哈希函数将其哈希为 m 位数字。 Chord 使用 SHA-1 进行哈希处理。 任何 IP 地址都会转换为 160 位数字，称为节点标识符。 从概念上讲，所有$ 2^{160} $个节点标识符都按升序排列在一个大圆圈中。 其中一些对应于参与节点，但大多数不对应。 将函数successor(k) 定义为顺时针方向跟随k 的第一个实际节点的节点标识符。 记录的名称也用散列（即 SHA-1）散列以生成一个 160 位的数字，称为密钥。 key = hash(name) 为了向其他人提供记录，节点构建一个由 (name, my-IP-address) 组成的元组，然后要求successor(hash(name)) 存储该元组。 这样，索引随机分布在节点上。 对于容错，可以使用 p 个不同的哈希函数将每个元组存储在 p 个节点上。 如果某个用户稍后想要查找名称，他会对其进行哈希处理以获取密钥，然后使用 successor (key)查找存储其索引元组的节点的 IP 地址。 查找程序： 请求节点向其后继节点发送一个包含其 IP 地址和它正在寻找的密钥的数据包。 数据包在环上传播，直到它定位到正在寻找的节点标识符的后继者。 该节点检查它是否有任何与密钥匹配的信息，如果有，则将其直接返回给请求节点。 作为第一个优化，每个节点都可以保存其后继节点和前驱节点的 IP 地址，以便可以顺时针或逆时针发送查询。 在大型对等系统中，线性搜索所有节点的效率非常低，因为每次搜索所需的平均节点数为 n/2。 为了大大加快搜索速度，每个节点还维护 Chord 所谓的 finger table（指取表）。 finger table有 m 个条目，从 0 到 m - 1 索引，每个条目指向一个不同的实际节点。 每个条目都有两个字段：开始和后继者的 IP 地址（开始） 节点 k 处条目 i 的字段值是： 使用finger table，在节点k 处查找key 的过程如下。 如果key介于k和successor(k)之间，那么保存key信息的节点就是successor(k)，搜索结束。 否则，搜索finger 表以找到其起始字段是key 的最接近前驱的条目。 然后将请求直接发送到该指纹表条目中的 IP 地址，要求它继续搜索。 平均查找次数为 \\(log_2n\\)。 Lookup key= 3 on node 1 Lookup key=14 on node 1 Lookup key=16 on node 1 New Node Join And Leave 当一个新节点 r 想要加入时，它必须联系某个现有节点并要求它为它查找后继节点 (r) 的 IP 地址。 然后新节点向后继节点 (r) 询问其前驱节点。 然后，新节点要求这两个节点在圆圈中的它们之间插入 r。 当一个节点优雅地离开时，它把它的密钥交给它的后继，并通知它的前任它的离开，这样前任就可以链接到离开节点的后继。 为了缓解节点崩溃带来的问题，每个节点不仅要跟踪它的直接后继，还要跟踪它的直接后继 Congestion 拥塞 拥塞是子网（部分）中存在太多数据包，性能急剧下降的情况 Factors Causing Congestion 造成拥塞的因素 输入流量速率超过输出线路的容量。 例如 多条输入线被转发到同一条输出线。 添加更多内存可能会有所帮助。 无限的内存怎么样？ 路由器中的处理器太慢而无法执行簿记任务（排队缓冲区、更新表等）。 线路容量和处理器能力需要平衡。 Congestion Control vs. Flow Control 拥塞控制与流量控制 拥塞控制 Congestion Control 它确保子网能够承载提供的流量。 这是一个全局问题，涉及所有主机、所有路由器的行为、路由器内的存储和转发处理等。 流量控制 Flow Control 它涉及给定发送方和给定接收方之间的点对点流量。 它确保快速发送方不能以比接收方能够吸收数据的速度持续传输数据。 主机可能会收到“减速”消息，因为接收器无法处理负载或因为网络无法处理它（confused）。 Congestion Metrics 拥塞度量 由于缓冲区空间不足而丢弃的所有数据包的百分比 平均队列长度 超时并重新传输的数据包数 平均数据包延迟 数据包延迟的标准偏差 不断上升的数字表明日益拥挤。 Congestion Information Propagation 拥塞信息传播 检测到拥塞的路由器向流量源发送一个单独的警告数据包。 每个数据包中可以保留一个位或字段。 当路由器检测到拥塞状态时，它会在所有传出数据包中填充该字段以警告邻居。 主机或路由器定期发送探测数据包以明确询问拥塞情况并在问题区域周围路由流量 Congestion Control In Virt.-circuit Subnets 虚拟电路子网中的拥塞控制 Admission control（准入控制，简单粗暴） 一种闭环技术，可以防止已经开始恶化的拥塞。 基本思想：一旦发出拥塞信号，就不会再建立虚拟电路，直到问题消失。 备用路由（绕过问题区域） 允许新的虚拟电路，但在问题区域周围小心地路由所有新的虚拟电路。 协商主机和子网之间的协议，以便子网在电路建立时可以预留路径上的资源。（资源预留） 交通量和交通形态 所需的服务质量 其他参数 Congestion Control In Datagram Subnets 数据报子网中的拥塞控制 每个路由器都可以监控其输出线路和其他资源的利用率。 每行都与一个变量 u 相关联，其值 (0.0 -1.0) 反映了最近的利用率。 每当 u 移动到阈值以上时，输出线就会进入警告状态。 检查每个新到达的数据包以查看其输出线是否处于警告状态。 Actions When In Warning State The Warning Bit（警告位） 在数据包的报头中设置了一个特殊位。 该位被复制到下一个发送回源的确认中。 源监视设置了位的确认部分并相应地调整其传输速率。 Choke Packets（极限极限） 路由器将阻塞数据包发送回源主机，将数据包中的目的地提供给它。 当源主机收到choke包时，需要将到达目的地的流量减少一定的百分比。 主机应在固定时间间隔内忽略指向同一目的地的阻塞数据包 如果在侦听期间没有阻塞数据包到达，主机可能会再次增加流量。 Hop-by-Hop Choke Packets（逐跳抑制演奏） 在高速或长距离下，向源主机发送阻塞数据包效果不佳，因为反应太慢。 另一种方法是让扼流数据包在它经过的每一跳都生效。 这种逐跳方案的净效果是以消耗更多上游缓冲区为代价在拥塞点提供快速缓解。 Fragmentation 每个网络都对其数据包施加了一些最大尺寸。 硬件（例如，TDM 传输时隙的宽度） 操作系统（例如，所有缓冲区都是 512 字节） 协议（例如，数据包长度字段中的位数） 符合一些（国际）国家标准 希望将错误引起的重传减少到一定程度 希望防止一个数据包占用信道时间过长 网络设计者不能自由选择他们希望的任何最大数据包大小。 最大有效载荷范围从 48 字节（ATM 信元）到 65,515 字节（IP 数据包），尽管较高层的有效载荷大小通常更大。 如果一个网络只允许 48 字节的数据包，而另一个网络允许 65515 字节的数据包，那么很难通过只允许较小数据包的网络获取大数据包。 如何才能做到这一点？ – Fragmentation（分段） Fragmentation是将数据包分解成几个较小的数据包以通过网络发送的过程。 问题不在于分解数据包以发送它，而是在另一端将数据包重新组合在一起。 有两种不同类型的碎片——透明(transparent)和非透明(non-transparent)。 透明分段试图通过在每次离开网络时重构数据包，使分段对路由上的任何其他网络不可见。 不透明的分段会导致所有分段的数据包通过多个网络到达目的地，而让目的地将它们重新组合在一起。 问题 透明碎片 出口网关必须知道它何时收到了所有的碎片。 所有数据包必须通过同一个网关退出。 重复重新组装然后重新整理大数据包所需的开销很大。 不透明的碎片 它要求每个主机都能够进行重组。 总开销会增加，因为每个片段都必须有一个标头。 A Method of Numbering the Fragments 定义一个小到足以通过每个网络的基本片段大小。 当原始数据包被分片时，除了最后一个（较短的）外，所有的碎片都等于基本碎片大小。 一个互联网数据包可能包含几个基本片段。 互联网数据包头必须提供 原始包号 互联网数据包中包含的第一个基本片段的编号，以及 一位指示互联网数据包中的最后一个基本片段是否是原始数据包的最后一个。 Outline Main function of router Learn IP IP packet format IP address and it’s classification Reserved IPv4 address Subnet and subnetting Internet and Its Network Layer 可以将 Internet 视为互连的子网或Autonomous Systems (ASes) 的集合。 将整个 Internet 连接在一起的粘合剂是网络层协议 IP（Internet 协议）。 它的工作是提供一种best-efforts(尽力而为)（即不保证）的方式来将数据报从源传输到目的地。 Internet - Collection of Subnetworks Addressing(寻址) 寻址：连网的目的是共享资源、与远端节点通信，要做到这一点，首先必须找到目的节点，寻找目的节点（设备）的过程叫做寻址。 两类 MAC寻址：根据MAC地址定位目的地 IP寻址：根据IP地址定位目的地 IP addressing 步骤 数据包到达路由器 路由器转发数据包 定位目的地 类比：邮寄 Main function of router 路由器进程 开包（解封装） 确定目标网络 查找路由表，重新封装并转发 主功能 路由 向前 其他 Routing table 包括网络地址、接口、度量（例如跳数）、子网掩码、网关等。 除了连接设备的IP和MAC地址外，路由器还有其邻居路由器的IP和MAC地址（arp表） 可能有些不同，因为工厂不同 ARP table and routing table Routing of router R1 Internet protocol IP 是提供一种尽力而为（即，不保证）的方式来将数据报（数据包）从源传输到目的地 路由协议 互联网协议 Internet protocol 数据包格式 寻址 IP packet format DF: don't fragment MF: More fragments IP address IP地址：网络号和主机号 IP地址的二进制数字 缺点：难以记住 IP地址的点分十进制表示法 二进制IP很难记住 点分十进制表示法： 32 位被分成 4 个 8 位组 “.” 用于分隔 8 位组 每个 8 位组用十进制写，从 0 到 255 Hierachical property of IP addr. Classification of IP address IP地址的分类 特殊的IP地址 Flood Broadcast = Local Broadcast Direct Broadcast Public and private address Subnet(子网) LAN 可能会变得太大而无法处理，必须拆分为多个子网。 子集允许将网络分成几个部分供内部使用，但对于外部世界仍然像单个网络（即单个路由表条目）一样。 这允许在组织内连接不同的子网。 Main router的作用 与外界的交流 主路由器转发来自外部的数据包，但如何知道内部网络结构？ 一张桌子？ 一种机制，子网掩码 Subnet Masks 子网掩码 路由器使用掩码来确定数据包应该传送到哪个子网。 子网掩码可以用点分十进制表示法指定，添加一个斜杠，后跟网络 + 子网部分的位数。 255.255.255.224 202.10.23.102/27 路由器将目的地址与子网掩码进行 AND 运算，以获得数据包应该去的路由器的地址。 使用这种方法减少了每个路由器必须存储的单个地址的数量，从而产生更小的路由器表。 Addr. Of subnet 子网是通过从 IP 地址的主机部分借用位来构建的 子网划分导致 IP 地址空间丢失 例如：C类IP 202.38.197.0，256个IP地址，254个有效IP。 4个子网，IP地址总数，2*62=124。 子网划分：将大网络划分为小子网 借用规则 Outline The basic idea of CIDR The principle of NAT/PAT ICMP and it’s application Principle Address resolution protocol ARP RARP Learn assignment of IP address (RARP) IP address problem IP 正迅速成为其流行的受害者：它的地址已用完。 原则上，存在超过 40 亿个地址，但按类组织地址空间的做法浪费了数百万个。 对于大多数组织： A类网络，16M地址太大了 C类网络，256个地址太小了 具有 65,536 个地址的 B 类网络似乎恰到好处（许多组织要求使用 B 网络）。 实际上，所有 B 类网络中有一半以上的主机少于 50 台！ 如何提供更多（和更小）的 B 类地址？ 或者 C 类网络使用 10 位而不是 8 位作为主机号？ 路由表爆炸 CIDR –Classless InterDomain Routing 无类别域间路由 路由表问题的解决方法和addr。 问题是 CIDR。 RFC 1519 中描述了 CIDR 背后的基本思想。 以可变大小的块分配 IP 地址，而不是根据类别分配 IP 地址。 例如 需要2000个地址 CIDR 可以使用前缀 13~27。 Routing With CIDR 每个路由表条目都通过提供 32 位掩码进行扩展。 每个路由表由一组（IP 地址、子网掩码、出线） 三元组组成。 (IP address, subnet mask, outgoing line) 当一个数据包进来时， 首先提取其目标 IP 地址。 屏蔽目标地址并将其与查找匹配项的表条目进行比较。 如果多个条目（具有不同子网掩码长度）匹配，则使用最长的掩码。 Routing cluster(路由聚合) Reduce routing table Separate up-down(隔离路由翻动) NAT outline NAT：网络地址转换NAT 私人IP地址（私人地址）与全球IP地址（公有地址）之间的转换 PAT：端口地址转换 映射许多 IP 地址。 到一个 IP 地址。 不同的端口 私有IP地址：非路由地址。 需要快速修复来解决 IP 地址用完的问题。 NAT（网络地址转换）在 RFC 3022 中有描述。 该过程涉及使用私有内部 IP 地址，然后在离开 LAN 时将这些 IP 地址转换为有效的 IP 地址。 此转换由 NAT 盒完成。 NAT 盒能够通过使用大型转换表来转换和跟踪地址。 当传入的数据包到达 NAT 盒时，它会查找源端口字段，该字段用作 NAT 表中内部 IP 地址的索引。 NAT Operation NAT Issues NAT 违反了 IP 的架构模型——每个 IP 地址在全球范围内唯一标识一台机器。 它把互联网变成了一个“面向连接”的网络。 NAT 盒维护连接的状态，如果它崩溃，链接也会崩溃。 协议层 k 假设协议层 k+1 已放入有效载荷中，从而违反了层独立性。 如果使用 TCP 或 UDP 以外的某些协议，NAT 可能会失败。 如果 IP 地址被插入到有效载荷数据（即消息文本）中，那么 NAT 表将不会转换该信息，并且可能会出现问题。 一台NAT机器的限制是61,440（65536-4096）台机器。 Internet network-layer protocol 除了互联网协议，还有一些其他的附属协议 ICMP ARP RARP 引导程序 DHCP ICMP - Internet Control Message Protocol 用于报告意外事件（错误）或测试互联网。 ICMP message format Address mapping ( 地址映射) ARP （地址解析协议）： Address Resolution Protocol 地址解析协议 IP addr. -&gt; MAC addr. ARP 解决了找出哪个物理地址对应于给定 IP 地址的问题。 ARP 在 RFC 826 中定义。 RARP （逆向地址解析协议） Reserve Address Resolution Protocol MAC addr. -&gt; IP addr. Assignment way of IP addr. 静态赋值 动态分配 给定一个以太网地址，对应的 IP 地址是什么？ RARP（反向地址解析协议）在RFC 903中定义。它使用全1（有限广播）的目的地址到达RARP服务器，RARP服务器发回相应的IP地址。 BOOTP 在 RFC 951、1048 和 1084 中定义。它使用通过路由器转发的 UDP 消息。 它可以提供更多信息。 （缺点 :手动配置） DHCP（动态主机配置协议）在 RFC 2131 和 2132 中有描述。 RARP DHCP：动态主机配置协议 Dynamic host configure protocol 可以灵活分配IP地址，节约IP地址的使用","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L9","slug":"计网L9","date":"2021-12-19T12:43:21.000Z","updated":"2023-04-26T11:19:54.839Z","comments":true,"path":"posts/4332/","link":"","permalink":"https://ye2222.github.io/posts/4332/","excerpt":"","text":"主要内容 packets(包)是如何从源地址传送到目标地址的 如何选择路径 Routing protocol, Router Routed protocol: IPv4,IPv6 Others Outline of network layer Outline of Routing algorithm Learn Dijkstra algorithm Distance-vector algorithm ：Rip Link state routing algorithm ：OSPF Multi-level routing, broadcast routing, mobile routing, adhoc routing, p2p, and et al. 第一部分 Main function of network layer Routing algorithm Static routing algorithm Dijkstra flooding Dynamic routing algorithm DV LS Learn Dijkstra algorithm 网络层 network layer 网络层的位置 网络层的主要作用 将数据包从源头一直传输到目的地。 Service types provided by network layer 服务类型 Connection oriented service 面向连接：X.25, ATM 虚电路 Connectionless service 无连接：IP 数据报 Virtual-circuit subnet 虚电路子网 Select a path when connection is established 建立连接时选择路径 Each packet has a connection-number 每个数据包都有一个连接号 Connection is removed when communication is over 通信结束后连接被删除 Datagram subnet 数据报子网 Each datagram has destination-address 每个数据报都有目的地址 Each datagram look for path independently 每个数据报独立寻找路径 IPv4协议 介绍 网际协议版本4 一种无连接的协议，是互联网的核心 也是使 用最广泛的网际协议版本，其后继版本为IPv6 基本功能 internet协议执行两个基本功能 寻址(addressing) 分片(fragmentation) IPv4数据报格式 数据报分片 总结 IP地址 IP地址的分类 一些特殊的地址 子网的划分 Routing table Static routing Configured by administrator: ip route Dynamic routing Routing algorithm Distance vector routing（D-V） Link state routing（L-S） 由管理员配置的路由表项称为静态路由 适合小而稳定的网络，成本更低 默认路由：目的网络地址和子网掩码均为0.0.0.0，如： 可以使用Windows：route print, check routing table 通过路由协议获得的路由表项称为动态路由 适合大型变分网络，成本更高 Routed protocol和Routing protocol的区别 Routed protocol 直接连接用户的 example：IP、IPX Routing protocol 维持路由间的表格 Distance vector routing Link state routing Hybrid routing Routing algorithm 路由算法设计必须考虑以下问题： 正确性、简单性、鲁棒性、稳定性、公平性和最优性（矛盾、权衡） Correctness, simplicity, robustness, stability, fairness, and optimality (contradictory、trade-off) 路由算法分类 静态算法（非自适应路由选择）（not self-adaptive） 动态算法（自适应路由选择）（ self-adaptive ） 路由算法中的度量 Alias：cost，量度、代价、开销、成本 Common metric Path length：hop (跳数) reliability：error rate on line delay bandwidth Load of router Communication cost 最优化原则 Optimization principle 如果路由器 J 在从路由器 I 到路由器 K 的最优路径上，那么从 J 到 K 的最优路径也落在同一条路径上 从所有源到给定目的地的一组最优路由形成以目的地为根的树（称为sink tree） Sink tree(汇集树) 汇集树不一定是唯一的 所有路由算法的目标都是发现并使用所有路由器的汇集树 Shortest path routing 定义 用于计算一个节点到其他所有节点的最短路径，主要特点是以起始点为 中心向外逐层扩展，直到扩展到终点为止 Dijkstra算法 compute shortest path using weight on communication-line 带有最少行的路径可能不是最短路径 最短的路可能不是最快的 步骤 例子 Flooding Every incoming packet is sent out on every outgoing line except the one it arrived on 不计算路径，有路就走 problem：duplicate packets，such as 3，6 解决： 在packet-header中加一个计数器，通过节点时减1，计数器为零时丢包 每个节点建立一个寄存器表，数据包再次到达节点时被丢弃 选择性地Flooding 缺点：重复数据包有两个，浪费带宽 优点：可靠性高，路径短，军事上使用频繁 Dynamic Routing algorithm Distance vector routing algorithm For example: RIP Link state routing algorithm For example: OSPF Hybrid routing 混合路由 For example: IGRP 动态的实现 如果路由器需要通信，他们必须说相同的语言，即相同的路由协议 一个新的路由器必须主动介绍自己（问好） 定期发送 hello 数据包以了解其他人的健康状况（保持活动状态） Distance Vector Routing 距离矢量路由 距离矢量路由选择： 通过让每个路由器维护一个表（即矢量）来操作 给出到每个目的地的最佳已知距离以及使用哪条线路到达那里。 D-V 算法是动态的和分布式的。 常用于小型网络，RIP是D-V的典型例子 RIP：路由信息协议，路由选择信息协议，1988，RFC1058 Working principle of DV -- DV算法的工作原则 每个路由器使用两个向量 $D_i $和 \\(S_i\\) $D_i $表示从一个节点到所有其他节点的距离 \\(S_i\\) 表示下一个节点（跳） 在邻居路由器之间交换路径信息 每个节点根据路径信息更新自己的路由表 更新表 交换向量后 更新距离 更新下一个节点 练习 D-V算法的特点 优势 算法很简单 坏处 交换的信息太大 路径信息传播缓慢，路径信息可能不同 收敛速度慢，导致无穷计数问题。 不适合大网络 Main features of RIP RIP 是一种 D-V 路由协议 RIP 使用 hop（跳数）作为度量(metric) 当metric大于15时，认为目的地不可达 默认发送周期为 30 秒 Disadvantage of RIP 当目标网络的度量大于 15（如此小）时无法到达 RIP的度量是hop，一路都是router的编号，不太合理 实际中，常数到无穷大，收敛缓慢 The problems induced by DV Representation routing loop（路由环路） Count to infinite（计数到无穷问题） slow Convergence （收敛慢的问题） Cause Trust wrong routing information Main problem of DV It reacts rapidly to good news, but leisurely to bad news(好消息跑得快，坏消息传得慢) Link State Routing OSPF 距离矢量路由一直在 ARPANET 中使用，直到 1979 年它被链路状态路由取代。 链路状态路由的变体现在被广泛使用。 链路状态路由背后的思想由五个部分组成： 发现它的邻居并了解他们的网络地址。 测量每个邻居的延迟或成本。 构造一个分组，分组中包含刚收到的所有信息 将此分组发送给其他的路由器 计算到所有其他路由器的最短路径。 Learning about the Neighbors 当路由器启动时，它会在每条点对点线路上发送一个特殊的 HELLO 数据包。 期望另一端的路由器发回一个回复，告诉它是谁（使用全局唯一名称）。 当两个或多个路由器通过 LAN 连接时，LAN 可以建模为一个节点。 Measuring Line Cost 设置到每个邻居的成本度量 为了确定线路的成本，路由器发送一个特殊的 ECHO 数据包，并且要求对方立即发回。 通过测量往返时间，发送路由器可以获得对延迟的合理估计。 为了获得更好的结果，可以多次进行测试，并使用平均值。 为了将负载考虑在内，往返计时器必须在 ECHO 数据包排队时启动。 要忽略负载，应在 ECHO 数据包到达队列前端时启动计时器。 测量延迟时是否应考虑负载？ 论证可以通过两种方式进行。 Building Link State Packets 链路状态包被构造为发送到其他路由器。 数据包中包含的信息是： ID of the sender sequence number age list of neighbors delay to each neighbor 什么时候建立？ 状态数据包可能会定期构建，或者在某些重要事件发生时构建，例如线路或邻居断开或再次恢复。 A subnet. (b) The link state packets for this subnet. Distributing The Link State Packets 将LSP分组发送给其他的路由器 基本算法： 每个状态数据包都包含一个序列号，该序列号随着每个新数据包的发送而递增。 路由器会跟踪它们看到的所有（源路由器、序列）对。 当一个新的链路状态数据包进来时，它会根据已经看到的数据包列表进行检查。 如果它是新的，它将在除到达的那条线路之外的所有线路上转发（即，flooding）。 如果它是重复的，则将其丢弃--discarded 如果一个序列号低于迄今为止看到的最高序列号的数据包到达，则它被视为已过时而被拒绝。 基本算法的问题： 序列号可能会环绕，导致混淆。 解决方案：使用 32 位序列号。 每秒一个数据包，需要 137 年才能环绕。 如果路由器崩溃，它将失去对自己序列号的跟踪。 如果它再次从序列号 0 开始，新的数据包将被其他路由器拒绝为过时/重复。 如果序列号被破坏并且接收到 65,540 而不是 4（1 位错误），则数据包 5 -- 65540 将被拒绝为已过时。 00000000000000100 10000000000000100 路由器崩溃和序列号损坏的解决方案是将age（例如，60）与来自任何路由器的每个状态数据包相关联，并每秒递减一次年龄。 当年龄达到zero时，来自该路由器的信息将被丢弃。 通常每 10 秒就会有一个新数据包出现，因此路由器信息仅在路由器关闭时才会超时（或连续丢失 6 个数据包，这种情况不太可能发生）。 对基本算法的一些改进使其更加健壮。 当一个状态包进入路由器进行flooding时，它首先被放置在一个保持区（保留区）中等待一小会。 如果来自同一源的另一个状态数据包在传输之前进入，则比较它们的序列号。 如果它们相等，则丢弃重复项。 如果它们不同，则较旧的将被丢弃。 为了防止线路上的错误，所有状态数据包都被确认。 当一条线路空闲时，保持区被循环扫描以选择要发送的数据包或确认。 Computing the New Routes 一组完整的链路状态数据包允许路由器构建整个子网的图。 我们现在可以使用 Dijkstra 算法来计算路由器之间的最短路径。 我们可以在路由器中安装这些信息来引导数据包。 （设置路由表） Characteristics of L-S routing algorithm 好处 每个路由器的一致性好 收敛性好 适合大网络 缺点 每个路由器需要更大的存储空间 计算工作量很大 OSPF 先开最短路径 用图代替真实网络 每个路由器都是一个节点 计量成本（公制） 可能有几张图 计算最短路径 BGP（border gateway protocol）（边界网关协议） 不同的协议 - AS 之间需要 BGP（边界网关协议），因为内部网关协议和外部网关协议的目标不同。 BGP 的定义在 RFCs 1771 到 1774 中。 外部网关协议路由器的典型策略涉及政治、安全或经济方面的考虑。 鉴于 BGP 对传输流量的特殊兴趣，网络被分为三类之一。 存根网络 stub networks 多连接网络 multiconnected networks 过境网络 transit networks BGP 路由器对通过建立 TCP 连接相互通信。 BGP 从根本上说是一种距离矢量协议，但与大多数其他协议（如 RIP）截然不同。 BGP 路由器会跟踪准确的路径。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L8","slug":"计网L8","date":"2021-12-17T11:38:08.000Z","updated":"2023-04-26T11:19:54.840Z","comments":true,"path":"posts/53293/","link":"","permalink":"https://ye2222.github.io/posts/53293/","excerpt":"","text":"内容 Multiple access protocol 多路访问协议 A real system(LAN): Ethernet 以太网 以太网是利用MAC将各个电脑连接起来的一种协议 IEEE802.3 Data Link Layer Switching 数据链接层的交换 Bridge 桥 switch 交换机 Medium Access Control 这一章的内容 Learn random access protocol(随机访问协议) Master pure ALOHA and slotted ALOHA Master the characteristics of each type of CSMA 1-P CSMA CSMA/CD Learn collision-free protocol (无冲突的协议) Bit-Map Binary Countdown The problem of Broadcast network 广播网络的问题 Data communication 数据通讯 Unicast（单播）：One - to - One Broadcast（广播）：One - to - Everyone Multicast（组播）：One - to - A group 在任何广播网络中，关键问题是如何在多个竞争用户之间分配单个广播信道。 allocate a single broadcast channel 广播信道有时被称为多路访问信道或随机访问信道。 multiaccess channels or random access channels What is MAC ? 用于确定谁在多路访问信道上的下一步且属于数据链路层的子层的协议，称为 MAC（Medium Access Control）子层 MAC 子层在 LAN 中尤为重要，其中许多 LAN 使用多路访问信道作为通信的基础。 Allocating channel 分配通道 有两种分配通道的方法： 静态分配 -- static allocation 频道就像一个电路——只允许一个人使用它。 未使用的带宽会丢失（浪费） 动态分配 -- dynamic allocation 通道是开放的，一些计算机可以访问其他计算机未使用的带宽。 没有专用带宽 Static allocation FDM（频分多路复用 Frequency Division Multiplexing） TDM（时分多路复用 Time Division Multiplexing） Problem of Static Channel Allocation FDM在什么情况下是有效的？ 当只有少量且固定数量的用户，并且每个用户都有大量（缓冲）流量负载时 FDM 有什么问题？ 如果当前对通信感兴趣的用户少于 N 个，则频谱的某些部分将被浪费。 如果超过 N 个用户想要通信，其中一些将被拒绝权限 即使用户数为N且不变，当一些用户处于静止状态时，其他人无法使用他们的带宽，因此只是浪费。 对于突发数据流量（峰值流量与平均流量比为1000:1），分配的小子信道大部分时间都处于空闲状态，但无法处理峰值流量。 Poor Performance Of Static FDM 性能不佳 无 FDM 信道容量 C bps 到达率 λ frames/sec 平均帧长 1/μ(bit/frame) 平均时延 T 有FDM 分成N个子通道 每个子信道容量 C/N bps 平均输入率 λ/N 恰好适用于 FDM 的相同论点也适用于时分复用 (TDM)。 Dynamic Channel Allocation 在进行动态分配之前，我们必须考虑 5 个关键假设： Station Model Single Channel Assumption Collision Assumption Continuous/Slotted Time Carrier/No Carrier Sense 1 – Station Model 该模型由 N 个independent stations（也称为terminals）组成。 每个站生成用于传输的帧。 generate frames 一旦生成了一个帧，该站就会被阻塞，并且在该帧成功传输之前什么都不做。 2 – Single Channel Assumption 它是模型的核心。 单个通道可用于所有通信。 就硬件而言，所有站都是等效的。 但是协议软件可能会为不同的站点分配优先级。 3 – Collision Assumption 如果同时传输两帧，它们就会“冲突”。 在碰撞中，两帧都完全丢失。 冲突的帧必须稍后再次重传。 所有站点都可以检测冲突。 除了冲突，没有其他错误。 4 – Continuous/Slotted Time 连续时间 Continuous Time 时间被视为一个连续体。 时间不分为离散的间隔。 帧传输可以在任何时刻开始。 空档时间 Slotted Time 时间被划分为离散的间隔（槽）。 帧传输总是从一个时隙开始。 一个时隙可能包含 0、1 或更多帧。 0 frames = 空闲时隙 1 frames = 成功传输 2+ frames = 碰撞 有些系统使用一种，有些系统使用另一种。 但是对于给定的系统，只有其中一个成立。 5 – Carrier/No Carrier Sense Carrier sense（载波侦听） station可以在发送之前判断频道是否正在使用 如果信道被感知为繁忙，则没有站将尝试使用它，直到它变为空闲。 No carrier sense 非载波侦听 station在尝试使用该频道之前不会感应到该频道。 只有稍后他们才能确定传输是否成功。 LAN一般都有载波侦听。 请注意，此处的“载波”一词是指电缆上的电信号。 Multiple access protocol 多路访问协议 Random Access Protocol 随机访问协议 特点：竞争使用通道，可能导致冲突 典型的随机访问协议 ALOHA pure ALOHA； slotted（分槽，分槽）ALOHA CSMA CSMA/CD（以太网） Controlled Access 受控访问协议 特点：已分配信道，无冲突 ALOHA Protocol Pure ALOHA: A Frame is sent at once when it is generated Collision may be occurred all the time 冲突时间为2D 前面D时间内传输的帧的后面部分会冲突 后面D时间内传输的帧的前面部分就冲突 Slotted ALOHA Frame is sent only at the very beginning of interval Frame is sent successfully once no collision is occurred at the beginning of interval (slot) 冲突时间为D 前一个帧传输完毕后，进入时隙的起点，可能在D时间(时隙持续时间)一直发生冲突 总结 Carrier Sense Protocols CSMA：Carrier Sense Multiple Access Characteristic：“先听后发” Improve ALOHA Types Non-persistent CSMA Persistent CSMA 1-persistent CSMA P-persistent CSMA 1-persistent is a special example of p-persistent 但前者是连续时间的，后者是分槽的 问题：对于1-persistent CSMA，如果一个频道空闲后站点进行发送数据，是否会造成冲突 会，有两种情况 有两个或多个站点同时发送数据 传播延迟时间--Propagation 传输时延是指一个站点从开始发送数据帧到数据帧发送完毕所需要的全部时间 传播时延是指发送端开始发送数据到接收端收到数据所需要的全部时间。 传输时延和发送数据帧大小有关，而传播时延和传输距离相关。 例子：计算冲突窗口 CSMA/CD -- Carrier Sense Multiple Access with Collision Detection “先听后发、边发边听” 所有站点在发送时都接收到自己的信号，因此，如果信号不同，站点就会检测到冲突。 一旦检测到冲突，立即中止传输，并在发生冲突时发送阻塞信号(a jam signal)以通知其他站点； 所有站点都需要一个随机的时间来再次重传。 广泛应用于局域网LANs的MAC子层 有三个状态 Contention竞争 Transmission 传输 idle 空闲 Other Multiple Access Protocol Collision-Free protocol (无冲突的协议) A Bit-Map protocol(位图协议,预留协议) 竞争期 传输期 Binary Countdown protocol (二进制倒计数协议) Limited-Contention protocol (有限竞争协议) WDMA（波分多路访问协议） MACAW（无线局域网协议） MACA：Multiple Access with Collision Avoidance MACAW ：MACA for wirless IEEE Ethernet naming rule 10Base2（IEEE 802.3a） –10：baseband（unit: Mbps） 10Mbps –Base：baseband transmission (基带传输) –2（或5）：support segment （100米为单位，四舍五入） 10Base-TX（IEEE 802.3X） –T：copper UTP –F：fiber 检测粗或细同轴电缆的问题 检测电缆断裂、过长（超长）、不良分接头或连接器松动可能是粗同轴电缆或细同轴电缆的主要问题。 时域反射计（时间域反射计） 发帖 定时发送和接收回声之间的时间间隔 定位回声的来源 Topology of 10Base-T Physical topology is star Logical topology is bus（compete the bus） 优势 安装成本低于同轴电缆 即插即用，组网灵活 星型拓扑，易分离故障 开放 问题 多用户共用一条10M总线（通道） 以太网编码 Ethernet encoding 不能直接使用二进制表示电压0V和5V，因为你分不清空闲的发送端(0 volts)和0 bit(0 volts) 使用Manchester encoding，1bit表示一个高伏加低伏，0bit表示一个低伏加高伏 IEEE 802 standard (chapter 1) Ethernet MAC sublayer protocol 有两种不同的MAC子层协议： DIX(DEC, Intel, Xerox) 使用最广，首先发明 IEEE 802.3 后发明，使用范围没那么广 Destination/Source address 10-Mbps baseband standard 只使用6个字节的地址 MAC address (physical address) Ethernet MAC Address Manufacture ID (OUI，Organizationally Unique Identifier ) + NIC ID=24bit + 24bit 例子 区别： The Type/Length Field 大于1536的是Type，小于等于1536(0x600)的是Length Data field 0~1500字节 以太网要求有效帧必须至少64个字节 其他必须的部分为6+6+2+4=18个字节 最大帧长：1500+18=1518 为什么需要至少64字节 CSMA/CD：帧的传送时间大于等于\\(2\\tau\\) 所以小于这个值的说明发生了冲突，提前送回 对于以太网 Binary Exponential Backoff 二进制指数回退算法 发生碰撞后，该站等待一个随机时间并重试。 随机化是如何完成的？ 时间被分成离散的时隙，其长度等于最坏情况的往返传播时间 (2τ)。 第一次碰撞后，每个站随机等待 0 或 1 个时隙。 第二次碰撞后，每个站随机等待 0、1、2 或 3 个时隙时间。 在 i 次冲突后，会选择 0 到\\(2^i-1\\) 之间的随机数，并跳过该数量的时隙。 达到 10 次冲突后，随机化间隔将冻结在 1023 个时隙。 16次碰撞后，控制器放弃并报告失败。 Typical Ethernet 10base2 10base5 10base-T Improve performance Up to 100Mbps Switched network 交换式以太网 高速背板：backplane 插件卡: plug-in cards Hub：集线器 Switch：交换机 Repeater：中继器 插入式卡检查帧是否以连接到同一卡的其他站之一为目的地。 如果是，则将帧复制到目标站。 如果没有，帧将通过高速背板发送到目标站的卡。 如果连接到同一个插件卡的两台机器同时传输帧会怎样？ 情况 1：卡上的所有端口都连接在一起形成本地卡上 LAN -- Hub 在任何时候，每张卡只允许传输一次，但所有卡都可以并行传输。 每张卡形成自己的冲突域，独立于其他。 情况 2：每个输入端口都可以在卡的板载 RAM 中缓冲传入帧 -- Switch 所有输入端口都可以同时接收（和发送）帧 - 并行和全双工(parallel and full-duplex) 每个端口都是一个单独的冲突域，因此不会发生冲突。 100Mbps Ethernet—802.3u 快速以太网 带宽：10Mbps -&gt; 100Mbps 快速以太网（IEEE 802.3u）于 1995 年 6 月被 IEEE 正式批准。 向下兼容 保留旧的数据包格式、接口和程序规则 更快 比特时间从 100 (10 Mbps) 纳秒减少到 10 纳秒 (100 Mbps)。 自动协商 -- autonegotiation 快速以太网使用集线器或交换机连接计算机，就像 10Base-T 接线一样。 快速以太网允许使用以下三种类型的电线。 Gigabit Ethernet（吉比特以太网）千兆以太网 千兆以太网 (IEEE 802.3z) 于 1998 年被 IEEE 批准。 向下兼容 比现有的 802.3 和 802.3u 标准更快。 千兆以太网的所有配置都是点对点而不是多点。 千兆以太网支持两种不同的操作模式 全双工：基于交换机的连接 半双工：基于集线器的连接 千兆以太网支持流量控制：一端可以向另一端发送一个特殊的控制帧，告诉它暂停一段时间 解决一些问题 carrier extension（载荷扩充） 将帧填充到 512 字节 (8) 所以，最大距离可以是200m=25*8 缺点：线路利用率低，仅为9%（46/512） frame bursting （帧串） 在一次传输中传输多个帧 改善线路效用 IEEE802.2 LLC 在以太网和其他 802 协议之上运行。 LLC 通过向网络层提供单一格式和接口来隐藏各种 802 网络之间的差异。 LLC 提供三种服务选项： 不可靠的数据报服务， 确认数据报服务 可靠的面向连接的服务。 LLC 标头包含三个字段： 目的地接入点 源接入点 一个控制字段。 数据链路层交换 为什么有多个局域网？ 每个部门的目标可能不同 可能在地理上分布在几个建筑物上 可能需要拆分成单独的 LAN 以适应负载 最远的机器之间的物理距离可能太大 为了提高性能 桥梁(Bridge)可以为组织的安全做出贡献 Provide a higher load Bridge-operation from 802.11 to 802.3 Bridge from 802.X to 802.Y 问题： 不同的帧格式——重新封装 re-encapsulation 不同的传输速度 - 缓冲 buffering 不同的最大帧长（如，802.3 1526 字节、802.11 2346 字节） 不同的安全策略 不同的QoS策略 Local internetworking 本地互联 通过透明网桥(transparent bridges)连接的多个 LAN 不需要对其硬件和软件进行任何更改。 透明网桥 即插即用，无需任何配置 网络中的站点无需感知网桥的存在与否 透明网桥以混杂模式（promiscuous mode）运行，接受在它所连接的所有 LAN 上传输的每一帧。 当帧到达时，网桥必须决定是丢弃还是转发它，如果是后者，则将帧放置在哪个 LAN 上。 通过在网桥内的大（散列）表中查找目标地址来做出决定。 透明网桥 网桥维护一个目的地址表和相应的输出行，如下所示： 最初所有的哈希表都是空的。 flooding algorithm：（泛洪） 未知目的地的每个传入帧都在网桥连接到的所有 LAN 上输出，除了它到达的那个。 backward learning （逆向学习） 通过查看传入帧的源地址，网桥能够知道哪个机器可以在哪个 LAN 上访问，因此它在其哈希表中创建一个条目，将源机器与传入 LAN 链接起来。 如何处理动态拓扑？ 每当创建哈希表条目时，都会在条目中注明帧的到达时间。 每当来自条目中地址的帧到达时，条目时间就会更新。 桥中的进程会定期扫描哈希表并清除（清除）超过几分钟的所有条目。 传入帧的路由过程： 如果目的局域网和源局域网相同，则丢弃该帧 -- discard 如果目标 LAN 和源 LAN 不同，则转发该帧 -- forward 如果目标 LAN 未知，请使用泛洪 -- flooding 当每一帧到达时，必须应用上述算法。 特殊用途的 VLSI 芯片可以在几微秒内完成查找和更新表条目。 转发 过滤 泛洪 透明网桥小结 Bridge can segment collision-domain 可以分割冲突域 例子 Spanning tree bridge 为了提高可靠性，一些站点在 LAN 对之间并行使用两个或多个网桥。 这种安排在拓扑中创建了环路。 如果到达未知目的地的帧会发生什么？ 解决方案是让网桥相互通信，并使用到达每个 LAN 的生成树覆盖实际拓扑。 在生成树中，从每个源到每个目的地都有唯一的路径，循环是不可能的。 构建生成树 选择一座桥作为树的根 序列号最小的网桥成为根。 构建了从根到每个网桥和 LAN 的最短路径树。 如果网或 LAN 出现故障，则会计算新的生成树。 Remote Bridges 远程网桥可用于互连远程 LAN。 在每个 LAN 上放置一个网桥 用点对点线成对连接桥。 Network Devices Repeaters 中继站 Are analog devices to connect two cable segments. A signal appearing on one segment is amplified and put out on the other segment. Can not understand frames, packets, or headers, but understand volts. Hubs 集线器 Frames arriving on any of the lines are sent out on all the others. The entire hub forms a single collision domain. All the lines coming into a hub must operate at the same speed. Do not amplify the incoming signals and are designed to hold multiple line cards each with multiple inputs (one collision domain). Do not examine the 802 addresses or use them in any way. Bridge 网桥 A bridge connects two or more LANs. When a frame arrives, software in the bridge extracts the destination address from the frame header and looks it up in a table to see where to send the frame. A bridge may have line cards (like a hub) for different network types and speeds. Each line forms its own collision domain. Switches 交换机 A switch is similar to bridge in its routing on frame addresses. Switches are often used to connect individual computers (no collision). Switches must have space for many more line cards. Each line card provides buffer space for frames arriving on its ports. Each port forms its own collision domain. Routers 路由 When a packet comes into a router, the frame header and trailer are stripped off and the packet located in the frame's payload field is passed to the routing software. The routing software uses the packet header to choose an output line. For an IP packet, the packet header will contain a 32-bit (IPv4) or 128-bit (IPv6) address, but not a 48-bit 802 address. Gateways Transport gateway Connect two computers that use different connection-oriented transport protocols Copy the packets from one connection to the other, reformatting them as need be. Application gateway understand the format and contents of the data translate messages from one format to another. L2 (data link layer) devices Network interface card (NIC) 网络适配器/网卡 Bridge Switch","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L7","slug":"计网L7","date":"2021-12-17T10:20:30.000Z","updated":"2023-04-26T11:19:54.836Z","comments":true,"path":"posts/54381/","link":"","permalink":"https://ye2222.github.io/posts/54381/","excerpt":"","text":"内容 学习协议验证 有限状态机模型 Petri网模型 学习示例 DLL 协议 HDLC Frame format PPP Protocol verification 协议验证 由于各种协议的复杂性，正确验证它们的正确性非常重要。 验证还应确定协议中是否可能出现死锁(deadlocks)或其他问题。 有几种不同的协议验证方法。 有限状态机模型 -- Finite state machine models Petri网模型 -- Petri net models Finite State Machine Models 每个协议机器(protocol machine)（即发送方或接收方）在每个时刻都始终处于特定状态。 所有状态都表示为节点。 整个系统的状态是两个协议机和通道的所有状态的组合。 two protocol machines and channel 从每个状态，有零个或多个可能的转换(transitions )到其他状态。 当某些事件发生时会发生转换。 所有过渡都表示为有向弧 -- directed arcs 初始状态(Initial state)对应于系统开始运行时的描述，或在此后不久的某个方便的开始位置。 可达性分析 哪些状态是可达的，哪些是不可达的 检测协议规范中的各种错误 例子 Petri Net Models Petri网有四个基本要素：places(库所), transitions（变迁）, arcs（弧）, and tokens（标记）. 一个place代表系统（部分）可能处于的状态。（圆圈） token指示的当前状态（粗点） transition由水平或垂直条指示。 每个转换都有零个或多个来自其输入位置的input arcs，以及零个或多个的output arcs，到达其输出位置。 如果在每个输入位置至少有一个输入令牌，则transition可以是enabled（激活的）。 任何启用的转换都可以随意fire（激发），从每个输入位置移除一个令牌并在每个输出位置存放一个令牌。 Petri 网可用于以类似于使用有限状态机的方式检测协议故障。 Petri 网可以用类似于文法的方便的代数形式（代数形式）表示。 Example DLL protocol HDLC High-Level Data Link Control PPP The Point-to-Point Protocol HDLC HDLC的历史 IBM 引入了 SDLC（同步数据链路控制）并将其提交给 ANSI 和 ISO，以作为美国和国际标准接受。 ANSI 将其修改为 ADCCP——高级数据通信控制程序 Advanced Data Communication Control Procedure ISO 将其修改为 HDLC——高级数据链路控制 High-level Data Link Control. CCITT 为其 LAP（链路访问程序）修改了 HDLC，但后来又将其修改为 LAPB。 它们都非常相似，它们之间只有细微的（但令人讨厌的）差异。 帧的结构 标志序列 -- Flag sequence 识别帧的开始或结束 位填充透明度。 地址字段 -- Address field 识别终端之一（在具有多个终端的线路上） 区分命令和响应（对于点对点线路） 控制领域 -- Control field 用于序列号、确认和其他目的 Frame Types -- 帧的种类 Information Frame(信息帧) Supervisory Frame (监控帧) Unnumbered Frame (无编号帧) 三种帧的Control字段的内容 Control field of An Information frame. A Supervisory frame. An Unnumbered frame. Information Frame（信息帧） Seq : N(S) 发送帧序列号 Next : N(R) 捎带确认 Piggybacked acknowledgement 捎带尚未接收的第一帧的编号（即预期的下一帧），而不是正确接收的最后一帧的编号。 P/F Poll/Final(查询/结束) 当计算机轮询一组终端时使用 Supervisory Frame （监控帧） Type 0 (bit3-4: 0 0) 接收就绪 RR帧=确认帧 当没有用于搭载的反向流量时使用 Type 1 (bit3-4: 0 1)，如协议 5 RNR=否定确认帧 Next 字段表示未正确接收到的第一个帧 Type 2（位 3-4：1 0）：接收未就绪 确认所有帧直到但不包括 Next 告诉发件人停止发送 Type 3（位 3-4：1 1）：选择性拒绝 只要求重传指定的帧 框架结构 数据字段 Data field 包含任何信息 可以任意长 校验和的效率随着帧长度的增加而下降 校验和字段 Checksum field 循环冗余码 Cyclic redundancy：16bit – CRC：\\(x^{16}+x^{12}+x^5+1\\) 协议提供的三个命令 DISC (DISConnect) - 允许机器宣布它正在停机（例如，用于预防性维护）。 SNRM（设置正常响应模式） - 允许刚刚重新上线的机器宣布其存在并强制所有序列号归零。 HDLC 和 LAPB 有一个附加命令，SABM（设置异步平衡模式）。 SABME 和 SNRME 与 SABM 和 SNRM 相同 FRMR (FRaMe Reject) - 表示一个具有正确校验和但不可能语义的帧到达。 DLL in the internet Point-to-Point Communication Router-Router专线连接 拨号主机-路由器 Point-to-Point Protocol 在 RFC 1661 中定义并在其他几个 RFC（例如 RFC 1662 和 1663）中进一步详细说明。 PPP 提供三个特性： 一种成帧方法，帧格式也处理错误检测。 用于连接线路、测试线路、协商选项和关闭线路的链路控制协议。 该协议称为 LCP（链路控制协议）。 一种以独立于要使用的网络层协议的方式协商网络层选项的方法。 选择的方法是为每个支持的网络层使用不同的 NCP（网络控制协议）。 Typical Scenario: Connecting A Home PC To Internet Service Provider 物理连接建立阶段： PC 通过调制解调器呼叫提供商的路由器。 路由器的调制解调器接听电话并建立物理连接。 数据链路层选项协商阶段： PC 在一个或多个 PPP 帧的有效载荷字段中向路由器发送一系列 LCP 数据包。 这些数据包及其响应选择要使用的 PPP 参数。 网络层选项协商阶段： 发送一系列 NCP 数据包以配置网络层并为 PC 分配 IP 地址（如果 PC 想要运行 TCP/IP 协议栈）。 数据通信阶段： PC 通过建立的连接发送和接收 IP 数据包。 连接释放阶段： 当PC完成后，NCP用于拆除网络层连接并释放IP地址。 LCP 用于关闭数据线层连接。 计算机告诉调制解调器挂断电话，释放物理连接。 PPP Frame Format 主要区别 PPP 是面向字符的，而 HDLC 是面向位的。 character-oriented PPP 在拨号调制解调器线路上使用字节填充，因此所有帧都是整数字节。 byte stuffing 用于无编号模式操作的 PPP 全帧格式 unnumbered mode Flag -- Begin with a special byte-01111110 (same as HDLC) 若封装在PPP帧中的数据出现0x7E字节，则用2字节序列0x7D、0x5E取代； 若出现0x7D字节，则用2字节序列0x7D、0x5D取代； Address Field --地址字段 始终设置为二进制值 11111111 Control field -- 控制字段 默认值为 00000011，表示未编号的帧。 考虑到地址和控制字段默认是不变的，所以LCP可以协商将这两个字段排除在外。 Protocol - 告诉 Payload 字段中的数据包类型 协议字段的默认大小为 2 个字节，可以使用 LCP 协商为 1 个字节。 当protocol=0x0021时，payload为IP包。 当Protocol= 0xc021 时，payload为 LCP 包。 当protocol=0x8021 时，payload为NCP 包。 Payload(有效负载) - 可变长度，最多达到一些协商的最大值，默认为 1500 字节。 Checksum(校验和) - 通常为 2 个字节（但可以为 4 个字节） Closing flag(结束标志) – 与开始标志相同","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L6","slug":"计网L6","date":"2021-12-17T04:31:51.000Z","updated":"2023-04-26T11:19:54.834Z","comments":true,"path":"posts/5292/","link":"","permalink":"https://ye2222.github.io/posts/5292/","excerpt":"","text":"Summary Learn 6 elementary DLL protocol Learn &amp; master sliding-window Learn &amp; master ARQ（自动重复请求）/PAR Learn &amp; master piggybacking(捎带确认) Learn pipeline Go back n &amp; selective repeat 基本DLL协议 假设 物理层、数据链路层和网络层是独立的进程 -- independent processes 机器 A 想要使用可靠的、面向连接的服务向机器 B 发送长数据流 -- reliable, connection-oriented A的数据链路层请求数据，网络层总是能够立即遵守 -- always able 这些协议处理通信错误，但不处理由计算机崩溃和重新启动引起的问题 -- errors, but not the problems caused by computers 就数据链路层而言，从网络层通过接口传递给它的数据包是纯数据 -- pure data 3 simplex(单工) protocol--三个单工的协议 An unrestricted simplex protocol 无限制的单工协议 A simplex stop-and-wait protocol 单工的停—等协议 A simplex protocol for a noisy channel 有噪声信道的单工协议 Protocol Declaration -- 协议定义 所有常见的数据类型、函数都定义为（protocol.h） NL、PL之间的数据传输 Wait_for_event(&amp;event)：等待某事发生 fram_arrive, cksum_err, timeout Timer start_timer, stop_timer start_ack_timer，stop_ack_timer 帧的结构 unrestricted simplex protocol 无限制的单工协议 协议一（乌托邦，乌托邦） 数据只在一个方向传输 -- in one direction only 发送网络层和接收网络层都时刻准备着（随时待命）-- are always ready 处理时间可以忽略（瞬间完成）-- Processing time can be ignored 提供无限缓冲空间（无限空间）-- spaces is available 数据链路层之间的通信通道永不损坏或丢帧（完美通道） -- never damages or loses of frames 发送端和接收端处于一个无限的while循环中 Simplex Stop-and-Wait Protocol 单工停--等协议 Protocol2 ：放弃不切实际的限制 接收器的处理能力是有限的：接收器只有有限的缓冲容量和有限的处理速度。 a finite buffer capacity and a finite processing speed 如何防止发送方用数据淹没接收方？ 只需在协议 1 中插入延迟 -- delay 接收者向发送者提供反馈 -- feedback 发送方发送一帧然后在继续之前等待确认的协议称为停止等待 stop and wait 注意 数据流量是单工的，但帧是双向传输的。 两个数据链路层之间的通信通道需要能够进行双向信息传输。 一个半双工（半双工）物理通道就足够了 -- half-duplex 数据流 首先发送方发送一个帧，然后接收方发送一个帧，然后发送方发送另一个帧，然后接收方发送另一个帧，依此类推。 Simplex Protocol for a Noisy Channel 有噪声信道的单工协议 让我们考虑正常情况：通信通道可能会出错。 使用定时器和确认的方案： (timer and ackonwledgement) 发送方在发送一个帧后启动一个定时器 -- starts a timer after sending 只有在正确接收到传入帧时，接收器才会发回确认 -- sends back an ackonwledgement 如果定时器超时，发送方将重传该帧 -- retransmit the frame 主动确认重传 -- Positive Ackonwledgement with Retrasmission 自动重复请求 -- Automatic Repeat Request PAR(主动确认重传) 上述方案的致命缺陷是什么？ 丢失确认 -- Loss of an ackonwledgement 复制帧 -- duplicated frame 如何区分第一次看到的帧和重传？ 在每个帧的标题中使用序列号 -- sequence number 改进 Improve efficiency of transmission full-duplex （全双工） piggybacking （捎带确认） sliding window （滑动窗口）（flow control） Sliding window protocol Protocol 4：n=1——basic idea of sliding window Protocol 5： Go Back n （回退n帧） Protocol 6： Select Repeat （选择性重传） full-duplex （全双工） 如何实现全双工数据传输？ 两个独立的单工数据通道 双向数据的一个电路 捎带（捎带确认）Piggybacking 暂时延迟传出确认，以便他们可以免费乘坐下一个传出数据帧 接收者应该等待捎带多长时间？ 一个特别的方案：等待固定的毫秒数。 （ACK-TIMER） 序列号 序列号与每个传输的帧相关联。 序列号的范围从 0 到某个最大值 (\\(2^n - 1\\)) 循环。 一个窗口是一个序列号列表 -- window 发送方维护一个发送窗口(sending window)，其序列号对应于已发送但尚未确认或可以发送的帧 (been sent but are as yet not acknowledged, or can be sent) 每当一个新的数据包从网络层到达时，它就会被赋予下一个最高的序列号，并且上边界提前一个。 当确认(ackonwledge)进来时，下边界前进一个。 接收器维护一个接收窗口(receiving window)，其序列号与允许接收的帧相对应。 当接收到序列号等于窗口下边缘的帧时，将其传递到网络层，生成确认，并将窗口旋转一。 Receiver：接收帧后，检查序列号是否为frame_expected(期望帧号)，如果是，接收并且frame_expected+1，即滑动接收窗口（接收窗口）。 Sender：收到确认帧时，检查ack_number是否为next_frame_to_send，如果是，从network_layer取包，next_frame_to_send+1，即滑动singing_window w=1 sliding window Principle of protocol 4 -- 1位传输的滑动窗口 1-bit sliding window protocol （w=1） Window setting 窗口设置 Sliding window maximum：MAX_SEQ = 1 Initial value：seq =0, ack=1（期待接收seq=0） Window sliding scheme 窗口滑动模式 A send frame firstly A发送帧 （seq=0, ack=1, A0） B receive A0，send back piggyback-acknowledge B接收帧，发送捎带确认 （seq=0, ack=0, B0） A receive acknowledge （to A0），sliding window，send next frame 接收捎带确认，滑动窗口，发送下一帧 （seq=1, ack=0, A1） characteristic 序列号seq和确认值ack“0”“1”交替 滑动窗口长度W=1，收到确认才移动窗口 保证按顺序将接收到的正确帧只一次上交网络层 正常情况 不正常情况 duplicated 重复的 error control 差错控制 Line utilization rate of protocol4（信道利用率） 协议 4 中的一个假设：时间可以忽略不计。 向前或向后传输时间 接收器处理传入帧的处理时间 事实上，在低速率信道中，往返时间可以非常大，发送方在此期间被阻塞。 线路利用率： 信道容量为 b bps 帧大小 k 位 往返传播时间 R 秒 例子 代入公式：\\(\\frac{k}{k+ bR}=\\frac{1000}{1000+50000\\times0.5}=3.85\\%\\) improve line utilization 提高利用率 增加最大滑动窗口尺寸 W： 线路利用率 = \\(W\\times T_f \\ \\div \\ (T_f+R) = W \\times k \\ \\div \\ (k + bR)\\) 乌托邦案例：线路利用率达到100%，那么最大滑动窗口大小为： W = $ (T_f+R) T_f $ = 520 / 20 =26 Pipeline 管道化 允许发送方在阻塞前最多传输 w 帧 -- w frames 每当带宽和往返延迟的乘积很大时，发送端就需要一个大窗口。 bandwidth and round-trip-delay is large 长流中间的帧损坏或丢失怎么办？ Go back n -- 回退n个 Selective repeat -- 选择性重复 Protocol 5：go back n 接收方的窗口大小为1，即接收方只按顺序接受帧。 接收器丢弃发生错误后的所有帧，不发送确认。 超时后，发送方按顺序重传所有未确认的帧，从损坏或丢失的帧开始。 数据帧 工作原理分析 Protocol 6：selective repeat 协议 6 接受无序的帧，但按顺序将数据包传递到网络层。 accepts frames out of order 接收序列号在接收窗口内的所有帧 在所有编号较低的帧都以正确的顺序传送到网络层之前，不会将帧传递到网络层。 例子 接收方收到非期望的正确帧－缓存 发送方选择帧seq2重传 接收方收到重传帧seq2－排序上交 Function of NAK Negative acknowledgement (否定确认) 比协议 5 更有效 向发送方发送错误帧的 NAK，强制发送方立即重新发送帧而不是超时","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计算机图形学总复习","slug":"计算机图形学总复习","date":"2021-12-13T12:56:37.000Z","updated":"2023-04-26T11:19:54.825Z","comments":true,"path":"posts/7801/","link":"","permalink":"https://ye2222.github.io/posts/7801/","excerpt":"","text":"第一讲 线框显示 光栅化 填充算法 裁剪算法 新的曲线曲面表示 网格曲面(meshes), 细分曲面 隐式曲面 绘制 体绘制, 基于图象的绘制, 点绘制 可视化(Scientific visualization) 三维打印 是一种数字化制造技术 输入把数字设计三维模型，输出物理实体 增材制造(additive manufacturing） 打印流程 图形学帮助直观形象地理解大规模数据所蕴涵的科学现象和规律。 虚拟现实(Virtual reality) VR的世界里所有的东西都是虚拟的、假的。（ 没有现实中的物体） 多感知性 视觉、听觉、触觉、运动、味觉、嗅觉等感知 沉浸感 用户感到作为主角存在于模拟环境中 理想的模拟环境应达到用户难辨真假的程度。 交互性 用户可操作虚拟环境内物体，并获得反馈 自主性 指虚拟环境中物体依据物理定律进行动作的程度 增强现实(Augmented reality) 顾名思义，就是对真实世界进行增强，这里的增强是指通过显示屏幕把虚拟世界叠加到真实世界中去 混合现实 (MR) AR是把虚拟的东西叠加到真实世界，而MR则是把真实的东西叠加到虚拟世界里 首先得把现实的东西虚拟化。虚拟化一般使用摄像头来扫描物体进行三维重建 第二讲和第三讲 计算机图形学L1.md 第四讲 线段扫描转换 (Scan conversion of line segments) DDA algorithm Bresenham algorithm (Version 7-Sect. 8.9) 多边形扫描转换 (Scan conversion of polygon) Fill-area algorithms Scan-line polygon-fill algorithm (Version 7: Sections 8.10) 计算机图形学L2.md 第六讲 二维线段裁剪 Cohen-Sutherland线段裁剪(2.5) 二维多边形裁剪 Sutherland-Hodgman多边形裁剪(Section 8.5) 裁剪多边形(裁剪窗口): 凸多边形 被裁剪多边形: 任意简单多边形 三维裁剪 第七讲 什么时候消隐？ 消隐减少二义性(reduce ambiguity) 消隐可提高绘制效率, 但会降低绘制质量 实时仿真(realtime simulation)：效率优先 真实感绘制(photorealistic rendering):效果优先 消隐:排序与连惯性(sorting &amp; coherence) 两者决定了消隐的效率 消隐算法分类－按输出形式 消隐算法分类－按消隐空间 图象空间算法特点 对象空间算法特点 消隐假设 场景由多边形面构成 离视点越远，z值越大(裁剪窗口规范化) 正交投影, 投影面OXY(裁剪窗口规范化); Z-buffer---二维空间消隐示意 Z缓存(Z-buffer) 存储空间与帧缓存类似 存近平面到像素对应场景的距离，称为z值 距离越大离视点越远 步骤 有重叠时取小的z值 优点 缺点 后向面剔除(Back face culling)--对象空间算法 局限性 表优先级算法(List priority algorithm) 多边形深度排序算法 三维物体的深度排序算法 三维物体的深度排序算法适合于固定视点的消隐 二叉空间剖分树算法BSP树 二叉空间剖分树的遍历 第八讲 颜色:光射入眼睛刺激视觉器官所产生的主观感觉 光是一种电磁辐射 颜色空间/彩色模型/彩色空间/彩色系统 颜色坐标系 量化描述颜色属性 HSB和HSV空间(颜色包括三要素) 色彩(hue) 饱和度(saturation) 亮度(lightness) 视网膜上有两类感受器(the retina) 杆状接收器感受光强 锥状接受器感受颜色 三种锥状感受器分别为S, M, L； 分别大概对应:blue, green, red sensors. 其敏感波长峰值分别为:430nm,560nm,610nm 第九讲和第十讲 光照明模型(illumination models) 光照模型(illumination models) 1 泛光(ambient light) 计算 2 Lambert漫反射模型(diffusion model) 3 Phong光照模型 Phong模型—高光 4 Whitted模型 多边形物体的明暗处理(shading) 1 Flat Shading 2 Ground Shading 3 Phong Shading 也称为普通插值处理 利弊 能够模拟镜面光 光强变化更自然 计算成本高于Gouraud Shading 光线跟踪(Raytracing algorithm, Section 12.3) Whitted全局光照(illumination model) 1 光线投射(Ray casting algorithm RCA) 2.光线跟踪 光线跟踪算法(Ray tracing algorithm) 光线跟踪(Ray Tracing)---光照模型 光线跟踪(Ray Tracing)---逆向思想 3 光线跟踪算法步骤 光线树(Ray tree of a ray) 光线跟踪递归终止条件 光线跟踪细节 如何表示射线 射线与几何体的求交 线面求交的一般形式 ​ 球面与光线求交(Ray and sphere) ​ 光线与三角形求交(Ray and triangle) 例子 反射方向估计 折射方向估计 阴影生成 走样(Antialias) 反走样处理方法Antialias methods 加速(Acceleration) 包围盒(Bounding box) 层次包围盒(Hierarchical bounding box) 常用包围盒 长方形包围盒 包围球 包围圆柱 平行2n面体 空间分割技术","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"课程笔记/图形学","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[]},{"title":"软件工程复习L9","slug":"软件工程复习L9","date":"2021-12-08T07:14:34.000Z","updated":"2023-04-26T11:19:54.865Z","comments":true,"path":"posts/53939/","link":"","permalink":"https://ye2222.github.io/posts/53939/","excerpt":"","text":"第一步：画出控制流图 画出其程序流程图和对应的控制流图如下 第二步：计算圈复杂度 有以下三种方法计算圈复杂度： - 流图中区域的数量对应于环型的复杂性; - 给定流图G的圈复杂度V(G)，定义为V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量; - 给定流图G的圈复杂度V(G)，定义为V(G)=P+1，P是流图G中判定结点的数量。 第三步：导出测试用例 根据上面的计算方法，可得出四个独立的路径。 (一条独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。V(G)值正好等于该程序的独立路径的条数。) 路径1：4-14 路径2：4-6-7-14 路径3：4-6-8-10-13-4-14 路径4：4-6-8-11-13-4-14 总结：McCabe的确定基路径集合的算法 McCabe开发了一种算法，用于确定程序的基本路径集合，方法如下： 1、选择一个基线路径（应该对应某个“正常案例”，建议选择尽可能多判断节点的路径） 2、沿基线路径后退，碰到判定节点后翻转，将翻转后的路径作为基线路径，重复本步骤，直到所有的判定节点都被翻转。 注意：为遵循先易后难的原则，对于循环，一般先让路径跳过循环，然后考虑进入循环。 基本路径集通常并不唯一。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"软件工程复习L8","slug":"软件工程复习L8","date":"2021-12-08T03:13:41.000Z","updated":"2023-04-26T11:19:54.863Z","comments":true,"path":"posts/4722/","link":"","permalink":"https://ye2222.github.io/posts/4722/","excerpt":"","text":"Formal methods 形式规范(Formal specification)是更普遍的技术集合的一部分，这些技术被称为“形式化方法” 这些都是基于软件的数学表示和分析 形式化方法包括 形式规范 Formal specification 规格分析与证明 Specification analysis and proof 转型发展 Transformational development 程序验证 Program verification Formal Specification 形式规范的目标： 完全的 持续的 简洁的 明确的 有效——准确说明用户想要什么 基于形式语义模型的规范 什么是语义？ semantics 语义意味着“意义” 形式语义：用数学表达的意义 形式语义模型：数学中语言的完整语义定义 什么数学？ 离散数学！ 形式语义允许各方之间进行可靠的通信 dependable communication 什么是形式语义模型？ formal semantic model Types Of Languages 程序：Procedural 由计算机要执行的所需动作序列定义的计算 大多数高级语言都是程序化的 声明：Declarative 由计算机应处于的期望状态定义的计算 许多规范语言都是声明性的 语言的最大区别在于： 声明式(Declarative)：不说如何，只说什么 程序性的(Procedural)：什么都不说，只说怎么做 Library Example: Informal Statement 图书馆示例：非规范声明 一本书可以成堆、保留或借出 如果一本书在书架中或被保留，则可以请求 我们想 形式化概念和陈述 证明一些定理以获得对规范正确的信心 首先让我们形式化一些概念 S: the book is in the stacks R: the book is on reserve L: the book is on loan Q: the book is requested 如果需要一本书，那么它就在书架上或保留 Resolution Refutation 归结法 一旦定理证明者表明否定目标(negated goal)与给定的公理集不一致，那么原始目标必须是一致的。 这证明了定理 例子 解析原则(resolution principle)，描述了一种在最小替换的条款数据库中查找矛盾的方法 归结法通过否定要证明的陈述并将否定的目标添加到已知或已假定为真的公理集合来证明定理 然后它使用推理的分解规则来证明这导致了一个矛盾 步骤 把前提或公理变成从句形式 将要以从句形式证明的内容的否定添加到公理集合中 一起解析这些子句，产生从它们逻辑上遵循的新子句 通过生成空子句产生矛盾 用于产生空子句的替换是那些否定目标的反面为真的替换 演绎可以用一棵树来表示——演绎树。 例子1 We wish to prove that “Fido will die” from the statements that “Fido is a dog” and “all dogs are animals” and “all animals will die” Convert these predicates to clause form Negate the conclusion that fido will die ¬die(fido) 例子2 Jack owns a dog. Every dog owner is an animal lover. No animal lover kills an animal. Either Jack or Curiosity killed the cat, who is named Tuna. Did Curiosity kill the cat? 例子3 Introduction 形式方法 Formal methods 提高软件质量，减少错误 只有少数软件是用形式化方法开发的 成功的软件工程 市场变化 形式方法的范围有限 形式方法的可扩展性有限 应用于某些领域，如关键系统 形式规范 Formal specification 紧接着系统要求 详细需求规范和形式规范之间的紧密反馈循环 Software development costs with formal specification 形式规范语言 Formal specification languages 代数方法 Algebraic approach 系统是根据操作及其关系来描述的 Larch(Guttag et al., 1985,1993), OBJ(Futatsugi et al., 1985), Lotos(Bolognesi and Brinksma, 1987) 基于模型的方法 Model-based approach 系统模型是使用数学结构（例如集合和序列）构建的，系统操作由它们如何修改系统状态来定义 Z(Spivey, 1992), VDM(Jones, 1980), B(Wordsworth, 1986), CSP(Hoare, 1985), Petri Nets(Peterson, 1981) 接口规范 Interface specification 大型系统被分解为子系统，这些子系统之间具有明确定义的接口 子系统接口的规范允许不同子系统的独立开发 接口可以定义为抽象数据类型或对象类 形式化规范的代数方法特别适用于接口规范 Sub-system interfaces Sub-system interface specification 代数方法 接口类似于对象类 介绍，声明指定的排序（类型名称） 描述，其中操作被非正式地描述 签名，定义对象类或抽象数据类型的接口语法 公理，通过定义一组表征抽象数据类型行为的公理来定义操作的语义 Recursion in specifications 操作通常以递归方式指定。 例子：一个扇区 表示受控扇区的对象上的关键操作是 Enter。 在管制空域增加一架飞机； Leave。 将飞机移出管制空域； Move。 将飞机从一个高度移动到另一个高度； Lookup。 给定飞机标识符，返回其当前高度； Primitive operations 有时需要引入额外的操作来简化规范 然后可以使用这些更原始的操作定义其他操作 Primitive operations Create。 使扇区实例存在 Put。 添加一架没有安全检查的飞机 Behavioral specification 基于模型的规范 Model-based specification 抽象状态机语言 (AsmL) Abstract State Machine Language Abstract State Machine Language (AsmL) AsmL 是一种可执行的规范语言，用于对数字系统的结构和行为进行建模 抽象帮助我们将复杂的问题简化为可管理的单元，并防止我们迷失在细节的海洋中 AsmL 提供了多种功能，允许您以非常经济、高级的方式描述系统的相关状态 State transitions 机器的行为（它的运行）总是可以被描述为由状态转换链接的状态序列 Evolution of state variables 状态变量的演化 state variables: (Name, Value) 例子： 图表显示了机器的运行，该机器对订单的处理方式进行建模 每个过渡操作： 可以看作是在当前状态上调用机器的控制逻辑的结果 计算子序列状态作为输出 Control Logic 机器控制逻辑是一个黑匣子，它以状态字典 S1 作为输入，并给出一个新字典 S2 作为输出 两个字典 S1 和 S2 具有相同的一组键，但与每个变量名称关联的值在 S1 和 S2 之间可能不同 例子：读取文件 例子：图像表示 ​ Behavioral specification Z Schema Schema signature Schema predicate","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"软件工程复习L7","slug":"软件工程复习L7","date":"2021-12-08T02:16:15.000Z","updated":"2023-04-26T11:19:54.864Z","comments":true,"path":"posts/5682/","link":"","permalink":"https://ye2222.github.io/posts/5682/","excerpt":"","text":"Introduction 软件测试的两个不同目标 向开发人员和客户证明软件满足要求 -- software meets requirements 在软件的行为不正确、不受欢迎或不符合其规范的情况下发现软件中的故障或缺陷 -- discover faults or defects 埃兹格·迪克斯特拉： “测试只能显示错误的存在，而不是它们的缺失” 软件测试过程模型 software testing process Software Testing Process 数据处理 -&gt; 设计测试用例 -&gt; 判断结果 验收测试： 如果软件是给一个客户开发的，需要进行一系列验收测试来保证满足客户所有的需求。验收测试主要由用户而不是开发者来进行的。 Alpha测试与Beta测试： 如果一个软件是给很多客户使用的，可使用Alpha测试与Beta测试。 Alpha测试： 是在一个受控的环境下，由用户在开发者的指导下进行测试，由开发者负责记录错误和使用中出现的问题。 Beta测试： 由最终用户在自己的场所进行，开发发者通常不在场，也不能控制应用的环境。由用户记录错误和使用中出现的问题，并定期地交给开发者来解决。 Integration testing 集成测试 系统集成的过程包括从其组件构建一个系统，并针对组件交互引起的问题测试生成的系统 集成测试期间出现的一个主要问题是定位错误 localizing errors 为了更容易地定位错误，您应该始终使用增量方法进行系统集成和测试 一个好的经验法则是首先集成实现最常用功能的组件。 这意味着最常用的组件接受最多的测试 系统被视为组件的层次结构 Incremental integration testing Integration Testing Strategies 集成测试策略 选项： “大爆炸”方法 -- big bang 增量构建策略 -- incremental construction strategy Big-Bang Integration Example 需要存根和驱动程序来测试独立组件 系统被视为组件的层次结构 Bottom-Up Integration Example 测试序列及其依赖关系 Top-Down Integration Example 只有A是自己测试的 Modified Top-Down Integration Example 在合并之前对每个级别的组件进行单独测试 集成测试的策略： 自顶向下测试：从顶模块开始，沿被测程序的结构图逐渐向下测试。按照移动路线的差异，又可区分为两种不同的实施策略： 先广度后深度实施步骤。 组装顺序：M1-M2-M3-M4-M5-M6-M7-M8 先深度后广度实施步骤。 组装顺序：M1-M2-M5-M6-M8-M3-M4-M7 Black-box and White-box testing 黑箱测试 白箱测试 Release testing 发布测试 发布测试是测试将分发给客户的系统发布的过程 发布测试通常是一个黑盒测试过程，其中测试源自系统规范 黑盒测试 另一个名称是功能测试 Black box testing 导致异常行为的输入 显示缺陷存在的输出 惠特克 (2002) 指导方针： 选择强制系统生成所有错误消息的输入 设计导致输入缓冲区溢出的输入 多次重复相同的输入或一系列输入 强制生成无效输出 强制计算结果过大或过小 LIBSYS 示例： 使用正确和不正确的登录来测试登录机制，以检查是否接受了有效用户和拒绝了无效用户 使用针对已知来源的查询来测试搜索工具，以检查搜索机制是否确实在查找文档 测试系统演示工具以检查有关文档的信息是否正确显示 测试请求下载权限的机制 测试表明下载的文档可用的电子邮件响应 Performance testing 性能测试 发现缺陷的一种有效方法是围绕系统的限制设计测试。 在性能测试中，这意味着对系统施加压力——因此得名压力测试(stress testing) 压力测试的两大功能 它测试系统的故障行为 它会给系统带来压力，并可能导致通常不会发现的缺陷曝光 Component testing 组件测试 组件测试（或单元测试）是测试系统中单个组件的过程 要测试的不同类型的组件 对象中的单个函数或方法 具有多个属性和方法的对象类 由几个不同的对象或功能组成的复合组件 Interface testing 接口测试 许多组件由几个相互作用的对象组成 测试这些复合组件然后主要关注测试组件接口的行为 接口测试的一些通用指南 检查要测试的代码并明确列出对外部组件的每次调用 当指针通过接口传递时，始终使用空指针参数测试接口 -- pointers 在通过程序接口调用组件的情况下，设计应该导致组件失败的测试 在消息传递系统中使用压力测试，如上一节所述 -- stress testing 在多个组件通过共享内存交互的情况下，设计测试以改变这些组件的激活顺序 Test case design 设计测试系统的测试用例（输入和预测输出） 测试用例设计的各种方法 基于需求的测试，其中测试用例旨在测试系统需求 -- Requirements-based testing 分区测试，识别输入和输出分区并设计测试，以便系统执行来自所有分区的输入并在所有分区中生成输出 -- Partition testing 结构测试，您使用程序结构的知识来设计测试程序的所有部分 -- Structural testing Requirements-based testing 基于需求的测试是一种系统的测试用例设计方法，您可以在其中考虑每个需求并为其派生一组测试 LIBSYS 要求 用户应能够搜索所有初始数据库集或从中选择一个子集 系统应提供合适的查看器供用户阅读文档库中的文档 每个订单都应分配一个唯一标识符（ORDER_ID），用户应能够将其复制到帐户永久存储区 LIBSYS 测试： 发起用户搜索已知存在和已知不存在的项目，其中一组数据库包括一个数据库 .....，包括两个数据库 ……，包括两个以上的数据库 从一组数据库中选择一个数据库并启动用户搜索已知存在和已知不存在的项目 从一组数据库中选择一个以上的数据库，然后…… Partition testing 输入数据和输出结果通常属于不同的类，其中一个类的所有成员都是相关的。 这些类中的每一个都是一个等效分区(equivalence partition)或域，其中程序对每个类成员都以等效的方式运行。 应从每个分区中选择测试用例。 Equivalence partitioning Equivalence partition for search routine Structural testing 结构测试是一种测试用例设计的方法，其中测试源自对软件结构和实现的知识 有时称为“白盒”测试 Path testing 路径测试是一种结构测试策略，其目标是通过组件或程序来执行每条独立的执行路径 通过程序的路径数通常与其大小成正比 路径测试不会测试通过程序的所有路径的所有可能组合 路径测试的起点是程序流程图 (a program flow graph) 路径测试的目标是确保通过程序的每个独立路径至少执行一次 When to Stop Testing More faulty? Probability of finding faults during the development Fault seeding 何时停止测试停止方法 覆盖标准 Coverage criteria 故障播种 Fault seeding \\(\\frac{检测到的种子故障}{种子错误总数} = \\frac{检测到的非种子故障}{非种子错误总数}\\) N=Sn/s S:播种故障数，n找到非播种故障数，其中播种故障s个 两个独立的测试小组测试 两个小组的有效性 E1=x/n, E2=y/n 两个小组共同发现了q个故障 小组1的有效性 E1=x/n=q/y 并且 E2 =y/n=q/x 因此推导出 n= q/(E1*E2)，用q/y，q/x来模拟有效性 n = x*y/q 何时停止测试识别容易出错的代码 跟踪开发过程中在每个组件中发现的故障数量 收集关于每个组件的测量（例如，大小、决策数量） 分类树(Classification trees)：一种统计技术，可对大量测量信息进行排序并创建决策树以显示最佳预测值 树有助于确定哪些组件可能有大量错误 An Example of a Classification Tree Test automation 测试自动化 测试是软件过程中一个昂贵且费力的阶段 一些工具： Test manager Test data generator Oracle File comparator Report generator Dynamic analyzer Simulator","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"软件工程复习L6","slug":"软件工程复习L6","date":"2021-12-07T11:54:34.000Z","updated":"2023-04-26T11:19:54.862Z","comments":true,"path":"posts/55027/","link":"","permalink":"https://ye2222.github.io/posts/55027/","excerpt":"","text":"Overview of Patterns 针对特定上下文中出现的常见软件问题提出解决方案 捕获软件参与者之间的重复结构和动态，以促进成功设计的重用 帮助解决关键的软件设计力量 Flexibility 灵活性 Extensibility 可扩展性 Dependability 可靠性 Predictability 可预测性 Scalability 可延展性 Efficiency 效率 一般编纂设计策略、约束和“最佳实践”的专业知识 可以在类中编码并按原样重用的数据结构（即链表、哈希表） 复杂的特定领域设计（针对整个应用程序或子系统） 如果它们不是熟悉的数据结构或复杂的特定领域子系统，它们是什么？ 为解决特定上下文中的一般设计问题而定制的通信对象和类的描述 The “gang of four” (GoF) 设计模式书目录 23 种不同的模式 不同类别问题的解决方案，在 C++ 和 Smalltalk 中 问题及解决方案适用范围广，多人使用多年 模式建议在分析、设计和编程中重用的机会 GOF 以结构化格式呈现每个模式 Elements of Design Patterns 设计模式有4个基本要素： 图案名称：增加设计师的词汇量 -- Pattern 问题：意图、上下文、何时应用 -- Problem 解决方案：类UML结构，抽象代码 -- Solution 结果：结果和权衡 -- Consequences Three Types of GoF Patterns 创作模式： Creational Patterns 处理初始化和配置对象 结构模式： Structural Patterns 类或对象的组合 解耦接口和类的实现 行为模式： Behavioral Patterns 处理对象社会之间的动态交互 他们如何分配责任 Structural patterns 组装对象以实现新功能 示例：代理 Proxy 代理充当另一个对象的方便代理或占位符。 例子？ Remote Proxy 远程代理：不同地址空间中对象的本地代表 Virtual Proxy 虚拟代理：代表应该按需加载的大对象 Protected Proxy 受保护代理 ：保护对原始对象的访问 Proxy Pattern - Structure 意图 为另一个对象提供代理或占位符以控制对其的访问。 结构 Type: Structural Patterns 适配器：将类的接口转换为客户期望的接口 桥：将抽象与许多可能的实现联系起来 合成的：将部分-整体层次结构表示为树结构 装饰器：动态地为对象附加额外的责任 正面：简化子系统的接口 蝇量级：高效共享多个细粒度对象 代理：为另一个对象提供代理或占位符以控制对其的访问 Adapter pattern 问题：如何解决不兼容的接口(incompatible interfaces)或为具有不同接口的相似组件提供稳定的接口？ 解决方案：通过一个中间适配器将原来的接口组件转换成另一个。 Using an Adapter: adapt postSale request to SOAP XML interface Adapter pattern uses inheritance Object Adapter 优点 减少与实现特定细节的耦合--Reduces coupling 多态性和间接性揭示了提供的基本行为 -- Polymorphism and indirection 在类图中包含新类中的设计模式名称（例如，TaxMasterAdapter），代码根据已知的设计模式与其他开发人员进行交流 Composite Pattern Composite 允许客户端统一处理单个对象和对象的组合。 Facade Pattern 外观图案 为子系统中的一组对象提供统一的接口。 Facades 允许我们提供一个封闭的架构 Structure of the Facade Pattern Type: Creational Patterns 单例：保证访问单个（唯一）实例 -- Singleton 简单工厂：创建专门的、复杂的对象 -- Simple Factory 抽象工厂：打造专业化工厂家族 -- Abstract Factory 工厂方法：定义一个用于创建对象的接口，但让子类决定实例化哪个类 -- Factory Method Builder：一步一步构造一个复杂的对象 原型：从原型克隆新实例 -- Prototype 延迟初始化：延迟昂贵的创建，直到需要它 -- Lazy initialization Singleton pattern 一个只有实例并提供全局访问点的类 全局变量可能很危险！ （副作用，打破信息隐藏） Simple Factory pattern 背景/问题 Context/Problem 当有特殊考虑时，谁应该负责创建对象，例如复杂的逻辑，希望分离创建责任以获得更好的内聚性等等 解决方案 Solution 创建一个 Pure Fabrication 来处理创建 How does Simple Factory work Factory can create different objects Factory Pattern 意图： 定义用于创建对象的接口，但让子类决定实例化哪个类。 Abstract Factory Pattern example The Client remains blissfully unaware of the various concrete classes in this example. Advantages 优点 将复杂创建的职责分离为内聚的辅助类 隐藏复杂的创建逻辑，例如从文件初始化 处理内存管理策略，例如回收或缓存 Behavioral Patterns 责任链：Chain of Responsible 请求委托给负责的服务提供商 命令： Command Request 或 Action 是一流的对象，因此是可存储的 迭代器： Iterator 按顺序聚合和访问元素 翻译： Interpreter 小语法的语言解释器 调解员： Mediator 协调其同事之间的互动 纪念： Memento Snapshot 私下捕获和恢复对象状态 观察员： Observer 当观察到的对象发生变化时，观察者会自动更新 状态： State 其行为取决于其状态的对象 战略： Strategy 用于选择多种算法之一的抽象 模板方法： Template Method 派生类提供的带有一些步骤的算法 游客： Visitor 应用于异构对象结构元素的操作 Observer pattern 意图： 定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖对象都会得到通知并自动更新 在模型-视图-控制器框架中使用(MVC) 模型是问题域 视图是窗口系统 控制器是鼠标/键盘控制 Command pattern 概要或意图：Synopsis or Intent 将一个请求封装成一个对象，从而让你参数化具有不同请求、队列或日志请求的客户端，并支持可撤销的操作 解决方案： Solution Command 对象的接口可以是一个简单的 execute() 方法 额外的方法可以支持撤销和重做 命令可以是持久的并且可以全局访问，就像普通对象一样 Command Pattern Structure: 参与者（参与此模式的类和/或对象）Participants： Command 声明用于执行操作的接口 ConcreteCommand 定义了 Receiver 对象和通过调用 Receiver 上的相应操作来实现 Execute 之间的绑定 调用者(Invoker)要求命令执行请求 接收者(Receiver)知道如何执行与执行请求相关的操作 客户端(Client)创建一个 ConcreteCommand 对象并设置其接收器 结果 Consequences： 您可以撤消/重做任何命令(undo/redo) 每个命令存储恢复状态所需的内容 您可以将命令存储在堆栈或队列中(store Commands) 命令处理器模式维护历史 添加新命令很容易，因为您不必更改现有类(you do not have to change existing classes ) 命令是一个抽象类，你可以从中派生出新的类 execute()、undo() 和 redo() 是多态函数 State Pattern – Motivation 考虑一个代表网络连接的 TCPConnection 类。 当 TCPConnection 对象收到来自其他对象的请求时，它会根据其当前状态做出不同的响应。 意图：允许对象在其内部状态改变时改变其行为。 从客户端的角度来看，该对象似乎改变了它的类。 Builder Pattern Builder - Example 意图：将复杂对象的构建与其表示分开，以便相同的构建过程可以创建不同的表示。 结构 客户端创建 Director 对象并使用所需的 Builder 对象对其进行配置。 每当应该构建产品的一部分时，Director 都会通知构建者。 Builder 处理来自主管的请求并向产品添加部件。 客户端从构建器中检索产品。 Prototype Pattern 意图：使用原型实例指定要创建的对象种类，并通过复制此原型来创建新对象。 结构 客户要求原型克隆自身 Bridge Pattern 意图：将抽象与其实现分离，以便两者可以独立变化。 Decorator Pattern 绘画示例 虽然画挂在墙上可以有框也可以没有框，但往往是加框的，而真正挂在墙上的是框。 意图 动态地为对象附加额外的职责。 装饰器提供了一种灵活的替代子类来扩展功能。 Strategy Pattern 意图 定义一系列算法，封装每个算法，并使它们可以互换。 策略让算法独立于使用它的客户端而变化。 结构 策略定义了一组可以互换使用的算法。 到机场的交通方式是战略的一个例子。 Iterator Pattern 诸如列表之类的聚合对象应该为您提供一种访问其元素而不暴露其内部结构的方法。 关键思想是把访问和遍历的责任从列表对象中取出，放入迭代器对象中。 意图 提供一种顺序访问聚合对象的元素而不暴露其底层表示的方法。 结构 Benefits of Design Patterns 设计模式可实现软件架构的大规模重用，并有助于文档系统 模式明确地捕捉专家知识和设计权衡，并使其更广泛地可用 模式有助于改善开发人员的沟通 模式名称形成一个共同的词汇","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"软件工程复习L5","slug":"软件工程复习L5","date":"2021-12-06T00:47:29.000Z","updated":"2023-04-26T11:19:54.851Z","comments":true,"path":"posts/55219/","link":"","permalink":"https://ye2222.github.io/posts/55219/","excerpt":"","text":"Software Design是后续开发步骤及软件维护工作的基础。 如果没有设计，只能建立一个不稳定的系统结构 The Design Process 设计是找出如何实现所有客户要求的创造性过程； 由此产生的计划也称为设计 早期设计决策针对系统架构(system's architecture) 后来的设计决策解决了如何实现各个单元(individual units) Design is a Creative Process 利用现有解决方案的多种方法 克隆(Cloning)：完全借用设计/代码，稍作调整 参考模型(Reference models)：建议如何分解系统的通用架构 Design Process Model 设计过程模型 设计软件系统是一个迭代过程(iterative process) 最终的结果是软件架构文档(software architecture document) The Role of the Architect Decomposition and Views 分解和视图 系统关键元素的高级描述 创建具有越来越多细节的信息层次(hierarchy)结构 Popular Design Methods 一些设计问题没有现成的解决方案 设计师必须分解以隔离关键问题 一些流行的设计方法： 功能分解--Functional decomposition 面向数据的分解--Data-oriented decomposition 面向过程的分解--Process-oriented decomposition 面向事件的分解--Event-oriented decomposition 面向对象的设计--Object-oriented design Architectural design 结构设计 识别子系统(sub-systems)并建立子系统控制和通信的框架(framework) 是设计过程的第一阶段 Architectural Styles and Strategies Pipes-and-Filter 该系统有用于输入和输出的数据流（管道）和数据的转换（过滤器） 几个重要的属性 设计者可以将整个系统对输入和输出的影响理解为滤波器的组成 过滤器可以很容易地在其他系统上重复使用 系统进化很简单 允许并发执行过滤器 缺点 不适合处理交互式应用程序 数据流模型（Data-flow model） 例子：发票处理系统的流水线模型 Client-Server 两种类型的组件： 服务器组件提供服务 客户端使用请求/回复协议访问它们 ​ 该模型的主要组成部分 一组服务器(servers) 一组客户(clients) 一个网络(network) 例子 Peer-to-Peer (P2P) 每个组件都充当自己的进程，并充当其他对等组件的客户端和服务器(both a client and a server)。 任何组件都可以向任何其他对等组件发起请求(request)。 特征 扩大规模--Scale up well 增加系统容量--Increased system capabilities 高度容忍失败--Highly tolerant of failures Publish-Subscribe 组件通过广播(broadcasting)和响应事件(reacting)进行交互 组件通过订阅(subscribe)事件来表达对事件的兴趣 当另一个组件宣布（发布）该事件发生时，订阅组件会收到通知 Repositories 两个组件 中央数据存储--central data store 对其进行操作以存储、检索和更新信息的组件的集合--store, retrieve and update information 挑战在于决定组件将如何交互 A traditional database：事务触发流程执行 A blackboard：中央存储控制触发过程 优点：开放(openness) 数据表示可供各种程序员（供应商）使用，因此他们可以构建访问存储库的工具 但也有一个缺点：数据格式必须是所有组件都可以接受的 黑板系统 专家系统 Layering 层是分层的(hierarchical) 每一层都为其外部提供服务，并充当其内部层的客户 好处 高度抽象--High levels of abstraction 添加和修改图层相对容易--add and modify a layer 缺点 构建系统层并不总是那么容易 系统性能可能会受到层间额外协调的影响--extra coordination 有时称为抽象机器模型(abstract machine model) 将系统组织成层 版本管理系统的分层模型 Combining Architectural Styles 实际的软件架构很少基于纯粹的一种风格 建筑风格可以通过多种方式组合 在不同的层使用不同的样式 使用混合样式对不同的组件或交互类型进行建模 如果架构表示为模型的集合，则必须创建文档以显示模型之间的关系 例子 Combination of Publish-Subscribe, Client-Server, and Repository Architecture Styles Control styles 必须控制子系统(Sub-system) 两种通用控件样式 集中控制 Centralized control 一个子系统全面负责控制和启动和停止其他子系统 基于事件的控制 Event-based control 每个子系统都可以响应外部生成的事件 Centralized control 集中控制 集中控制模式 Centralized control model 一个子系统被指定为系统控制器，负责管理其他子系统的执行 受控子系统是顺序执行还是并行执行 (sequentially or in parallel) 调用返回模型(call-return model)（自顶向下的子程序模型） 管理器模型(manager model)，（一个系统组件被指定为系统管理器并控制其他系统进程的启动、停止和协调） Call-return model Real-time system control Event-driven systems Event 事件 可能是一个信号，可以从菜单中获取一系列值或命令输入 两种事件驱动的控制模型 广播模型--Broadcast models 中断驱动模型--Interrupt-driven models Broadcast model 子系统注册对特定事件的兴趣 所有事件都可以广播到所有子系统 Interrupt-driven control Design Principles--Modularity 模块化 模块化是将系统的各个不相关方面分开的原则，以便可以单独研究每个方面 每个模块都将易于理解和开发 更容易定位故障（因为每个故障的可疑模块较少） 更容易更改系统（因为对一个模块的更改影响相对较少的其他模块 为了确定设计分离关注点的程度，我们使用两个衡量模块独立性的概念：耦合和内聚 Coupling 耦合 tightly coupled 紧密耦合 两个模块在彼此高度依赖时紧密耦合 loosely coupled 松散耦合 松散耦合的模块有一定的依赖性，但它们的互连性很弱 uncoupled 未耦合 未耦合的模块根本没有互连； 他们完全不相关 Cohesion 内聚 内聚是指模块内部元素（例如，数据、函数、内部模块）内部和之间的依赖关系 Design Principles 使用图表进行两种设计 扇入(fan-in)是指使用特定软件单元的单元数 扇出(fan-out)是指特定软件单元使用的单元数 扇出 = 一个模块直接调用。 3 &lt;= fan-out &lt;=9 扇入 = 直接调用该模块的模块数 在不破坏独立性的前提下，fan-in 大的比较好。 选择适当的深度、宽度、扇出和扇入 深度 = 分层的层数。过大表示分工过细。 宽度 = 同一层上模块数的最大值。过大表示系统复杂度大。 我们可以尝试使用称为sandwiching的技术打破使用图中的循环 循环的一个单元被分解成两个单元，这样新单元之一就没有依赖关系了 可以多次应用夹层，以打破紧耦合单元或长依赖链中的相互依赖关系","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"软件工程复习L4","slug":"软件工程复习L4","date":"2021-12-03T12:18:09.000Z","updated":"2023-04-26T11:19:54.850Z","comments":true,"path":"posts/6002/","link":"","permalink":"https://ye2222.github.io/posts/6002/","excerpt":"","text":"Process models 工作流模型--Workflow model 流程模型显示了整个流程以及系统支持的流程 数据流模型--Dataflow model 数据流模型可用于显示流程以及从一个流程到另一个流程的信息流 Workflow model Equipment procurement process Data flow diagrams DFD 从功能角度对系统进行建模。 跟踪和记录与流程相关的数据如何有助于全面了解系统。 数据流图还可用于显示系统与其环境中的其他系统之间的数据交换。 Insulin pump DFD Order processing DFD Modeling using the Unified Modeling Language (UML) UML Diagrams Dynamic modeling Use Case Diagrams 用例图 Use Case diagrams &amp; descriptions State Diagrams 状态图 State diagrams ---- State Machine Interaction Diagrams 互动图 Sequence &amp; collaboration diagrams Static modeling Implementation Diagrams Package, Component &amp; Deployment diagrams Static Structure Diagrams Class &amp; object diagrams Dynamic modeling Use Case 用例(use case)指定了一个系统或系统的一部分的行为，是一组动作序列的描述，包括系统为给参与者带来可观察到的价值结果而执行的变量 参与者(actor)是与系统、子系统或类交互的外部人员、过程或事物的理想化。参与者描述外部用户与系统的交互 用于描述系统中的主要流程以及流程（用例）(processes(use cases))与外部系统或称为参与者(actor)的个人之间的交互。 一旦开发了概述，就可以将其扩展到包括子流程。 用例描述是一个通用场景，是一系列描述参与者和用例之间交互的每个步骤的句子。 用例(use case)在用例图中呈现为椭圆。用例总是标有其名称。 在用例图中，参与者被呈现为一个棍状人物。每个参与者参与一个或多个用例。 参与者可以参与与其他参与者的泛化(generalization)关系。 参与者只能通过关联连接到用例。 State Machine 对象在其生命周期中的任何给定时间都必须处于某种特定状态。 对象从一种状态过渡到另一种状态是影响它的某个事件的结果。 可以为UML模型中的任何类、协作、操作或用例创建状态图。 状态图中只能有一个启动状态(start state)，但可能有许多中间和最终状态(final state)。 State Diagrams 状态机视图通过建模每个类对象的生命周期来描述对象随时间的动态行为。 每个对象都被视为一个孤立的实体，通过检测事件并对其作出响应来与世界其他地方进行通信。 事件表示对象可以检测到的各种变化，任何可以影响对象的东西都可以被描述为一个事件 状态是一组值，用于描述某一时刻的对象。 状态图提供了一个对象在接收连续消息时发生的情况的精确视图。 并非每个类都需要有状态图——只有当它们是非常动态的时，它才有助于理解对象的所有可能状态，并且当消息触发从一个状态到另一个状态的每次转换时。 例子 Sequence Diagram 序列图是强调消息时间顺序的交互图。它显示一组对象以及这些对象发送和接收的消息。 从图形上看，序列图是一个表格，显示沿X轴排列的对象和沿Y轴按时间递增排序的消息。 以图形方式演示场景 它们显示对象相互传递消息的顺序 消息：请求对象执行方法（调用方法） 它们显示创建和销毁对象的时间 objects 对象 序列图中的对象呈现为一个框，框中有一条从框中向下的虚线。 这条线被称为对象生命线，它表示对象在一段时间内的存在。 Message 消息 消息呈现为水平箭头，随着时间沿着对象生命线向下移动，从一个对象传递到另一个对象。 条件（如[check=“true”]）指示消息何时传递。 最后的箭头表示从上一条消息返回，而不是新消息。 iteration marker 迭代标记 迭代标记，例如*（如图所示）或*[i=1..n]，指示消息将按指示重复。 例子 Collaboration Diagram 协作图强调参与交互的对象之间的关系。 与序列图不同，您不必在协作图中明确显示对象的时间线。 事件序列由消息前面的序列号指示。 对象标识符的形式为 objectName : className，并且可以省略 objectName 或 className，并且冒号的位置表示 objectName: 或 :className。 提供显示事件发生顺序的第二种方式 对象显示在由指示它们之间的链接的线连接的矩形中。 数字表示操作的执行顺序。 数字与消息名称和指示流向的箭头一起书写。 协作图和序列图都源自 UML 元模型中的相同信息，因此您可以采用一种形式的图并将其转换为另一种形式。 它们在语义上是等价的。 Activity Diagram 活动图本质上是一个流程图，显示了从活动到活动的控制流。 使用活动图来指定、构建和记录对象社会的动态，或对操作的控制流进行建模。 交互图强调从对象到对象的控制流，而活动图则强调从活动到活动的控制流。 活动是状态机内正在进行的非原子执行。 Static Modeling Classes 类 类是对共享相同属性、操作、关系和语义的一组对象的描述。 在图形上，一个类被呈现为一个矩形，通常在单独的、指定的隔间中包含它的名称、属性和操作。 Class Names 类的名称是类的图形表示中唯一必需的标记。 它总是出现在最上面的隔间中。 Class Attributes 属性是一个类的命名属性，用于描述被建模的对象。 在类图中，属性出现在名称隔间正下方的第二个隔间中。 属性通常以以下形式列出： 属性名称：类型 派生属性是可以从其他属性计算出来的属性，但实际上并不存在。 例如，一个人的年龄可以从他的出生日期计算出来。 派生属性由前面的“/”指定，如下所示：/ 年龄：日期 +public #protected -private /derived Class Operations 操作描述类行为 并出现在第三个隔间。 您可以通过声明其签名来指定操作：列出所有参数的名称、类型和默认值，如果是函数，则列出返回类型。 绘制类时，不必在每个图中都显示属性和操作。 Class Responsibilities 一个类也可以在类图中包含它的职责。 责任是类执行特定服务的合同或义务。 Relationships 在 UML 中，对象互连（逻辑或物理）建模为关系。 UML中存在三种关系： 依赖 -- dependencies 泛化 -- generalizations 关联 -- associations Dependency Relationships 依赖关系 依赖项表示两个或多个元素之间的语义关系。 从 CourseSchedule 到 Course 的依赖存在是因为 Course 被用于 CourseSchedule 的添加和删除操作。 Generalization Relationships 泛化关系 类似于继承关系 泛化将子类与其超类连接起来。 它表示从超类到子类的属性和行为的继承，并表示在更一般的超类的子类中的特化。 UML 允许一个类从多个超类继承，尽管一些编程语言（例如 Java）不允许多重继承。 Association Relationships 关联关系 如果模型中的两个类需要相互通信，则它们之间必须存在链接。 关联表示该链接。 我们可以通过向表示关联的行添加多重装饰来指示关联的多重性。 该示例表明学生有一个或多个讲师： 该示例表明每个教师都有一个或多个学生： 我们还可以使用角色名称指示关联中对象的行为（即对象的角色）。 为关系命名 我们可以指定双重联系。 我们可以通过定义关联的可导航性(navigability)来约束关联关系。 在这里，路由器对象通过向服务器（调用其操作）发送消息来从 DNS 对象请求服务。 关联的方向表明服务器不知道路由器。 关联也可以是对象本身，称为链接类(link classes)或关联类(association classes)。 一个类可以有一个自关联。 我们可以通过称为聚合(aggregations)和组合(compositions)的特殊关联对包含其他对象的对象进行建模。 聚合指定了聚合（整体）和组成部分之间的整体-部分关系，其中该部分可以独立于聚合而存在。 聚合由关联上的空心菱形装饰表示。 组合表示整体对部分的所有权和重合的生命周期（即，它们作为一个整体存在和消亡）。 组合由关联上的填充菱形装饰表示。 Interfaces 接口是一组命名的操作，它指定对象的行为而不显示它们的内部结构。 它可以通过一个或两个隔间的矩形在模型中呈现，接口名称上方带有构造型 。 Interface Services 接口不会被实例化。 它们没有属性或状态。 相反，它们指定了相关类提供的服务。 Interface Realization Relationship 实现关系将类与提供其行为规范的接口连接起来。 它由一条带有空心三角形的虚线呈现，指向说明符。 Enumeration 枚举是一种用户定义的数据类型，由名称和枚举文字的有序列表组成。 Exception 可以像任何其他类一样建模。 注意名称隔间中的构造型。 Package Diagrams 包是将定义的类组织成组。 它们代表逻辑软件模块。 它们使用与类图相同的关联（聚合、关联、泛化/特化、依赖……） (aggregation, association, generalization/specialization, dependency,…) Packages 包是一种类似容器的元素，用于将其他元素组织成组。 一个包可以包含类和其他包和图表。 包可用于在不同包中的类之间提供受控访问。 在此图中，FrontEnd 包中的类和BackEnd 包中的类不能相互访问。 BackEnd 包中的类现在可以访问 FrontEnd 包中的类。 我们可以对包之间的泛化和依赖关系建模。 Component Diagram 组件图是在面向对象系统的物理方面建模时发现的两种图之一。 它们显示了一组组件之间的组织和依赖关系。 使用组件图对系统的静态实现视图进行建模。 这涉及对驻留在节点上的物理事物进行建模，例如可执行文件、库、表、文件和文档。 组件是任何形式的软件 组件图显示软件组件及其关系（虚线箭头） 它们从高级视图显示物理组件，以显示代码模块是如何分布的。 它们更常与部署图(deploymend diagrams )一起使用，而不是分开使用。 example Deployment Diagram 部署图是在面向对象系统的物理方面建模时发现的两种图之一。 它们显示了运行时处理节点的配置以及它们上的组件。 使用部署图为系统的静态部署视图建模。 这涉及对系统执行的硬件拓扑进行建模。 每个节点或处理元素都由一个 3D 框表示。 通信/关系用实线表示 组件是具有明确定义的接口的物理实现单元，旨在用作系统的可替换部分。 设计良好的组件不直接依赖于其他组件，而是依赖于组件支持的接口。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"计网L3","slug":"计网L3","date":"2021-12-03T02:00:01.000Z","updated":"2023-04-26T11:19:54.832Z","comments":true,"path":"posts/5996/","link":"","permalink":"https://ye2222.github.io/posts/5996/","excerpt":"","text":"物理层 定义了网络的机械、电气和定时接口，提供了从发送方到接收方传输位的方法，也就是说，涉及了大量关于如何使用（模拟）信号(analog signal)来获取数字信息(digital information)的内容。 数据交流的技术基础 傅里叶级数 信息可以通过改变某些物理特性（如电压或电流）在导线上传输。通过将该电压或电流的值表示为时间的单值函数f（t），我们可以对信号的行为建模并进行数学分析 Bandwidth--带宽 传输介质的频率范围(range of frequency)或位数(number of bits)称为带宽。 数字信号传输会受到衰减(attenuation)、失真(distortion)等影响。部分是由于不允许高频(high-frequency)分量通过造成的。 Hz bps：bit/s Bandwidth-Limited signals--带宽有限的信号 n越大，第n个谐波的频率nf越高 所有传输设备都会以不同的量减少不同的傅里叶分量，从而引入失真。 \\(通常，振幅在0到某个频率f_c（赫兹，Hz）之间传输，且所有高于该截止频率的频率强烈衰减。\\) Bit Rate 和 Harmonics(谐波) 给定一个bit rate: b bits/sec 在T时间内传输8bits，则T为\\(\\frac{8}{b}\\) sec 如果n=1，即只有一个谐波，则第一个谐波的频率为\\(f=\\frac{b}{8} Hz\\) 如果有n个谐波，则频率为\\(\\frac{1}{\\frac{T}{n}}= \\frac{n}{T} = \\frac{nb}{8}\\) \\(\\frac{nb}{8} ≤ f_c=&gt; n ≤ \\frac{f_c}{(b/8)} = \\frac{8f_c} {b}\\) 如果n越大的话，因为\\(f_c\\)是一个定值，那么b会减小 例子：电话线，\\(f_c=3000Hz\\) Signal-to-Noise Ratio 信噪比 S/N S: signal power N: noise power dB \\(dB = 10log_{10}\\frac{S}{N}\\) an S/N ratio of 1000 is 30 dB Max. Data Rate of a Channel 频道的最大数据传输量 Nyquist's Theorem(noiseless channel) 无噪声信道 Maximum data rate: \\[ 2Hlog_2V bits/sec \\] H: bandwidth 带宽 V: discrete levels 离散水平 Shannon's Theorem(noise channel) 噪声信道 Maximum number of bits/sec: \\[ Hlog_2(1+S/N) \\] H: bandwidth S/N: signal to noise ratio 信噪比 引导性传输介质 磁介质--magnetism 将数据从一台机器传输到另一台机器的最常见办法是将数据写到磁带或其他可擦写介质上(如可刻录DVD)，然后在目标机器上从磁带或磁盘中读出数据 优点：优良的带宽特性 缺点：延迟特性很差，传输事件长 双绞线--twisted pair 由两根相互绝缘的铜线组成，铜线的直径大约在1毫米 两根电线绞在一起，干扰波能相互抵消，降低电线的辐射 信号通常以两根电线的电压差来承载，对外部噪声有更好的免疫力 双绞线既可以用于传输模拟信号，也可以用于传输数字信号 双绞线最常见的应用是电话系统。几乎所有的电话都是通过双绞线连接到电话公司的 端局。 所获得的带宽取决于导线的厚度(直径)以及传输距离的远近 双绞线可分为几大类 5类线：有4对双绞线 全双工链路：双向同时使用的链路 半双工链路：可以双向使用但一次只能使用一个方向的链路 单工链路：只允许一个方向上传输的链路 到6类为止，所有的双绞线称为非屏蔽双绞线--UTP（Unshielded Twisted Pair） 这些双绞线仅由导线和绝缘层简单地构成 7类外面多加了个屏蔽层 同轴电缆--coaxial cable 比非屏蔽双绞线有更好地屏蔽特性和更大地带宽，能以很高地速率传输相当长的距离 广泛使用的有两种： 50Ω电缆：用于数字运输 75Ω电缆：用于模拟传输和有线电视传输 这样的划分并非技术因素，而是历史原因 同轴电缆由硬的铜芯和外面包上的一层绝缘材料组成，绝缘材料的外层是一层密织的网状圆柱导体，外层导体再覆盖上一层保护塑料外套 同轴电缆的结构和屏蔽性使得它既有很高的带宽，又拥有很好的抗噪性 带宽取决于电缆的质量和长度 电力线 使用电力线进行数据通信 可以在家庭内部构建局域网 又可以在室外作为访问Internet的宽带接入 光纤 光纤主要用于网络骨干的长途传输、高速局域网以及高速Internet接入 光纤传输系统由三个关键部件构成 光源 传输介质：超薄玻璃纤维 探测器 无线传输 电磁频谱 电磁波每秒振动的次数称为它的频率，通常用f表示，以赫兹(Hz)来度量 两个相邻的波峰(或者波谷)之间的距离称为波长，通常用希腊字母λ表示 \\(λf=c\\) 无线电传输 传输距离长，被广泛用于通信领域 无线电波是全方向传播的 无线电波的特性与频率有关 微波传输 微波按直线传播 红外传输 非引导性的红外波被广泛用于短程通信 红外线不能很好地透过固体墙壁 光通信","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L2","slug":"计网L2","date":"2021-12-03T01:44:26.000Z","updated":"2023-04-26T11:19:54.831Z","comments":true,"path":"posts/55213/","link":"","permalink":"https://ye2222.github.io/posts/55213/","excerpt":"","text":"Design Issues for the Networks 网络的设计要素 Addressing 寻址 Error control 错误控制 flow control 流量控制 routing 路由 multiplexing and de-multiplexing Network Architecture Layered Network Model 分层网络模型 OSI Peer-to-Peer Communications 对等体交流 TCP/IP of Internet protocol 协议 协议（protocol）是指通信双方就如何进行通信的一种约定。 Protocol refers to a kind of agreement on how to communicate between communication parties. service 服务 服务是指某一层向它上一层提供的一组原语（操作）。 A service is a set of primitives (operations) provided by a layer to its upper layer. 服务定义了该层准备代表其用户执行哪些操作，但是它并不涉及如何实现这些操作。 服务与两层之间的接口有关，低层是服务提供者，而上层是服务用户。 service primitive 服务原语 一个服务由一组原语（primitive）正式说明，用户进程通过这些原语（操作）来访问该服务。 协议和服务的关系和区别 服务是指某一层向它上一层提供的一组原语（操作）。 协议是一组规则，规定了同一层上对等实体之间所交换的数据包或者报文的格式和含义。对等实体利用协议来实现它们的服务定义，它们可以自由地改变协议，只要不改变呈现给它们用户的服务即可。 按照这种方式，服务和协议是完全相分离的 服务涉及层与层之间的接口，协议涉及不同机器上两个对等实体之间发送的数据包 IEEE 802工作组 Network Standardization ITU (International Telecommunication Union) ISO (International Standards Organization ) ANSI (American National Standards Institute) NIST (National Institute of Standards and Technology) IEEE (Institute of Electrical and Electronics Engineers) RFCs (Request For Comments). IRTF (Internet Research Task Force)","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L1","slug":"计网L1","date":"2021-12-03T00:38:58.000Z","updated":"2023-04-26T11:19:54.826Z","comments":true,"path":"posts/55021/","link":"","permalink":"https://ye2222.github.io/posts/55021/","excerpt":"","text":"计算机网络的基本概念 A collection of autonomous computers interconnected 一些互相连接、自治的计算机的集合 interconnected：Be able to exchange information 能够交换信息 Autonomous: Be able to handle independently 能够独自处理、单独运行 在尺寸上分类计算机网络 LAN--Local Area Networks--局域网 WAN--Wide Area Networks--广域网 Network Topology 网络拓扑结构 Layout of inter-connections (信道的分布方式) Measure bps：bits per second Throughput 吞吐量 Usually refers to actually measured bandwidth, at a specific time of day. 通常指在一天中的特定时间实际测量的带宽。 带宽的重要性 Communication Technology For twisted-pair cable Modem 调制解调器 300bps,1200bps,9600bps,28kbps,33kbps,56kbps XDSL x数字用户线 128Kbps, 1Mbps,4Mbps,6Mbps Ethernet 以太网 10Mbps, 100Mbps, 1000Mbps… For Fiber Ethernet 以太网 10/100Mbps, 1/10Gbps + SDH 同步数字体系 155Mbps, 2.5Gbps, 1.6Tbps + Communication Mode Point-to-Point 点到点 Multicast 多播 Broadcast 广播 Type of Services 面向连接服务和无连接服务 面向连接的服务（connection-oriented service）是按照电话系统建模的 无连接服务（conncetionless service），这是按照邮政系统建模的。 每个报文（信件）都携带了完整的目标地址，每个报文都由系统中的中间节点路由， 而且路由独立于后续报文。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"软件工程复习L3","slug":"软件工程复习L3","date":"2021-12-02T07:04:49.000Z","updated":"2023-04-26T11:19:54.849Z","comments":true,"path":"posts/54579/","link":"","permalink":"https://ye2222.github.io/posts/54579/","excerpt":"","text":"Requirements engineering 需求工程 需求：反映了客户对有助于解决某些问题的系统的需求 需求工程：发现、分析、记录和检查系统服务和约束的过程 The Requirements Process 在实际的开发过程中，获取、分析、建模、编写规约和验证这些需求开发活动不会是线性地、顺序地完成。实际上，这些活动是交叉的、递增的和反复的。 Types of Requirements Requirements: 在环境域内定义的任何需求，包括系统接口 Specification: 规范仅限于环境和系统域之间的交叉点 Software requirements 软件要求 用户需求--User requirements 高级抽象需求--High-level abstract requirements 以自然语言和图表表示的语句，说明系统预期提供的服务以及它必须在哪些约束条件下运行 系统要求--System requirements 系统应执行的操作的详细说明 详细说明系统的功能、服务和操作限制 应该是准确的 Different kinds of software requirements for different users Requirement Type 功能要求--Functional requirements 系统应提供的服务声明、系统应如何对特定输入做出反应以及系统在特定情况下的行为 非功能性需求--Non-functional requirements 对系统提供的服务或功能的限制，包括时间限制、开发过程和标准的限制 timing constraints, constraints on the development process and standards 域要求--Domain requirements 来自系统的应用领域，并反映该领域的特征和约束 application domain of the system characteristics and constraints of that domain Functional requirements 描述系统应该做什么 LIBSYS示例 用户应能够搜索所有初始数据库集或从中选择子集 完整性--Completeness 应定义用户所需的所有服务 一致性--Consistency 需求不应有相互矛盾的定义 Non-functional requirements 非功能性需求 是与系统交付的特定功能不直接相关的需求 可能与紧急系统属性有关，如可靠性、响应时间和存储占用率 未能满足非功能性要求可能意味着整个系统无法使用（飞机系统：可靠性） 只要可能，您应该定量地编写非功能性需求，以将其目标转化为定量需求 速度：处理事务/秒，用户/事件响应时间 大小：K字节，RAM芯片数 可靠性：平均失效时间 如果您可以在需求文档中区分功能性需求和非功能性需求，这将非常有用。实际上，这很难做到 Specification 规范 需求是用文本文档中的自然语言语句编写的 缺乏清晰性，难以精确和明确 指导方针 发明一种标准格式 始终如一地使用语言 使用文本突出显示来选择需求的关键部分 尽可能避免使用计算机术语 自然语言问题 自然语言通常用于编写系统需求规范，它可能会造成混乱和难以理解 自然语言理解依赖于规范读者和作者对同一概念使用相同的词语 自然语言需求规范过于灵活 没有简单的方法来模块化自然语言需求 Structured language specifications 优点 保持自然语言的大部分表达性和可理解性 确保规范具有一定程度的一致性 Interface specification 接口规范 三种类型的接口 程序接口（如API） 数据结构 数据表示（如位的顺序） The software requirements document 软件要求文档 或称为软件需求规范（SRS）-- Software requirements specification 软件需求规范的读者 系统客户 管理者 系统工程师 系统测试工程师 系统维护工程师 需求文档的结构 前言 介绍 用户需求定义 系统架构 系统需求说明 系统模型 系统演化 附录 指数 Modeling 建模 抽象--Abstraction 抽象有助于控制问题复杂度，抓住问题的本质,获取一般和特殊关系 Modeling Notations 建模符号 对于建模、记录和沟通决策，使用标准符号(standard notations)是很重要的 建模帮助我们彻底理解需求 Entity-Relationship Diagrams 一种用于表示概念模型的流行图形符号范式 Entity 描述为矩形，表示具有公共属性和行为的真实世界对象的集合 Relationship 描述为两个实体之间的边缘，边缘中的菱形指定关系类型 attribute 实体上的注释，用于描述与该实体关联的数据或属性 Event Traces 事件跟踪 真实世界实体之间交换的事件序列的图形描述 A graphical description of a sequence of events that are exchanged between real-world entities 垂直线(Vertical line)：不同实体的时间线，其名称显示在该行的顶部 水平线(Horizontal line)：围绕该线的两个实体之间的事件或交互 时间是从上到下的 每个图都描述了一个跟踪，表示几种可能的行为之一 Message Sequence Chart 一种增强的事件跟踪表示法，具有创建和销毁实体、指定操作和计时器以及组成跟踪的功能 垂直线(Vertical line)表示参与的实体 消息(Message)被描述为从发送实体到接收实体的箭头 动作(Action)被指定为位于实体执行行上的带标签的矩形 条件(Condition)是实体演化中的重要状态，表示为标记的六边形 Petri Nets 一种形式或状态转换(state-transition)符号，用于对并发活动及其交互进行建模 圆圈(Circle)（地点）代表活动或条件 条形图(Bar)表示转换(transitions) 圆弧(Arcs)将transitions与其输入位置和输出位置连接起来 这些位置由令牌(tokens)填充，这些令牌充当转换的启用条件 可以为每个arc指定一个权重(weight)，该权重指定在触发转换时从arc的输入位置移除多少tokens Functions and Relations 形式化方法或途径：基于数学的规范和设计技术 形式化方法将需求或软件行为建模为数学函数或关系的集合 函数指定系统执行和输出的状态 每当输入值映射多个输出值时，就会使用关系 Functions and Relations的示例：Parnas表 列标题和行标题是用于指定案例的谓词 条目“X”在指定条件下可能无效，或者条件组合不可行 Decision Tables 它是功能规范的表格表示，将事件和条件映射到适当的响应或操作 如果有n个输入条件，则有2n个可能的输入条件组合 映射到同一组结果的组合可以组合到单个列中 Decision Trees 三种类型的“节点” 决策节点(Decision nodes)-由正方形表示 机会节点(Chance nodes)-由圆表示 终端节点(Terminal nodes)-由三角形表示（可选） 求解该树需要修剪决策节点上除最佳决策外的所有决策，并在机会节点上找到所有可能的自然状态的期望值 从左到右创建树 从右到左求解树 Logic 操作符号(operational notation)是用于描述问题或建议的软件解决方案的情景行为的符号 基于案例的行为模型 示例：状态机、事件跟踪、数据流图、功能方法 描述性表示(descriptive notation)法是根据问题的性质或变体来描述问题或建议解决方案的表示法 示例：逻辑 Petri Nets 介绍 Graphical and Mathematical modeling tools 图形和数学建模工具 图形工具 视觉传达辅助 数学工具 状态方程、代数方程等 并发(concurrent)、异步(asynchronous)、分布式(distributed)、并行(parallel)、非确定性(nondeterministic)和/或随机(stochastic)系统 非正式定义 Petri Nets的图形表示是一个二部图（bipartite graph） 有两种节点(node) Places：通常是模型资源(resource)或系统的部分状态 圆形 transitions: 模型状态转换和同步 方形 Arcs: 是有向的并且总是连接不同类型的节点 例子 State 系统的状态是通过用令牌(token)标记位置来建模的 一个地方可以用有限数量（可能为零）的标记来标记 Fire 触发 转换 t 在某个标记中被称为启用，如果对于从位置 p 到 t 的每条arc，标记中都存在一个不同的标记 启用的转换可以触发并产生新的标记 在标记中触发转换 t 是一个原子(atomic)操作 触发转换会导致两件事： 对于连接 p 到 t 的每条弧线，从任何位置 p 的标记中减去一个记号 对于连接 t 到 p 的每条弧线，在任何位置 p 的标记上添加一个记号 图形表示 Nondeterminism 不确定性 Petri Networks的执行是不确定的 可以同时启用多个转换，其中任何一个都可以触发 不需要触发 - 它们随意触发，在时间 0 到无穷大之间，或者根本不触发 Concurrency 并发 独立输入允许“并发”触发转换 Conflict 冲突 重叠输入使转换发生冲突 -- Overlapping inputs put transitions in conflict ​ 可能激发序列\\(t1,t3,t5\\)无限循环，而 \\(t2,t4,t6\\)被“饿死” Solution Mutual Exclusion 互斥 两个子网强制同步 Bounded Buffers 有界缓冲区 Liveness and Deadlock 活性与死锁 活力： 如果一个转换永远不能触发，它就是死锁的。 如果转换永远不会死锁，它就是live的。 时间 Petri Network 时间Petri网的思想：即使一个变迁处于使能状态，它也必须经过\\(t_{min}\\)之后才能被触发，且必须在\\(t_{max}\\)之前。 Fork and Join Iteration: 1 or more times Exercise 一个交通灯 Example: Single traffic light 两盏交通灯 使用互斥的原理 Restaurant Restaurant (Two Scenarios) Scenario 1: Waiter takes order from customer 1; serves customer 1; takes order from customer 2; serves customer 2. Scenario 2: Waiter takes order from customer 1; takes order from customer 2; serves customer 2; serves customer 1. Formal Definition Related Models Finite State Processes Finite State Nets Some Petri nets can be modelled by FSPs Implementing Petri 我们可以以集中或分散的方式实现 Petri 网结构 集中--Centralized 单个“网络管理器”监视网络的当前状态，并触发启用的转换。 分散--Decentralized Transitions 是进程，places 是共享资源，transitions 竞争获取令牌。 Centralized schemes 在一种可能的集中式方案中，管理器选择并触发启用的转换。 可以并行触发并发启用的转换。 Decentralized schemes 转换是过程，令牌是地方持有的资源 Role of a token token可以起到以下作用： 物理对象，例如产品、零件、药物、人； 信息对象，例如消息、信号、报告； 对象的集合，例如装有产品的卡车、装有零件的仓库或地址文件； 状态指示符，例如进程所处状态的指示符，或对象状态的指示符； 条件指示符：令牌的存在表明是否满足某个条件。 一种通信媒介，如电话线、中间人或通信网络； 缓冲区：例如，仓库、队列或邮筒； 地理位置，例如仓库、办公室或医院中的某个地方； 可能的状态或状态条件：例如，电梯所在的楼层，或有专家可用的条件。 Role of a transition 事件：例如，开始手术、患者死亡、季节变化或交通灯从红色变为绿色； 对象的转换，例如调整产品、更新数据库或更新文档； 对象的运输：例如，运输货物或发送文件。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"软件工程复习L2","slug":"软件工程复习L2","date":"2021-11-24T12:59:17.000Z","updated":"2023-04-26T11:19:54.847Z","comments":true,"path":"posts/5618/","link":"","permalink":"https://ye2222.github.io/posts/5618/","excerpt":"","text":"软件工程过程和软件生命期 软件生命期（Life cycle) 一个软件从定义、开发、使用和维护，直到最终被废弃，所经历的生存过程称为软件生存期或叫生命期。 软件过程模型--Software process models 是软件过程的抽象表示 三种过程模型 瀑布模型--The waterfall model 规范、开发、验证和演变的过程活动被视为单独的过程阶段 进化发展--Evolutionary development 交叉规范、开发和验证活动 基于组件的软件工程--Component-based software engineering 基于多个可重用组件的存在 集成这些组件 为过程建模的原因 形成共识 找到并评估实现过程目标的适当活动 针对将要使用的特定情况定制通用流程 瀑布模型--Waterfall model 瀑布模型中没有迭代 大多数软件开发应用了大量的迭代 缺点 不提供如何在开发期间处理产品和活动变更的指导（假设需求可以冻结） 将软件开发视为制造过程而不是创造性过程 不存在导致创建最终产品的迭代活动 在最终产品之前需要等待很长时间 原型 原型是部分开发的产品 原型设计有帮助 开发人员评估替代设计策略（设计原型） 用户了解系统将是什么样子（用户界面原型） 原型设计对于验证和确认很有用 V Model 是瀑布模型的一种变体 使用单元测试来验证程序设计--unit testing 使用集成测试验证体系结构（系统）设计--integration testing 使用验收测试来验证需求--acceptance testing 如果在验证和确认过程中发现问题，在重新实施右侧测试之前，可以重新执行V的左侧 Evolutionary development 定义：开发一个初始实现，将其公开给用户评论，并通过多个版本对其进行优化，直到开发出一个合适的系统 原型设计的两种基本类型 探索性开发--Exploratory development 一次性原型--Throwaway prototyping 优点 规范可以增量开发 是开发中小型系统的好方法 规范可以增量开发 是开发中小型系统的好方法 Incremental development 优点： 客户不必等到整个系统交付后才能从中获得价值 客户可以使用早期的增量作为原型，并获得经验，为以后的系统增量需求提供信息 整体项目失败的风险较低 大多数重要的系统服务不可避免地会受到最多的测试 增量和迭代的区别：Increments and Iterations 增量开发：从小型功能子系统开始，并在每个新版本中添加功能 迭代开发：从整个系统开始，然后在每个新版本中更改每个子系统的功能 Spiral development 这个过程被表示为一个螺旋 螺旋中的每个循环表示软件过程的一个阶段 螺旋中的每个环路被分成四个扇区 目标设定--Objective setting 风险评估--Risk assessment 开发和验证--Development and validation 计划--Planning Component-based software engineering--CBSE 软件重用 Other Process Models Relies on Formal Method (形式化方法) Operational Specification Model 在开发过程的早期执行（检查）需求并评估其影响 Transformational Model 较少的主要发展步骤 应用一系列转换将规范更改为可交付系统 Relies on formalism--基于形式 需要正式规范（允许转换） 过程活动--Process activities Software specification Software design and implementation 软件设计是对要实现的软件结构、作为系统一部分的数据、系统组件之间的接口以及有时使用的算法的描述 设计过程 The software design process Software implementation 软件开发 从系统设计过程中自然遵循 CASE工具可用于从设计生成框架程序，包括定义和实现接口的代码 编程是一项个人活动，没有一般流程可遵循 The debugging process Software validation 验证和确认（V&amp;V）旨在表明系统符合其规范并满足系统客户的要求。 包括检查和审查流程和系统测试。 checking and review processes and system testing. 系统测试涉及使用从系统要处理的实际数据的规范派生的测试用例来执行系统。 test cases The testing process System testing System evolution 软件优化（软件维护）的成本可能比软件开发要高得多 Computer-Aided software engineering (CASE) 计算机辅助软件工程（CASE） 包括设计编辑器、数据字典、编译器、调试器、系统构建工具等 活动的示例可以使用CASE实现自动化： 图形系统模型的发展 使用数据字典理解设计 从用户创建的图形界面描述生成用户界面 通过提供有关正在执行的程序的信息进行程序调试 自动将程序从编程语言的旧版本转换为更新版本 CASE整合 Tools 支持单个流程任务，如设计一致性检查、文本编辑等。 Workbenches 支持流程阶段，如规范或设计，通常包括许多集成工具。 Environments 支持整个软件过程的全部或大部分。通常包括几个集成工作台。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"软件工程复习L1","slug":"软件工程复习L1","date":"2021-11-22T08:29:44.000Z","updated":"2023-04-26T11:19:54.847Z","comments":true,"path":"posts/5298/","link":"","permalink":"https://ye2222.github.io/posts/5298/","excerpt":"","text":"Soft engineering 定义 Software engineering is an engineering discipline that is concerned with all aspects of software production from early system specification to maintaining the system after it has gone into use 软件工程是一门工程学科，涉及软件生产的各个方面，从早期的系统规范到系统投入使用后的维护 Engineering discipline Theories methods tools (formal or less formal approach) Software Engineering Solving Problems--软件工程三要素 Method 提供一系列软件开发技术。包括完成开发过程中各方面任务的方法并用某种特殊的语言或图形来描述。 UML and other models Design Pattern Formal method Agile Development Tool 软件工具为软件方法提供了自动的或半自动的支撑环境。将多种工具集成在一起可构成计算机辅助软件工程（ Computer-Aided Software Engineering 即CASE）的软件开发支撑系统。 Procedure 软件过程是将软件工程的方法和工具综合起来，进行软件开发活动。 Analysis (requirement specification) Design Implementation Testing 需要解决的问题 软件产品庞大而复杂 发展需要分析和综合(analysis, synthesis) 分析：将一个大问题分解成更小的、可以理解的部分 抽象是关键 综合：从较小的构建块构建（组合）软件 组合具有挑战性 分析 综合 The Software Life Cycle Software Process software process model a simplified description of a software process include activities of software process, software products and the role of people involved software development model Waterfall approach Iterative development Component-based software engineering Development process models four phases analysis (requirement specificiation) design implementation testing The waterfall model a phase cannot be started until the previous phase is completed. 除非前面的阶段结束，否则不会开始新的阶段 The iterative model software is developed in a series of steps. ANALYSIS PHASE 开发过程从分析阶段开始 此阶段产生一个规范文档，该文档显示软件将做什么，而不指定如何做 分析阶段可以使用两种不同的方法，这取决于实现阶段是使用过程编程语言还是面向对象语言完成的。 Procedure-oriented analysis also called structured analysis or classical analysis 是系统实现阶段使用过程语言时使用的分析过程。 Data flow diagrams 展示系统中数据的移动 Entity-relationship diagrams State diagrams Object-oriented analysis 在实现使用面向对象语言时使用的分析过程。 Use case diagrams four components: system, use cases, actors and relationships Class diagrams DESIGN PHASE 定义了系统将如何完成分析阶段定义的内容。 在设计阶段，定义了系统的所有组件。 Procedure-oriented design 需要设计过程和数据 在面向过程的设计中，整个系统被划分为一组过程或模块。 Structure charts 在面向过程的设计中，说明模块之间关系的常用工具是结构图。 Modularity 模块化 模块化意味着将一个大型项目分解为易于理解和处理的较小部分。 模块化意味着将一个大任务划分为可以相互通信的小任务 当系统被划分为模块时，有两个主要问题：耦合和内聚（coupling and cohesion） coupling 耦合 耦合是衡量两个模块相互绑定紧密程度的一种方法。 软件系统中模块之间的耦合必须最小化 当两个模块相互依赖时，它们紧密耦合--Tightly coupled 松耦合模块具有一定的依赖性，但它们的互连较弱--Loosely coupled 未耦合的模块完全没有互连；他们完全没有关系--Uncoupled modules cohesion 内聚 在计算机编程中，内聚性是指模块中的元素属于一起的程度。 从某种意义上说，它是一个类的方法和数据与该类所服务的统一目的或概念之间关系强度的度量。 具有高内聚性的模块往往更可取，因为高内聚性与软件的几个理想特性相关，包括健壮性、可靠性、可重用性和可理解性。 软件系统中模块内的内聚必须最大化。 Object-oriented design 在面向对象设计中，设计阶段通过详细说明类的细节继续进行。 一个类由一组变量（属性）和一组方法组成。 面向对象设计阶段列出了这些属性和方法的详细信息 IMPLEMENTATION PHASE 在这个阶段，程序员在面向过程的设计中为模块编写代码，或者在面向对象的设计中编写程序单元来实现类 Choice of language Software quality 高质量的软件系统是指满足用户需求、满足组织的操作标准并在为其开发的硬件上高效运行的系统。 如果我们想要实现高质量的软件系统，我们必须能够定义一些质量属性。 Software quality factors 操作性 兼容性 可移植性 TESTING PHASE 测试阶段的目标是发现错误，这意味着一个好的测试策略是发现最多错误的策略。 有两种类型的测试：玻璃盒（白盒）和黑盒 Glass-box testing 玻璃盒测试（或白盒测试）基于了解软件的内部结构。 测试的目标是确定软件的所有组件是否都达到了设计的目的。 玻璃盒测试假设测试人员了解软件的一切。 在这种情况下，软件就像一个玻璃盒子，盒子里的一切都是可见的。玻璃盒测试由软件工程师或专门团队完成。 Basis path testing--基本路径测试 此方法创建一组测试用例，这些测试用例至少执行软件中的每个语句一次。 Black-box testing 黑盒测试的名字来源于测试软件的概念，它不知道软件内部是什么，也不知道它是如何工作的。换句话说，软件就像一个测试人员看不见的黑匣子。 黑盒测试根据软件应该完成的功能（如输入和输出）测试软件的功能。 Exhaustive testing 最好的黑盒测试方法是测试软件在输入域中的所有可能值。 然而，在复杂的软件中，输入域是如此巨大，以至于这样做通常是不切实际的。 Random testing 在随机测试中，选择输入域中的值子集进行测试。 选择子集的方式必须确保值分布在域输入上，这一点非常重要。 在这种情况下，使用随机数生成器非常有用。 Boundary-value testing 遇到边界值时，经常会发生错误。 例如，如果模块定义其输入之一必须大于或等于100，则测试模块的边界值100非常重要。 如果模块在此边界值处失败，则模块代码中的某些条件（如x）可能会失效≥ 100写为x&gt;100。 DOCUMENTATION 为了正确使用和有效维护软件，需要文档。 通常，为软件准备三套独立的文档：用户文档、系统文档和技术文档。 user documentation, system documentation and technical documentation. 文件编制是一个持续的过程。 User documentation 为了正确运行软件系统，用户需要文档，传统上称为用户指南，它显示了如何一步一步地使用软件。 用户指南通常包含一个教程部分，用于指导用户了解软件的每个功能。 一个好的用户指南可以是一个非常强大的营销工具：用户文档在营销中的重要性怎么强调都不过分。 用户指南应该为新手和专家用户编写，一个具有良好用户文档的软件系统肯定会增加销量。 System documentation 系统文档定义了软件本身。 它的编写应该使软件能够由原始开发人员以外的人进行维护和修改。 系统开发的所有四个阶段都应有系统文档。 Technical documentation 技术文档描述了软件系统的安装和维修。 安装文档定义了软件应如何安装在每台计算机上，例如服务器和客户端。 服务文档定义了在必要时应如何维护和更新系统。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[]},{"title":"pandasL1","slug":"pandasL1","date":"2021-11-05T13:01:41.000Z","updated":"2023-04-26T11:19:54.736Z","comments":true,"path":"posts/38677/","link":"","permalink":"https://ye2222.github.io/posts/38677/","excerpt":"","text":"Series和DataFrame 分别代表着一维的序列和二维的表结构 Series Series 是个定长的字典序列。说是定长是因为在存储的时候，相当于两个 ndarray Series有两个基本属性：index 和 values。 在 Series 结构中，index 默认是 0,1,2,……递增的整数序列，当然我们也可以自己来指定索引 1234567import pandas as pdfrom pandas import Series, DataFramex1 = Series([1,2,3,4])x2 = Series(data=[1,2,3,4], index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])d = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2, &#x27;c&#x27;:3, &#x27;d&#x27;:4&#125;x3 = Series(d) Series内部的列表时基于numpy的array实现的 ```python pd.Series([1, 2]).values array([1, 2]) 12345678910111213141516 #### DataFrame- 包括了行索引和列索引，我们可以将 DataFrame 看成是由相同索引的 Series 组成的字典类型。```pythonimport pandas as pdfrom pandas import Series, DataFramedata = &#123;&#x27;Chinese&#x27;: [66, 95, 93, 90,80], &#x27;English&#x27;: [65, 85, 92, 88, 90], &#x27;Math&#x27;: [30, 98, 96, 77, 90]&#125;df1= DataFrame(data)df2 = DataFrame(data, index=[&#x27;ZhangFei&#x27;, &#x27;GuanYu&#x27;, &#x27;ZhaoYun&#x27;, &#x27;HuangZhong&#x27;, &#x27;DianWei&#x27;], columns=[&#x27;English&#x27;, &#x27;Math&#x27;, &#x27;Chinese&#x27;]) 数据清洗的一些操作 重命名列名 columns，让列表名更容易识别 ```python df2.rename(columns={origin:change}) df2.columns.names = [] # 设置列索引名 df2.index,names = [] 12345- **去重复的值** - ```python df.drop_duplicates() 格式问题 ```python df.column.astype(type) 123456789101112131415161718192021- **数据间的空格** - ```python # 删除左右两边空格 df2[&#x27;Chinese&#x27;]=df2[&#x27;Chinese&#x27;].map(str.strip) # 删除左边空格 df2[&#x27;Chinese&#x27;]=df2[&#x27;Chinese&#x27;].map(str.lstrip) # 删除右边空格 df2[&#x27;Chinese&#x27;]=df2[&#x27;Chinese&#x27;].map(str.rstrip) # 去除$ df2[&#x27;Chinese&#x27;]=df2[&#x27;Chinese&#x27;].str.strip(&#x27;$&#x27;) # 大小写转换 # 全部大写 df2.columns = df2.columns.str.upper() # 全部小写 df2.columns = df2.columns.str.lower() # 首字母大写 df2.columns = df2.columns.str.title() 查找空值 ```python df.isnull() 知道哪列存在空值 df.isnull().any() # 寻找非空值 df.notnull() 123456789101112131415- **使用apply函数对数据进行清洗** - ```python df[&#x27;name&#x27;] = df[&#x27;name&#x27;].apply(str.upper) def double_df(x): return 2*x df1[u&#x27;语文&#x27;] = df1[u&#x27;语文&#x27;].apply(double_df) def plus(df,n,m): df[&#x27;new1&#x27;] = (df[u&#x27;语文&#x27;]+df[u&#x27;英语&#x27;]) * m df[&#x27;new2&#x27;] = (df[u&#x27;语文&#x27;]+df[u&#x27;英语&#x27;]) * n return df df1 = df1.apply(plus,axis=1,args=(2,3,)) 读取CSV文件 123456fixed_df = pd.read_csv(&#x27;../data/bikes.csv&#x27;, sep=&#x27;;&#x27;, encoding=&#x27;latin1&#x27;, parse_dates=[&#x27;Date&#x27;], dayfirst=True, index_col=&#x27;Date&#x27;) 可以将某些列转换成日期 dayfirst将日期的列提前 encoding解码方式 查看DataFrame的信息 查看行数和列数 1234df.shape# (20, 4) 20行数据，4列属性df.shape[0] # 行数df.shape[1] # 列数 删除 DataFrame 中的不必要的列或行 12df.drop(columns=[])df.drop(index=[]) apply函数的使用 跟lambda函数一起使用 可以改变某列的数据类型 ```python dollarizer = lambda x: float(x[1:-1]) chipo.item_price = chipo.item_price.apply(dollarizer) 123456789101112131415### 对DataFrame的行进行操作#### 查看前几行的数据```python# 显示前五行# 切片df[:5]# locdf.loc[&#x27;index1&#x27;:&#x27;index5&#x27;, :]# ilocdf.iloc[:5, :] 在loc和iloc中使用切片选中时，不需要加列表外套，除非选择几个需要整合成一个列表 丢弃某一行数据 丢弃数据全为NaN的行 1df = df.dropna() 丢弃数据全为0的行 12345678# 找到全为0的行(df==0).all(axis=1)# 选中这些行df[(df==0).all(axis=1)]# 反选不全为0的行df[~(df==0).all(axis=1)] 对DataFrame中的列进行操作 选取一列以及多列 12345# 有两种，如果列名中有空格只能用第一种df[&#x27;列名&#x27;]df.列名df[[&#x27;column1&#x27;, &#x27;column2&#x27; ...]] 对一列进行绘图 12345# 默认是折线图df[&#x27;列名&#x27;].plot()# 对整个DataFrame绘图df.plot() 对列进行计数 1df[&#x27;column&#x27;].value_counts() 会忽略NaN值 计数结果会进行排序，但是两个计数结果进行算术操作时，会按正确对应关系进行操作 选取符合条件的列 12345df1 = df[df.column == condition]# 或：| 和：&amp;complaints[is_noise &amp; in_brooklyn][:5]complaints[is_noise | in_brooklyn][:5] 利用Counter对DataFrame中的一列进行计数 1234x = df.item_namey = Counter(x)df1 = pd.DataFrame.from_dict(y, orient=&#x27;index&#x27;)df1 = df1[0].sort_values(ascending = True)[45:50] pd.DataFrame.from_dict()可将Counter类型转换成DataFrame 改变DataFrame中列的顺序 可以通过选取列，重新组织顺序 1df1 = df[[&#x27;name&#x27;, &#x27;type&#x27;, &#x27;hp&#x27;, &#x27;evolution&#x27;, &#x27;pokedex&#x27;]] 改变DataFrame中列的名字 可以直接对df.columns赋值一个列表 123df1.columns = [&#x27;alcohol&#x27;, &#x27;malic_acid&#x27;, &#x27;alcalinty_of_ash&#x27;, &#x27;magnesium&#x27;, &#x27;flavanoids&#x27;, &#x27;proanthocyanins&#x27;, &#x27;hue&#x27;]df1 NaN值的操作 填充DataFrame中的NaN值 1df.fillna(1, inplace=True) # 将NaN全部填充为1 删除带有NaN值的行 123df=df.dropna(how=&#x27;any&#x27;)DataFrame.dropna(axis=0, how=&#x27;any&#x27;, thresh=None, subset=None, inplace=False) Parameters 说明 axis 0为行 1为列，default 0，数据删除维度 how {‘any’, ‘all’}, default ‘any’， any：删除带有nan的行；all：删除全为nan的行 thresh int，保留至少 int 个非nan行 subset list，在特定列缺失值处理 inplace bool，是否修改源文件 DataFrame的索引 DataFrame重新设置索引 1df = df.reset_index(drop=True) drop=True会将原来的索引舍弃 DataFrame的多级索引 1234df = pd.DataFrame(np.random.randint(80, 120, size=(6, 4)), index= pd.MultiIndex.from_product([[1, 2, 3],[&#x27;girl&#x27;, &#x27;boy&#x27;]]), columns=pd.MultiIndex.from_product([[&#x27;English&#x27;,&#x27;Chinese&#x27;], [&#x27;Y&#x27;,&#x27;N&#x27;]])) 多级索引的排序 123df.columns.names = [&#x27;Language&#x27;, &#x27;Pass&#x27;] # 设置列索引名df.index.names = [&#x27;Class&#x27;, &#x27;Six&#x27;] # 设置行索引名df.sort_index(level=0, axis=0, ascending=False) # 对行索引Class的值进行降序排列 多级索引轴向转换 stack() : 将行索引变成列索引，可以理解为将表格数据转换为树状数据 unstack() : 将列索引变成行索引，可以理解为将树状数据转换为表格数据 两个函数互为逆函数，作用相反，用法相同。单级索引时，结果会生成一个Series；多级索引时默认转换最内层索引，也可以自定义转换的索引层级 获取股票数据 使用alpha_vantage 1234567import pandas as pdfrom alpha_vantage.timeseries import TimeSeriests = TimeSeries(key=&#x27;WRB3PU9PRGSGVS2H&#x27;, output_format=&#x27;pandas&#x27;)data, meta_data = ts.get_intraday(symbol=&#x27;MSFT&#x27;,interval=&#x27;1week&#x27;, outputsize=&#x27;full&#x27;)data.to_csv(&quot;./Test_1.csv&quot;, encoding=“utf-8-sig”) key=WRB3PU9PRGSGVS2H symbol是获取股票的名称，interval是时间间隔 interval取值：1min,5min,15min,30min,60min 使用pandas_datareader.data 12345import pandas_datareader.data as webstart = datetime.datetime(2015, 1, 1)end = datetime.datetime(2021, 11, 4)stock = web.DataReader(&quot;600797.SS&quot;, &quot;yahoo&quot;, start, end) DataFrame的合并 concat 1pd.concat([df1,df2,df3],axis=0,ignore_index=True) 参数axis=0表示上下合并，1表示左右合并，ignore_index=True表示忽略原来的索引 join参数 join为‘inner’时 会裁剪吊互相之间没有的数据， join为‘outer’时 会用NaN值来填充相互之间没有的数据 merge 123pd.merge(left, right, how=&#x27;inner&#x27;, on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True, suffixes=(&#x27;_x&#x27;, &#x27;_y&#x27;), copy=True, indicator=False) append 1df.append(df1) 当索引为日期时 获取索引代表的星期数 1df.index.weekday 同理可得到月的、年的等 将属性改变成datetime 使用pd.to_datetime对列或者索引进行改变 1df.index = pd.to_datetime(df.index) 改变时间频率 改变为每一周、每个月，每个年等 使用df.resample('Y') Y是年，M是月，W是周 12# 一个月一个月频率的DataFramemonthly = df.resample(&#x27;M&#x27;)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"pandas","slug":"编程语言/python/pandas","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/pandas/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"pandasL2","slug":"pandasL2","date":"2021-11-05T13:01:41.000Z","updated":"2023-04-26T11:19:54.754Z","comments":true,"path":"posts/38485/","link":"","permalink":"https://ye2222.github.io/posts/38485/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"matplotlibL1","slug":"matplotlibL1","date":"2021-11-03T16:00:50.000Z","updated":"2023-04-26T11:19:54.685Z","comments":true,"path":"posts/763/","link":"","permalink":"https://ye2222.github.io/posts/763/","excerpt":"","text":"设置风格 1plt.style.use(&#x27;ggplot&#x27;) 直方图 横轴为文字的样式 数据集：pandas中的DataFrame或者Series 使用plot选择类型，需要数据集提前处理好为两个量 12345df.plot(kind=&#x27;bar&#x27;)df.xlabel()df.ylabel()df.title()plt.show() 散点图 函数： 1plt.scatter(x=None, y=None, c=颜色, s=点的大小)","categories":[{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"matplotlib","slug":"画图/matplotlib","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/matplotlib/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"seabornL1","slug":"seabornL1","date":"2021-11-03T12:16:23.000Z","updated":"2023-04-26T11:19:54.754Z","comments":true,"path":"posts/6548/","link":"","permalink":"https://ye2222.github.io/posts/6548/","excerpt":"","text":"1import seaborn as sns seaborn是基于matplotlib的一个库 sns.FacetGrid() 作用：可以在数据集的子集中分别可视化变量的分布或多个变量之间的关系 一个FacetGrid可以与多达三个维度可以得出：row，col，和hue 1234# 只列出常用的参数g = sns.FacetGrid(data, row=None, col=None, hue=None, sharex=True, sharey=True) 更多参数可参考：seaborn.FacetGrid()——API map() 作用：在FacetGird构建的网格上绘制图 1g.map(plt.图形, d)","categories":[{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"seaborn","slug":"画图/seaborn","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/seaborn/"}],"tags":[]},{"title":"数据分析L1","slug":"数据分析L1","date":"2021-11-02T14:35:24.000Z","updated":"2023-04-26T11:19:54.793Z","comments":true,"path":"posts/44041/","link":"","permalink":"https://ye2222.github.io/posts/44041/","excerpt":"","text":"数据分析的三个重要组成部分 数据采集 数据挖掘 数据可视化 数据采集 数据挖掘 数据可视化 数据挖掘 基本流程 商业理解：从商业的角度理解项目需求，在这个基础上，再对数据挖掘的目标进行定义。 数据理解：尝试收集部分数据，然后对数据进行探索，包括数据描述、数据质量验证等。对收集的数据有个初步的认知。 数据准备：开始收集数据，并对数据进行清洗、数据集成等操作，完成数据挖掘前的准备工作。 模型建立：选择和应用各种数据挖掘模型，并进行优化，以便得到更好的分类结果。 模型评估：对模型进行评价，并检查构建模型的每个步骤，确认模型是否实现了预定的商业目标。 上线发布：呈现的形式可以是一份报告，也可以是实现一个比较复杂的、可重复的数据挖掘过程 Numpy 为什么要使用numpy的数据结构，而不是用Python自带的list list的元素在系统内存中是分散存储的，Numpy数组存储在一个均匀连续的内存块中，遍历可以节省计算资源 内存访问模式中，数据连续的存储在内存中，Numpy直接利用现在CPU的矢量化指令计算，加载寄存器中的多个连续浮点数 Numpy的矩阵计算可以采用多线程的方式，提升计算效率 一个重要提升内存和计算资源的利用率的规则 避免采用隐式拷贝，而是采用就地操作的方式 自己创造类型 1234567import numpy as nppersontype = np.dtype(&#123; &#x27;names&#x27;:[&#x27;name&#x27;, &#x27;age&#x27;, &#x27;chinese&#x27;, &#x27;math&#x27;, &#x27;english&#x27;], &#x27;formats&#x27;:[&#x27;S32&#x27;,&#x27;i&#x27;, &#x27;i&#x27;, &#x27;i&#x27;, &#x27;f&#x27;]&#125;)peoples = np.array([(&quot;ZhangFei&quot;,32,75,100, 90),(&quot;GuanYu&quot;,24,85,96,88.5), (&quot;ZhaoYun&quot;,28,85,92,96.5),(&quot;HuangZhong&quot;,29,65,85,100)], dtype=persontype) Pandas Series和DataFrame 分别代表着一维的序列和二维的表结构 Series Series 是个定长的字典序列。说是定长是因为在存储的时候，相当于两个 ndarray Series有两个基本属性：index 和 values。 在 Series 结构中，index 默认是 0,1,2,……递增的整数序列，当然我们也可以自己来指定索引 1234567import pandas as pdfrom pandas import Series, DataFramex1 = Series([1,2,3,4])x2 = Series(data=[1,2,3,4], index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])d = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2, &#x27;c&#x27;:3, &#x27;d&#x27;:4&#125;x3 = Series(d) DataFrame 包括了行索引和列索引，我们可以将 DataFrame 看成是由相同索引的 Series 组成的字典类型。 12345678import pandas as pdfrom pandas import Series, DataFramedata = &#123;&#x27;Chinese&#x27;: [66, 95, 93, 90,80], &#x27;English&#x27;: [65, 85, 92, 88, 90], &#x27;Math&#x27;: [30, 98, 96, 77, 90]&#125;df1= DataFrame(data)df2 = DataFrame(data, index=[&#x27;ZhangFei&#x27;, &#x27;GuanYu&#x27;, &#x27;ZhaoYun&#x27;, &#x27;HuangZhong&#x27;, &#x27;DianWei&#x27;], columns=[&#x27;English&#x27;, &#x27;Math&#x27;, &#x27;Chinese&#x27;]) 数据清洗 删除 DataFrame 中的不必要的列或行 ```python df.drop(columns=[]) df.drop(index=[]) 12345- **重命名列名 columns，让列表名更容易识别** - ```python df2.rename(columns=&#123;origin:change&#125;) 去重复的值 ```python df.drop_duplicates() 12345- **格式问题** - ```python df.column.astype(type) 数据间的空格 ```python # 删除左右两边空格 df2['Chinese']=df2['Chinese'].map(str.strip) # 删除左边空格 df2['Chinese']=df2['Chinese'].map(str.lstrip) # 删除右边空格 df2['Chinese']=df2['Chinese'].map(str.rstrip) 去除$ df2['Chinese']=df2['Chinese'].str.strip('$') 大小写转换 全部大写 df2.columns = df2.columns.str.upper() # 全部小写 df2.columns = df2.columns.str.lower() # 首字母大写 df2.columns = df2.columns.str.title() 12345678910- **查找空值** - ```python df.isnull() # 知道哪列存在空值 df.isnull().any() # 寻找非空值 df.notnull() 使用apply函数对数据进行清洗 ```python df['name'] = df['name'].apply(str.upper) def double_df(x): return 2*x df1[u'语文'] = df1[u'语文'].apply(double_df) def plus(df,n,m): df['new1'] = (df[u'语文']+df[u'英语']) * m df['new2'] = (df[u'语文']+df[u'英语']) * n return df df1 = df1.apply(plus,axis=1,args=(2,3,)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211103092114173.png)### 数据分析的一些概念- 商业智能 BI、数据仓库 DW、数据挖掘 DM - 元数据 VS 数据元 - **元数据**（MetaData）：描述其它数据的数据，也称为“中介数据”。 - **数据元**（Data Element）：就是最小数据单元。![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211103101608794.png)#### 数据预处理1. 数据清洗 - 主要是为了去除重复数据，去噪声（即干扰数据）以及填充缺失值。2. 数据集成 - 是将多个数据源中的数据存放在一个统一的数据存储中。3. 数据变换 - 就是将数据转换成适合数据挖掘的形式### 用户画像：标签化![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211103190809281.png)#### 设计唯一标签- **用户唯一标识是整个用户画像的核心**。- 设计唯一标识可以从这些项中选择：用户名、注册手机号、联系人手机号、邮箱、设备号、CookieID 等。#### 给用户打标签**用户消费行为分析**1. 用户标签：它包括了性别、年龄、地域、收入、学历、职业等。这些包括了用户的基础属性。2. 消费标签：消费习惯、购买意向、是否对促销敏感。这些统计分析用户的消费习惯。3. 行为标签：时间段、频次、时长、访问路径。这些是通过分析用户行为，来得到他们使用 App 的习惯。4. 内容分析：对用户平时浏览的内容，尤其是停留时间长、浏览次数多的内容进行分析，分析出用户对哪些内容感兴趣，比如，金融、娱乐、教育、体育、时尚、科技等#### 用户生命周期1. 获客：如何进行拉新，通过更精准的营销获取客户。2. 粘客：个性化推荐，搜索排序，场景运营等。3. 留客：流失率预测，分析关键节点降低流失率。![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211103191209718.png)### 数据采集#### 数据源![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211103191731121.png)开放数据源![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211103192228170.png)#### 爬虫抓取- 使用 Python 编写爬虫代码- **[火车采集器](http://www.locoy.com/)**- **[八爪鱼](http://www.bazhuayu.com/)** - 可云采集- **[集搜客](http://www.gooseeker.com/)**#### 日志采集1. 通过 Web 服务器采集，例如 httpd、Nginx、Tomcat 都自带日志记录功能。同时很多互联网企业都有自己的海量数据采集工具，多用于系统日志采集，如 Hadoop 的 Chukwa、Cloudera 的 Flume、Facebook 的 Scribe 等，这些工具均采用分布式架构，能够满足每秒数百 MB 的日志数据采集和传输需求。2. 自定义采集用户行为，例如用 JavaScript 代码监听用户的行为、AJAX 异步请求后台记录日志等。4##### 埋点- 埋点是日志采集的关键步骤- **埋点就是在有需要的位置采集相应的信息，进行上报**- 埋点就是在你需要统计数据的地方植入统计代码，当然植入代码可以自己写，也可以使用第三方统计工具### 数据清洗#### 4个关键点：完全合一1. **完**整性：单条数据是否存在空值，统计的字段是否完善。2. **全**面性：观察某一列的全部数值，比如在 Excel 表中，我们选中一列，可以看到该列的平均值、最大值、最小值。我们可以通过常识来判断该列是否有问题，比如：数据定义、单位标识、数值本身。3. **合**法性：数据的类型、内容、大小的合法性。比如数据中存在非 ASCII 字符，性别存在了未知，年龄超过了 150 岁等。4. 唯**一**性：数据是否存在重复记录，因为数据通常来自不同渠道的汇总，重复的情况是常见的。行数据、列数据都需要是唯一的，比如一个人不能重复记录多次，且一个人的体重也不能在列指标中重复记录多次。### 数据集成#### 两种架构：ELT和ETL1. ETL - 提取 (Extract)——转换 (Transform)——加载 (Load) - 在数据源抽取后首先进行转换，然后将转换的结果写入目的地。2. ELT - 提取 (Extract)——加载 (Load)——变换 (Transform) - 在抽取后将结果先写入目的地，然后利用数据库的聚合分析能力或者外部计算框架![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211109211202429.png)- ELT 和 ETL 相比，最大的区别是“重抽取和加载，轻转换”，从而可以用更轻量的方案搭建起一个数据集成平台- ELT 架构中，数据变换这个过程根据后续使用的情况，需要在 SQL 中进行，好处是你可以从数据源中提取数据，经过少量预处理后进行加载### 数据变换![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211110104502508.png)数据变换是数据准备的重要环节，它**通过数据平滑、数据聚集、数据概化和规范化等方式**将数据转换成适用于数据挖掘的形式。#### 常见的变换方式1. **数据平滑**：去除数据中的噪声，将连续数据离散化。这里可以采用分箱、聚类和回归的方式进行数据平滑，我会在后面给你讲解聚类和回归这两个算法；2. **数据聚集**：对数据进行汇总，在 SQL 中有一些聚集函数可以供我们操作，比如 Max() 反馈某个字段的数值最大值，Sum() 返回某个字段的数值总和；3. **数据概化**：将数据由较低的概念抽象成为较高的概念，减少数据复杂度，即用更高的概念替代更低的概念。比如说上海、杭州、深圳、北京可以概化为中国。4. **数据规范化**：使属性数据按比例缩放，这样就将原来的数值映射到一个新的特定区域中。常用的方法有最小—最大规范化、Z—score 规范化、按小数定标规范化等5. **属性构造**：构造出新的属性并添加到属性集中。这里会用到特征工程的知识，因为通过属性与属性的连接构造新的属性，其实就是特征工程。比如说，数据表中统计每个人的英语、语文和数学成绩，你可以构造一个“总和”这个属性，来作为新属性。这样“总和”这个属性就可以用到后续的数据挖掘计算中。最简单易用的就是对数据进行规范化处理#### 数据规范化的几种方法#### **1. Min-max 规范化**Min-max 规范化方法是将原始数据变换到 [0,1] 的空间中。用公式表示就是：新数值 =（原数值 - 极小值）/（极大值 - 极小值）。![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211110141838915.png)- 是在列上进行计算- 每一行表示一个样本，每一列表示一个特征#### **2. Z-Score 规范化**可以使用相同的标准比价两个不同标准下的数值新数值 =（原数值 - 均值）/ 标准差![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211110105307778.png)![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211110105250916.png)![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211110142530601.png)#### **3. 小数定标规范化**- 小数定标规范化就是通过移动小数点的位置来进行规范化。- 小数点移动多少位取决于属性 A 的取值中的最大绝对值。- 举个例子，比如属性 A 的取值范围是 -999 到 88，那么最大绝对值为 999，小数点就会移动 3 位，即新数值 = 原数值 /1000。那么 A 的取值范围就被规范化为 -0.999 到 0.088。#### 数据可视化#### 使用视图背后的目的![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211110143436461.png)- 呈现某个变量的分布情况，就可以通过直方图的形式来呈现- 想要看两个变量之间的相关性及分布情况，可以采用散点图的形式呈现。- 散点图既可以表明两个变量之间的关系，也可以体现它们的分布情况#### 前端可视化组件**Canvas 和 SVG 是 HTML5 中主要的 2D 图形技术，WebGL 是 3D 框架。**- **Canvas 适用于位图** - Canvas 技术可以绘制比较复杂的动画 - 就是给了你一张白板，需要你自己来画点- **SVG** 的中文是可缩放矢量图形，它是使用 XML 格式来定义图形的 - SVG 经常用于图标和图表上。它最大的特点就是支持大部分浏览器，动态交互性实现起来也很方便，比如在 SVG 中插入动画元素等。- **WebGL 是一种 3D 绘图协议**，能在网页浏览器中呈现 3D 画面技术，并且可以和用户进行交互。![](https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20211110150319836.png)#### 可视化视图四种关系1. 比较：比较数据间各类别的关系，或者是它们随着时间的变化趋势，比如折线图；2. 联系：查看两个或两个以上变量之间的关系，比如散点图；3. 构成：每个部分占整体的百分比，或者是随着时间的百分比变化，比如饼图；4. 分布：关注单个变量，或者多个变量的分布情况，比如直方图。按照变量的个数，我们可以把可视化视图划分为单变量分析和多变量分析。散点图：```pythonimport pandas as pdimport matplotlib.pyplot as pltimport seanborn as sns # 散点图plt.scatter(x, y)sns.jointplot(x, y, data=, kind=&#x27;scatter&#x27;)# 折线图plt.plot(x, y)sns.lineplot(x, y, data=)# 直方图plt.hist(x)sns.distplot(x)# 条形图plt.bar(x, y)sns.barplot(x, y)# 箱型图plt.boxplot(x)sns.boxplot(x)# 饼图plt.pie(x)# 热力图sns.heatmap()# 蜘蛛图# 画图数据准备，角度、状态值labels=np.array([u&quot; 推进 &quot;,&quot;KDA&quot;,u&quot; 生存 &quot;,u&quot; 团战 &quot;,u&quot; 发育 &quot;,u&quot; 输出 &quot;])stats=[83, 61, 95, 67, 76, 88]angles=np.linspace(0, 2*np.pi, len(labels), endpoint=False)stats=np.concatenate((stats,[stats[0]]))angles=np.concatenate((angles,[angles[0]]))fig = plt.figure()ax = fig.add_subplot(111, polar=True) ax.plot(angles, stats, &#x27;o-&#x27;, linewidth=2)ax.fill(angles, stats, alpha=0.25)# 二元变量分布# 用 Seaborn 画二元变量分布图（散点图，核密度图，Hexbin 图）sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&#x27;scatter&#x27;)sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&#x27;kde&#x27;)sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&#x27;hex&#x27;)# 成对关系sns.pairplot()","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://ye2222.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[]},{"title":"Transformer","slug":"Transformer","date":"2021-11-01T12:32:03.000Z","updated":"2023-04-26T11:19:54.682Z","comments":true,"path":"posts/15915/","link":"","permalink":"https://ye2222.github.io/posts/15915/","excerpt":"","text":"seq2seq 基于attention的seq2seq 可视化过程 基于transformer的seq2seq 结构 深入分析 流程：编码器输入数据处理-&gt;编码器运行-&gt;解码器输入数据处理-&gt;解码器运行-&gt;分类head 编码器输入数据处理 单词嵌入：用向量来标记单词 位置编码(positional encoding) transfromer内部没有rnn，没有捕捉顺序序列的能力 编码词向量时引入了位置编码position encoding向量来表示两个单词i和j之间的距离 即在词向量中加入了单词的位置信息 方法： 网络自动学习： 1self.pos_embedding = nn.Parameter(torch.randn(1, N, 512)) 定义一个超参数，形状与输入嵌入一致，进行相加 自己定义规则 Attention is all you need 中采用了sin-cos规则，具体做法是 将向量(N,512)采用如下函数进行处理 pos即0~N,i是0-511 将一个词向量中的512维度切分为奇数行(cos函数)和偶数行(sin函数) 按照原始行号进行拼接 代码： 1234567891011def get_position_angle_vec(position): # hid_j是0-511,d_hid是512，position表示单词位置0～N-1 return [position / np.power(10000, 2 * (hid_j // 2) / d_hid) for hid_j in range(d_hid)]# 每个单词位置0～N-1都可以编码得到512长度的向量sinusoid_table = np.array([get_position_angle_vec(pos_i) for pos_i in range(n_position)])# 偶数列进行sinsinusoid_table[:, 0::2] = np.sin(sinusoid_table[:, 0::2]) # dim 2i# 奇数列进行cossinusoid_table[:, 1::2] = np.cos(sinusoid_table[:, 1::2]) # dim 2i+1 可视化","categories":[{"name":"论文","slug":"论文","permalink":"https://ye2222.github.io/categories/%E8%AE%BA%E6%96%87/"}],"tags":[]},{"title":"numpyL8","slug":"numpyL8","date":"2021-10-30T05:02:33.000Z","updated":"2023-04-26T11:19:54.696Z","comments":true,"path":"posts/25047/","link":"","permalink":"https://ye2222.github.io/posts/25047/","excerpt":"","text":"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"操作系统L15","slug":"操作系统L15","date":"2021-10-28T01:54:39.000Z","updated":"2023-04-26T11:19:54.763Z","comments":true,"path":"posts/24231/","link":"","permalink":"https://ye2222.github.io/posts/24231/","excerpt":"","text":"长期存储信息的三个基本要求： 能够存储大量信息 使用信息的进程终止时，保存的信息仍旧存在 必须能使多个进程并发访问有关信息 解决方案：将信息以称为文件的单位存储在磁盘或其他外部媒体上。 File 文件 文件是进程创建的信息逻辑单元 文件是对磁盘的建模 可以把每个文件看成一个地址空间 文件命名 是一种抽象机制，提供了一种在磁盘上保存信息而且方便以后读取的方法 每一个文件至少有一个名字 名字可能包括了文件内容的信息，让人知道里面有什么，计算机可能会使用名字的一部分去决定文件类型 文件结构 Windows和UNIX：字节序列 Large mainframe computers 大型主机：Tree 文件类型 普通文件 ASCII文件：可以显示和打印以及在文本编辑器中编辑 二进制文件 文件访问 顺序访问 Sequential access 进程在系统中可从头按顺序读取文件的全部字节或记录 但不能跳过某一些内容，也不能不按顺序读取 可以返回到起点的，需要时可多次读取该文件 存储介质是磁带(magenetic tape)时比较方便 随机访问文件 Random access 用磁盘可以不按顺序读取文件，或者按照关键字 能够以任何次序读取其中字节或记录的文件 对数据库系统必不可少 seek操作设置当前位置，之后从这个当前位置顺序地开始读文件 文件属性 attribute，也叫元数据(metadata) 文件操作 目录 Directories 文件系统有目录或文件夹来跟踪文件。 一个单级目录有一个包含所有文件的目录（根）。 两级目录具有根目录和用户目录。 分层目录有一个根目录和任意数量的子目录。 A single level directory system 一级目录系统 优点：简单、并且能够快速定位文件 Two-level Directory Systems 两级目录系统 Hierarchical Directory Systems 层次目录系统 A UNIX directory tree 两种不同的方法用于在目录树中指定文件名： 绝对路径名(absolute path name)由从根目录到文件的路径组成。 例如，cp /usr/ast/mailbox /usr/ast/mailbox.bak 相对路径名(relative path name)由当前目录（工作目录）的路径组成。 例如，cp ../lib/dictionary → cp /usr/lib/dictionary 不同系统的路径名不同： Windows： UNIX：/usr/ast/邮箱 MULTICS：&gt;usr&gt;ast&gt;邮箱 “.” 和“..”是文件系统中的两个特殊条目。 点 (.) 指的是当前目录（工作目录） 点点 (..) 指的是它的父级 Directory Operaitons 文件系统的实现 File System Layout 文件系统布局 文件系统布局： MBR（主引导记录）用于引导计算机。 分区表给出了每个分区的起始地址和结束地址。 MBR(Master Boot Record, 主引导记录)： 磁盘的0号扇区 在MBR的结尾是分区表，给出了每个分区的起始和结束地址 表中的一个分区被标记为活动分区 在计算机被引导时，BIOS读入并执行MBR MBR做的第一件事是确定活动分区，读入它的第一个块，称为引导块(boot block)，并执行 为统一起见，每个分区都从一个引导块开始，即使它不含可启动的操作系统。 Boot block 引导块：系统启动时由MBR程序读入。 Superblock 超级块：包含文件系统的关键参数。 Free blocks information 空闲块信息 I-nodes 告诉所有关于文件的信息。 Root directory 根目录 Directories and files 目录和文件 File Allocation 文件的实现 连续分配 Contiguous Allocation 将每个文件存储为连续的数据块。 好处： 实施简单； 读取性能非常好。 缺点： 磁盘碎片 Disk fragmentation 创建文件时必须知道最大文件大小。 示例：CD-ROM、DVD File Control Block 文件控制块 一个文件由文件控制块（FCB）和文件体组成。 FCB存储文件的属性信息 例如，名称、路径、访问控制信息。 在Unix中，FCB是由i-node实现的 问题 FIFO SSF Elevator algorithm Check points List three reasons for long-term information storage; What is sequence of bytes file structure? Please list at least five common file attributes. 没有文件名也没有文件类型 What is relative path name and why do we need relative path name? Solution 三点 存储容量受虚拟地址空间大小的限制，不同的应用对地址空间的要求不同； 进程终止时，它保存的信息也随之丢失，但还是有些信息需要保存信息 经常需要多个进程同时访问同一信息或其中部分信息 把文件看成字节序列 Creator、Owner、Key length、Current size、Maximum size ? 两问 相对当前路径开始的路径 More convient","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"图像处理L1","slug":"图像处理L1","date":"2021-10-17T15:53:02.000Z","updated":"2023-04-26T11:19:54.757Z","comments":true,"path":"posts/55869/","link":"","permalink":"https://ye2222.github.io/posts/55869/","excerpt":"","text":"问题一至问题十 问题一：通道交换 读取图像，然后将\\(\\text{RGB}\\)通道替换成\\(\\text{BGR}\\)通道。 下面的代码用于提取图像的红色通道。 注意，cv2.imread() 的系数是按\\(\\text{BGR}\\)顺序排列的！ 其中的变量red表示的是仅有原图像红通道的https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg。 123456789101112131415161718# 1# cv2.imread() 的系数是按 BGR顺序排列的# 读取图片，第二个参数0是灰色，1是彩色img = cv2.imread(&quot;https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg&quot;)plt.axis(&#x27;off&#x27;)plt.imshow(img)plt.show()red = img[:, :, 2].copy()blue = img[:, :, 0].copy()img[:, :, 0] = redimg[:, :, 2] = blueplt.axis(&#x27;off&#x27;)plt.imshow(img)plt.show()print(img.shape) 输入（https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_1.jpg) 问题二：灰度化（Grayscale） 将图像灰度化吧！ 灰度是一种图像亮度的表示方法，通过下式计算： \\[ Y = 0.2126\\ R + 0.7152\\ G + 0.0722\\ B \\] 输入（https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_2.jpg) 12345678910111213141516171819# 灰度化img = cv2.imread(&quot;https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg&quot;)blue = np.array(img[:, :, 0].copy(), dtype=&#x27;float64&#x27;)blue *= 0.0722green = np.array(img[:, :, 1].copy(), dtype=&#x27;float64&#x27;)green *= 0.7152red = np.array(img[:, :, 2].copy(), dtype=&#x27;float64&#x27;)red *= 0.2126img[:, :, 0] = red+green+blueimg[:, :, 1] = red+green+blueimg[:, :, 2] = red+green+blueplt.axis(&#x27;off&#x27;)plt.imshow(img)plt.show() 问题三：二值化（Thresholding） 把图像进行二值化吧。 二值化是将图像使用黑和白两种颜色表示的方法。 我们将灰度的阈值设置为\\(128\\)来进行二值化，即： \\[ y= \\begin{cases} 0&amp; (\\text{if}\\quad y &lt; 128) \\\\ 255&amp; (\\text{else}) \\end{cases} \\] 输入（https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_3.jpg) 123456789101112131415# 3 二值化# 二值化是将图像使用黑和白两种颜色表示的方法。for i in range(len(img[:, :, 0])): for j in range(len(img[:, :, 0][1])): if img[:, :, 0][i][j] &lt; 128: img[:, :, 0][i][j] = 0 else: img[:, :, 0][i][j] = 255 img[:, :, 1] = img[:, :, 0]img[:, :, 2] = img[:, :, 0]plt.axis(&#x27;off&#x27;)plt.imshow(img)plt.show() 问题四：大津二值化算法（Otsu's Method） 使用大津算法来二值化图像吧。 大津算法，也被称作最大类间方差法，是一种可以自动确定二值化中阈值的算法。 从类内方差和类间方差的比值计算得来： 小于阈值\\(t\\)的类记作\\(0\\)，大于阈值\\(t\\)的类记作\\(1\\)； \\(w_0\\)和\\(w_1\\)是被阈值\\(t\\)分开的两个类中的像素数占总像素数的比率（满足\\(w_0+w_1=1\\)）； \\({S_0}^2\\)， \\({S_1}^2\\)是这两个类中像素值的方差； \\(M_0\\)，\\(M_1\\)是这两个类的像素值的平均值； 即： 类内方差：\\({S_w}^2=w_0\\ {S_0}^2+w_1\\ {S_1}^2\\) 类间方差：\\({S_b}^2 = w_0 \\ (M_0 - M_t)^2 + w_1\\ (M_1 - M_t)^2 = w_0\\ w_1\\ (M_0 - M_1) ^2\\) 图像所有像素的方差：\\({S_t}^2 = {S_w}^2 + {S_b}^2 = \\text{常数}\\) 根据以上的式子，我们用以下的式子计算分离度\\(X\\)：[^1] 也就是说： 换言之，如果使\\({S_b}^2={w_0}\\ {w_1}\\ (M_0 - M_1)^2\\)最大，就可以得到最好的二值化阈值\\(t\\)。 输入（https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg) 输出 (\\(\\text{th} = 127\\)) (https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_4.jpg) 问题五：\\(\\text{HSV}\\)变换 将使用\\(\\text{HSV}\\)表示色彩的图像的色相反转吧！ \\(\\text{HSV}\\)即使用色相（Hue）、饱和度（Saturation）、明度（Value）来表示色彩的一种方式。 色相：将颜色使用\\(0^{\\circ}\\)到\\(360^{\\circ}\\)表示，就是平常所说的颜色名称，如红色、蓝色。色相与数值按下表对应： 红 黄 绿 青色 蓝色 品红 红 \\(0^{\\circ}\\) \\(60^{\\circ}\\) \\(120^{\\circ}\\) \\(180^{\\circ}\\) \\(240^{\\circ}\\) \\(300^{\\circ}\\) \\(360^{\\circ}\\) 饱和度：是指色彩的纯度，饱和度越低则颜色越黯淡（\\(0\\leq S &lt; 1\\)）； 明度：即颜色的明暗程度。数值越高越接近白色，数值越低越接近黑色（\\(0\\leq V &lt; 1\\)）； 从\\(\\text{RGB}\\)色彩表示转换到\\(\\text{HSV}\\)色彩表示通过以下方式计算： \\(\\text{RGB}\\)的取值范围为\\([0, 1]\\)，令： \\[ \\text{Max}=\\max(R,G,B)\\\\ \\text{Min}=\\min(R,G,B) \\] 色相： \\[ H=\\begin{cases} 0&amp;(\\text{if}\\ \\text{Min}=\\text{Max})\\\\ 60\\ \\frac{G-R}{\\text{Max}-\\text{Min}}+60&amp;(\\text{if}\\ \\text{Min}=B)\\\\ 60\\ \\frac{B-G}{\\text{Max}-\\text{Min}}+180&amp;(\\text{if}\\ \\text{Min}=R)\\\\ 60\\ \\frac{R-B}{\\text{Max}-\\text{Min}}+300&amp;(\\text{if}\\ \\text{Min}=G) \\end{cases} \\] 饱和度： \\[ S=\\text{Max}-\\text{Min} \\] 明度： \\[ V=\\text{Max} \\] 从\\(\\text{HSV}\\)色彩表示转换到\\(\\text{RGB}\\)色彩表示通过以下方式计算： \\[ C = S\\\\ \\] \\[ H&#39; = \\frac{H}{60}\\\\ \\] \\[ X = C\\ (1 - |H&#39; \\mod 2 - 1|)\\\\ \\] \\[ (R,G,B)=(V-C)\\ (1,1,1)+\\begin{cases} (0, 0, 0)&amp; (\\text{if H is undefined})\\\\ (C, X, 0)&amp; (\\text{if}\\quad 0 \\leq H&#39; &lt; 1)\\\\ (X, C, 0)&amp; (\\text{if}\\quad 1 \\leq H&#39; &lt; 2)\\\\ (0, C, X)&amp; (\\text{if}\\quad 2 \\leq H&#39; &lt; 3)\\\\ (0, X, C)&amp; (\\text{if}\\quad 3 \\leq H&#39; &lt; 4)\\\\ (X, 0, C)&amp; (\\text{if}\\quad 4 \\leq H&#39; &lt; 5)\\\\ (C, 0, X)&amp; (\\text{if}\\quad 5 \\leq H&#39; &lt; 6) \\end{cases} \\] 请将色相反转（色相值加\\(180\\)），然后再用\\(\\text{RGB}\\)色彩空间表示图片。 输入（https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_5.jpg) 答案 Python &gt;&gt; answers_py/answer_5.py C++ &gt;&gt; answers_cpp/answer_5.cpp 问题六：减色处理1 我们将图像的值由\\(256^3\\)压缩至\\(4^3\\)，即将\\(\\text{RGB}\\)的值只取\\(\\{32, 96, 160, 224\\}\\)。这被称作色彩量化。色彩的值按照下面的方式定义： \\[ \\text{val}= \\begin{cases} 32&amp; (0 \\leq \\text{var} &lt; 64)\\\\ 96&amp; (64\\leq \\text{var}&lt;128)\\\\ 160&amp;(128\\leq \\text{var}&lt;192)\\\\ 224&amp;(192\\leq \\text{var}&lt;256) \\end{cases} \\] 输入（https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_6.jpg) 答案 Python &gt;&gt; answers_py/answer_6.py C++ &gt;&gt; answers_cpp/answer_6.cpp 问题七：平均池化（Average Pooling） 将图片按照固定大小网格分割，网格内的像素值取网格内所有像素的平均值。 我们将这种把图片使用均等大小网格分割，并求网格内代表值的操作称为池化（Pooling）。 池化操作是卷积神经网络（Convolutional Neural Network）中重要的图像处理方式。平均池化按照下式定义： \\[ v=\\frac{1}{|R|}\\ \\sum\\limits_{i=1}^R\\ v_i \\] 请把大小为\\(128\\times128\\)的https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg使用\\(8\\times8\\)的网格做平均池化。 输入（https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_7.jpg) 答案 Python &gt;&gt; answers_py/answer_7.py C++ &gt;&gt; answers_cpp/answer_7.cpp 问题八：最大池化（Max Pooling） 网格内的值不取平均值，而是取网格内的最大值进行池化操作。 输入（https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/imori.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_8.jpg) 答案 - Python &gt;&gt; answers_py/answer_8.py - C++ &gt;&gt; answers_cpp/answer_8.cpp 问题九：高斯滤波（Gaussian Filter） 使用高斯滤波器（\\(3\\times3\\)大小，标准差\\(\\sigma=1.3\\)）来对imori_noise.jpg进行降噪处理吧！ 高斯滤波器是一种可以使图像平滑的滤波器，用于去除噪声。可用于去除噪声的滤波器还有中值滤波器（参见问题十），平滑滤波器（参见问题十一）、LoG滤波器（参见问题十九）。 高斯滤波器将中心像素周围的像素按照高斯分布加权平均进行平滑化。这样的（二维）权值通常被称为卷积核（kernel）或者滤波器（filter）。 但是，由于图像的长宽可能不是滤波器大小的整数倍，因此我们需要在图像的边缘补\\(0\\)。这种方法称作Zero Padding。并且权值\\(g\\)（卷积核）要进行归一化操作（\\(\\sum\\ g = 1\\)）。 按下面的高斯分布公式计算权值： \\[ g(x,y,\\sigma)=\\frac{1}{2\\ \\pi\\ \\sigma^2}\\ e^{-\\frac{x^2+y^2}{2\\ \\sigma^2}} \\] 标准差\\(\\sigma=1.3\\)的\\(8-\\)近邻高斯滤波器如下： \\[ K=\\frac{1}{16}\\ \\left[ \\begin{matrix} 1 &amp; 2 &amp; 1 \\\\ 2 &amp; 4 &amp; 2 \\\\ 1 &amp; 2 &amp; 1 \\end{matrix} \\right] \\] 输入（imori_noise.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_9.jpg) 答案 Python &gt;&gt; answers_py/answer_9.py C++ &gt;&gt; answers_cpp/answer_9.cpp 问题十：中值滤波（Median Filter） 使用中值滤波器（\\(3\\times3\\)大小）来对imori_noise.jpg进行降噪处理吧！ 中值滤波器是一种可以使图像平滑的滤波器。这种滤波器用滤波器范围内（在这里是\\(3\\times3\\)）像素点的中值进行滤波，请在这里也采用Zero Padding。 输入（imori_noise.jpg) 输出(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/answer_10.jpg) 这里没有找到\"減色処理\"准确的中文翻译，所以直译了。↩︎","categories":[],"tags":[]},{"title":"FastSpeech","slug":"FastSpeech","date":"2021-10-17T09:51:57.000Z","updated":"2023-04-26T11:19:54.625Z","comments":true,"path":"posts/2654/","link":"","permalink":"https://ye2222.github.io/posts/2654/","excerpt":"","text":"基本结构：","categories":[{"name":"论文","slug":"论文","permalink":"https://ye2222.github.io/categories/%E8%AE%BA%E6%96%87/"},{"name":"语音","slug":"论文/语音","permalink":"https://ye2222.github.io/categories/%E8%AE%BA%E6%96%87/%E8%AF%AD%E9%9F%B3/"}],"tags":[]},{"title":"numpyL7","slug":"numpyL7","date":"2021-10-16T02:25:16.000Z","updated":"2023-04-26T11:19:54.695Z","comments":true,"path":"posts/26007/","link":"","permalink":"https://ye2222.github.io/posts/26007/","excerpt":"","text":"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"numpyL6","slug":"numpyL6","date":"2021-10-16T02:25:09.000Z","updated":"2023-04-26T11:19:54.693Z","comments":true,"path":"posts/42326/","link":"","permalink":"https://ye2222.github.io/posts/42326/","excerpt":"","text":"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"numpyL5","slug":"numpyL5","date":"2021-10-16T02:24:58.000Z","updated":"2023-04-26T11:19:54.692Z","comments":true,"path":"posts/42006/","link":"","permalink":"https://ye2222.github.io/posts/42006/","excerpt":"","text":"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"操作系统L12","slug":"操作系统L12","date":"2021-10-14T02:55:25.000Z","updated":"2023-04-26T11:19:54.762Z","comments":true,"path":"posts/40166/","link":"","permalink":"https://ye2222.github.io/posts/40166/","excerpt":"","text":"I/O设备的分类 Block device 块设备：信息存储在固定的块中 Character device 字符设备：传递或接受字符流，不考虑任何块结构 I/O设备的组成 机器部分 电子部分，即设备控制器(device controller) Device Controllers 设备控制器 设备控制器是计算机系统的一部分，它能够识别CPU的信号 每个设备控制器都有一个本地缓冲区和一些寄存器。 它通过中断与 CPU 通信。 设备的控制器充当设备和操作系统之间的桥梁 CPU与设备的控制寄存器和数据缓存区进行通信 三种方法： 每个控制寄存器被分配I/O端口号。 所有控制寄存器都映射到存储空间。这称为内存映射I/O(Memory-Mapped I/O) 将I/O数据缓冲区映射到内存空间中，但从内存中分离I/O端口 I/O的实现 Programmed I/O 程序控制I/O Programmed input/output (PIO) 一种在CPU和外围设备之间传输数据的方法。 CPU上运行的软件使用指令执行数据传输到I/O设备。 Interrupt-Driven I/O 使用中断驱动的I / O将字符串写入打印机 在打印系统调用时执行的代码 中断服务程序 中断是怎么发生的？ 设备与中断控制器之间的连接实际上在总线上使用中断线而不是专用电线 Interrupt Handlers 中断处理程序 中断处理程序最好隐藏，让驱动程序启动I/O操作块，直到中断通知完成 中断过程执行其任务，然后取消阻止启动它的驱动程序。 I/O Using DMA 使用 DMA 打印字符串 在进行打印系统调用时执行的代码 中断服务程序 Direct Memory Access (DMA) 直接存储器存取 I/O Software Layers I/O软件层次 Device Drivers 驱动器和设备控制器之间的通信通过总线进行； 设备驱动程序的逻辑位置如下图所示。 问题 45000 Check Points ① What are the two kinds of IO devices. ② What are the two components of IO devices. ③ What is programmed IO? ④ What is Interrupt-Driven IO? ⑤ What is IO using DMA? ⑥ What are the five layers of the IO software system ⑦ What are the difference between driver and interrupt handler?","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"numpyL4","slug":"numpyL4","date":"2021-10-13T02:24:47.000Z","updated":"2023-04-26T11:19:54.691Z","comments":true,"path":"posts/25815/","link":"","permalink":"https://ye2222.github.io/posts/25815/","excerpt":"","text":"方波： 锯齿波：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"Opengl1","slug":"Opengl1","date":"2021-10-13T01:39:20.000Z","updated":"2023-04-26T11:19:54.665Z","comments":true,"path":"posts/8120/","link":"","permalink":"https://ye2222.github.io/posts/8120/","excerpt":"","text":"网页：http://www.songho.ca/opengl/index.html","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"OpenGL","slug":"课程笔记/OpenGL","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/OpenGL/"}],"tags":[]},{"title":"vim","slug":"vim","date":"2021-10-11T11:31:51.000Z","updated":"2023-04-26T11:19:54.755Z","comments":true,"path":"posts/26382/","link":"","permalink":"https://ye2222.github.io/posts/26382/","excerpt":"","text":"普通模式 hjkl:左下上右 w：下一个单词 b：上一个单词 gg：回到当前所在位置对应的第一行 shift+g：回到当前位置对应的最后一行 cirl+u：上一页 cirl+d：下一页 y：复制 y可以和上下左右组合 y4l：复制右边4个字符 y4j：复制4行内容 yaw 复制整个单词 d：删除 和y同理 p：粘贴 u：撤销 输入模式 i：进入输入模式，按Esc退出 a：从当前光标之后进入输入模式 o：跳到下一行进入输入模式 shift+i：从这一行的开头进入输入模式 shift+a：从这一行的末尾进入输入模式 caw：删除这个单词进入 cc：删除这一行进入输入模式 c4j：删除下4行进入输入模式 命令模式 在普通模式按Esc进入 :q ：退出 :w：保存 :wq：保存并退出 可视模式 在普通模式下按v进入 移动光标就会选中一大段内容","categories":[{"name":"杂学","slug":"杂学","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/"},{"name":"vim","slug":"杂学/vim","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/vim/"}],"tags":[]},{"title":"numpyL3","slug":"numpyL3","date":"2021-10-11T08:14:31.000Z","updated":"2023-04-26T11:19:54.690Z","comments":true,"path":"posts/42646/","link":"","permalink":"https://ye2222.github.io/posts/42646/","excerpt":"","text":"用corrcoef函数计算了两只股票收益率的相关性 diagonal和trace函数分别可以给出矩阵的对角线元素和矩阵的迹 用polyfit函数拟合一系列数据点 用polyval函数计算多项式函数的取值 用roots函数求解多项式的根 polyder函数求解多项式函数的导函数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"numpyL2","slug":"numpyL2","date":"2021-10-09T10:59:35.000Z","updated":"2023-04-26T11:19:54.688Z","comments":true,"path":"posts/26199/","link":"","permalink":"https://ye2222.github.io/posts/26199/","excerpt":"","text":"总结： 用loadtxt读文件， 用savetxt写文件， 用eye函数创建单位矩阵， 用loadtxt函数从一个CSV文件中读取股价数据。 NumPy中的average和mean函数可以用来计算数据的加权平均数和算术平均数。 使用min和max函数来确定股价的范围 用median函数获取数据的中位数 用std和var函数计算数据的标准差和方差 diff函数可以返回数组中相邻元素的差值 log函数可以计算数组元素的自然对数 loadtxt函数默认将所有数据转换为浮点数类型，它有一个特定的参数可以完成转换。这个参数就是converters，它是一个可以将数据列和所谓的转换函数连接起来的参数。 ones函数可以创建一个全为1的数组 convolve函数可以根据指定的权重计算卷积。 linspace可以给出一个均匀分布的数组，然后我们计算出该数组元素的指数。 可以用sum方法对权重值做归一化处理 fill函数，这个函数可以用一个指定的标量值填充数组，而这个标量值也是其唯一的参数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"深度学习-12","slug":"深度学习-12","date":"2021-10-07T15:51:44.000Z","updated":"2023-04-26T11:19:54.809Z","comments":true,"path":"posts/13349/","link":"","permalink":"https://ye2222.github.io/posts/13349/","excerpt":"","text":"互相关运算 卷积层所表达的运算其实是互相关运算 (cross-correlation) 在卷积层中，输入张量和核张量通过互相关运算产生输出张量。 例子： 输入是高度为 3 、宽度为 3 的二维张量（即形状为 3×3 ） 卷积核的高度和宽度都是 2，而卷积核窗口（或卷积窗口）的形状由内核的高度和宽度决定（即 2×2 ） 注意： 输出大小略小于输入大小。 这是因为卷积核的宽度和高度大于1， 而卷积核只与图像中每个大小完全适合的位置进行互相关运算。 输出大小等于输入大小\\(n_h×n_w\\)减去卷积核大小\\(k_h×k_w\\)，即\\((n_h-k_h+1)×(n_w-k_w+1)\\) 需要足够的空间在图像上“移动”卷积核。 代码实现 12345678910111213import torchfrom torch import nnfrom d2l import torch as d2ldef corr2d(X, K): #@save &quot;&quot;&quot;计算二维互相关运算。&quot;&quot;&quot; h, w = K.shape Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): Y[i, j] = (X[i:i + h, j:j + w] * K).sum() return Y 卷积层 卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。 卷积层中的两个被训练的参数是卷积核权重和标量偏置。 在训练基于卷积层的模型时，我们也随机初始化卷积核权重。 代码实现 12345678class Conv2D(nn.Module): def __init__(self, kernel_size): super().__init__() self.weight = nn.Parameter(torch.rand(kernel_size)) self.bias = nn.Parameter(torch.zeros(1)) def forward(self, x): return corr2d(x, self.weight) + self.bias 将带有 h×w 卷积核的卷积层称为 h×w卷积层。 卷积层中的填充和步幅 这两个参数是超参数 填充通常会使得输入和输出高宽一致 通常步幅等于1，不选为1是因为计算量太大了，选2可以减半","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"计算机图形学L3","slug":"计算机图形学L3","date":"2021-10-05T15:12:05.000Z","updated":"2023-04-26T11:19:54.823Z","comments":true,"path":"posts/47994/","link":"","permalink":"https://ye2222.github.io/posts/47994/","excerpt":"","text":"齐次方程 用 (n+1)维度向量表示n维点 二维点 (x, y) 可用齐次坐标(X,Y,ω)表示, 其中 x = X/ω, y = Y/ω 一个空间点(x,y)有无穷多齐次坐标(X,Y,ω) 优点： 用矩阵运算统一表示各种几何变换 易于表示复合变换 支持非线性变换表示 (3D-perspective transformations) 可表示无穷远点(Infinity) 常用的几何变换 基本变换：平移、旋转、放缩 其它变换：剪切、对称、复合 所有变换都是针对一个点的变换来讨论，复杂场景由顶点定义 作用： 构建复杂几何场景 简单动画 图形绘制流水线 二维变换 刚性变换 形状不变但位置与朝向变化 点之间的距离不变; 线之间的夹角 旋转与平移都是刚性变换 刚性变换的复合变换仍然是刚性变换 仿射变换 三维变换 场景造型 场景坐标系，包括世界坐标系、局部坐标系 局部坐标系：建立单个物体模型，简化物体的定义 世界坐标系：从单个物体构造复杂场景、造型变换 变换：造型变换 图形流水线中的坐标系变换 世界坐标系到视点坐标系 变换：取景变换 投影(照相、摄影) 投影坐标系和窗口坐标系 变换：投影变换 二维显示 窗口坐标系、规格化设备坐标系与屏幕的物理坐标系 变换：设备变换、视窗变换 坐标变换流程图 坐标系 三维取景变换 图形流水线 几何变换流水线 坐标系设定方式 坐标系坐标轴方向计算 观察(取景)变换 投影变换 3D到2D 两种投影 透视投影 平行投影 裁剪--线段与多边形裁剪 需要裁剪的原因 剔除不可见部分 透视投影中视域四棱锥是指位于“前面”和“后面”之间的四棱台 平行投影的视域形状一般为长方体 投影时，要剔出位于视域体外部的物体部分 裁剪所在的流程 图像坐标系到设备变换的过程中 二维线段裁剪 二维多边形裁剪 三维裁剪 关于三维变换与裁剪","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"课程笔记/图形学","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[]},{"title":"深度学习-11","slug":"深度学习-11","date":"2021-10-05T10:28:09.000Z","updated":"2023-04-26T11:19:54.807Z","comments":true,"path":"posts/13669/","link":"","permalink":"https://ye2222.github.io/posts/13669/","excerpt":"","text":"不变性 卷积神经网络正是将空间不变性（spatial invariance）的这一概念系统化，从而基于这个模型使用较少的参数来学习有用的表示。 适合于计算机视觉的神经网络结构： 平移不变性（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”。 局部性（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，在后续神经网络，整个图像级别上可以集成这些局部特征用于预测。 限制多层感知机 多层感知机的输入：二维图像\\(X\\) 隐藏表示\\(H\\)是一个矩阵，代码中表示为二维张量，其中X和H具有相同的形状 可以认为，无论是输入还是隐藏表示都拥有空间结构 平移不变性 意味着检测对象在输入\\(X\\)中的平移，应该仅仅导致隐藏表示\\(H\\)中的平移 也就是说，\\(V\\)和\\(U\\)实际上不依赖于\\((i, j)\\)的值，即\\([V]_{i,j,a,b}=[V]_{a,b}\\) 并且U是一个常数，比如u，所以可以将H定义简化为 局部性 (6.1.3)是一个 卷积层 （convolutional layer），而卷积神经网络是包含卷积层的一类特殊的神经网络。 \\(V\\)被称为卷积核 （convolution kernel） 或者 滤波器 （filter），它仅仅是可学习的一个层的权重。 卷积神经网络和多层感知机的训练差异： 以前，多层感知机可能需要数十亿个参数来表示网络中的一层，而现在卷积神经网络通常只需要几百个参数，而且不需要改变输入或隐藏表示的维数。 参数大幅减少的代价是，我们的特征现在是平移不变的，并且当确定每个隐藏激活的值时，每一层只能包含局部的信息。 以上所有的权重学习都将依赖于归纳偏置 当这种偏置与现实相符时，我们就能得到样本有效的模型，并且这些模型能很好地泛化到未知数据中 如果这偏置与现实不符时，比如当图像不满足平移不变时，我们的模型可能难以拟合我们的训练数据 卷积 通道 图像不是二维张量，而是一个由高度、宽度和颜色组成的三维张量，比如包含1024×1024×3 个像素。 前两个轴与像素的空间位置有关，而第三个轴可以看作是每个像素的多维表示。 因此，我们将 XX索引为$ [X]_{i,j,k}$ 。由此卷积相应地调整为 \\([V]_{a,b,c}\\) ，而不是 \\([V]_{a,b}\\) 由于输入图像是三维的，我们的隐藏表示 H 也最好采用三维张量。 我们可以把隐藏表示想象为一系列具有二维张量的 通道 （channel）。 这些通道有时也被称为 特征映射 （feature maps），因为每个通道都向后续层提供一组空间化的学习特征。 直观上你可以想象在靠近输入的底层，一些通道专门识别边，而其他通道专门识别纹理。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"Go4","slug":"Go4","date":"2021-10-04T13:14:16.000Z","updated":"2023-04-26T11:19:54.646Z","comments":true,"path":"posts/12956/","link":"","permalink":"https://ye2222.github.io/posts/12956/","excerpt":"","text":"4.1. 数组 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。 Go语言中很少直接使用数组，因为数组的长度是固定的 和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活， 但是要理解slice工作原理的话需要先理解数组 创建数组和切片的直接区别：定义了长度 123var x []int // 切片x = append(x, 2)var y = [...]int&#123;1, 2, 3&#125; // 数组 数组 数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。 内置的len函数将返回数组中元素的个数。 12345678910111213var a [3]int // array of 3 integersfmt.Println(a[0]) // print the first elementfmt.Println(a[len(a)-1]) // print the last element, a[2]// Print the indices and elements.for i, v := range a &#123; fmt.Printf(&quot;%d %d\\n&quot;, i, v)&#125;// Print the elements only.for _, v := range a &#123; fmt.Printf(&quot;%d\\n&quot;, v)&#125; 数组的初始化 默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。 可以使用数组字面值语法用一组值来初始化数组 123var q [3]int = [3]int&#123;1, 2, 3&#125;var r [3]int = [3]int&#123;1, 2&#125;fmt.Println(r[2]) // &quot;0&quot; 在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算 12q := [...]int&#123;1, 2, 3&#125;fmt.Printf(&quot;%T\\n&quot;, q) // &quot;[3]int&quot; 可以指定一个索引和对应值列表的方式初始化 123456789101112type Currency intconst ( USD Currency = iota // 美元 EUR // 欧元 GBP // 英镑 RMB // 人民币)symbol := [...]string&#123;USD: &quot;$&quot;, EUR: &quot;€&quot;, GBP: &quot;￡&quot;, RMB: &quot;￥&quot;&#125;fmt.Println(RMB, symbol[RMB]) // &quot;3 ￥&quot; 未指定初始值的元素将用零值初始化 1r := [...]int&#123;99: -1&#125; 定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。 数组的长度 数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型 数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。 12q := [3]int&#123;1, 2, 3&#125;q = [4]int&#123;1, 2, 3, 4&#125; // compile error: cannot assign [4]int to [3]int 数组的比较 如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的 这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的 不相等比较运算符!=遵循同样的规则 123456a := [2]int&#123;1, 2&#125;b := [...]int&#123;1, 2&#125;c := [2]int&#123;1, 3&#125;fmt.Println(a == b, a == c, b == c) // &quot;true false false&quot;d := [3]int&#123;1, 2&#125;fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int 例子 crypto/sha256包的Sum256函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应[32]byte数组类型 123456789101112import &quot;crypto/sha256&quot;func main() &#123; c1 := sha256.Sum256([]byte(&quot;x&quot;)) c2 := sha256.Sum256([]byte(&quot;X&quot;)) fmt.Printf(&quot;%x\\n%x\\n%t\\n%T\\n&quot;, c1, c2, c1 == c2, c1) // Output: // 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881 // 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015 // false // [32]uint8&#125; 可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。 123456789func zero(ptr *[32]byte) &#123; for i := range ptr &#123; ptr[i] = 0 &#125;&#125;func zero(ptr *[32]byte) &#123; *ptr = [32]byte&#123;&#125;&#125; 4.2. Slice Slice（切片）代表变长的序列，序列中每个元素都有相同的类型 一个slice类型一般写作[]T，其中T代表slice中元素的类型； slice的语法和数组很像，只是没有固定长度而已 一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象 slice的构成 一个slice由三个部分构成：指针、长度和容量。 指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。 长度对应slice中元素的数目；长度不能超过容量， 容量一般是从slice的开始位置到底层数据的结尾位置。 内置的len和cap函数分别返回slice的长度和容量 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。 切片 slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。 新的slice将只有j-i个元素。 如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替 如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大 12345678910111213141516171819months := [...]string&#123;1: &quot;January&quot;, /* ... */, 12: &quot;December&quot;&#125;Q2 := months[4:7]summer := months[6:9]fmt.Println(Q2) // [&quot;April&quot; &quot;May&quot; &quot;June&quot;]fmt.Println(summer) // [&quot;June&quot; &quot;July&quot; &quot;August&quot;]for _, s := range summer &#123; for _, q := range Q2 &#123; if s == q &#123; fmt.Printf(&quot;%s appears in both\\n&quot;, s) &#125; &#125;&#125;fmt.Println(summer[:20]) // panic: out of rangeendlessSummer := summer[:5] // extend a slice (within capacity)fmt.Println(endlessSummer) // &quot;[June July August September October]&quot; 字符串和[]byte的切片 字符串的切片操作和[]byte字节类型切片的切片操作是类似的。 都写作x[m:n] 并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度 x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte 换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名 例子 reverse函数在原内存空间将[]int类型的slice反转，而且它可以用于任意长度的slice 12345678910// reverse reverses a slice of ints in place.func reverse(s []int) &#123; for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125;&#125;a := [...]int&#123;0, 1, 2, 3, 4, 5&#125;reverse(a[:])fmt.Println(a) // &quot;[5 4 3 2 1 0]&quot; 一种将slice元素循环向左旋转n个元素的方法是三次调用reverse反转函数，第一次是反转开头的n个元素，然后是反转剩下的元素，最后是反转整个slice的元素。（如果是向右循环旋转，则将第三个函数调用移到第一个调用位置就可以了。） 123456s := []int&#123;0, 1, 2, 3, 4, 5&#125;// Rotate s left by two positions.reverse(s[:2])reverse(s[2:])reverse(s)fmt.Println(s) // &quot;[2 3 4 5 0 1]&quot; 切片的初始化 slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素， 但是对于slice并没有指明序列的长度。 这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。 slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化 切片的比较 slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素 标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较 1234567891011func equal(x, y []string) bool &#123; if len(x) != len(y) &#123; return false &#125; for i := range x &#123; if x[i] ![] &#123; return false &#125; &#125; return true&#125; 为何slice不直接支持比较运算符呢 第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身，虽然有很多办法处理这种情形，但是没有一个是简单有效的。 当slice声明为[]interface{}时，slice的元素可以是自身 第二个原因，因为slice的元素是间接引用的，一个固定的slice值（注：指slice本身的值，不是元素的值）在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改 例如Go语言中map的key只做简单的浅拷贝，它要求key在整个生命周期内保持不变性 例如slice扩容，就会导致其本身的值/地址变化 而用深度相等判断的话，显然在map的key这种场合不合适。对于像指针或chan之类的引用类型，==相等测试可以判断两个是否是引用相同的对象 一个针对slice的浅相等测试的==操作符可能是有一定用处的，也能临时解决map类型的key问题 但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作 slice唯一合法的比较操作是和nil比较 1if summer == nil &#123; /* ... */ &#125; 一个零值的slice等于nil。 一个nil值的slice并没有底层数组。 一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。 与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。 1234var s []int // len(s) == 0, s == nils = nil // len(s) == 0, s == nils = []int(nil) // len(s) == 0, s == nils = []int&#123;&#125; // len(s) == 0, s != nil 如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。 除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样 除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。 make函数创建slice 内置的make函数创建一个指定元素类型、长度和容量的slice 容量部分可以省略，在这种情况下，容量将等于长度。 12make([]T, len)make([]T, len, cap) // same as make([]T, cap)[:len] 在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。 在第一种语句中，slice是整个数组的view。 在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。 slice的索引 12345678910111213141516171819202122//demo_8.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; sli := [] int &#123;1, 2, 3, 4, 5, 6&#125; fmt.Println(&quot;sli[0:3] ==&quot;, sli[0:3]) fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(sli[0:3]),cap(sli[0:3]),sli[0:3]) fmt.Println(&quot;sli[0:3:4] ==&quot;, sli[0:3:4]) fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(sli[0:3:4]),cap(sli[0:3:4]),sli[0:3:4])&#125;// sli[0:3] == [1 2 3]// len=3 cap=6 slice=[1 2 3]// sli[0:3:5] == [1 2 3]// len=3 cap=4 slice=[1 2 3] 上述切片方式中 第一种：s[i:j]：从i截取到j 第二种：s[i:j:k]：从i截取到j，容量为k 4.2.1. append函数 内置的append函数用于向slice追加元素 12345var runes []runefor _, r := range &quot;Hello, 世界&quot; &#123; runes = append(runes, r)&#125;fmt.Printf(&quot;%q\\n&quot;, runes) // &quot;[&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;,&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27;]&quot; 对应这个特殊的问题我们可以通过Go语言内置的[]rune(\"Hello, 世界\")转换操作完成。 append函数对于理解slice底层是如何工作的非常重要，所以让我们仔细查看究竟是发生了什么 实现appendInt函数 专门用于处理[]int类型的slice 12345678910111213141516171819func appendInt(x []int, y int) []int &#123; var z []int zlen := len(x) + 1 if zlen &lt;= cap(x) &#123; // There is room to grow. Extend the slice. z = x[:zlen] &#125; else &#123; // There is insufficient space. Allocate a new array. // Grow by doubling, for amortized linear complexity. zcap := zlen if zcap &lt; 2*len(x) &#123; zcap = 2 * len(x) &#125; z = make([]int, zlen, zcap) copy(z, x) // a built-in function; see text &#125; z[len(x)] = y return z&#125; 每次调用appendInt函数，必须先检测slice底层数组是否有足够的容量来保存新添加的元素。 如果有足够空间的话，直接扩展slice（依然在原有的底层数组之上），将新添加的y元素复制到新扩展的空间，并返回slice。因此，输入的x和输出的z共享相同的底层数组。（line 4~6） 如果没有足够的增长空间的话，appendInt函数则会先分配一个足够大的slice用于保存新的结果，先将输入的x复制到新的空间，然后添加y元素。结果z和输入的x引用的将是不同的底层数组。（line10~15） 内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。 copy函数的第一个参数是要复制的目标slice 第二个参数是源slice 目标和源的位置顺序和dst = src赋值语句是一致的。 两个slice可以共享同一个底层数组，甚至有重叠也没有问题。 copy函数将返回成功复制的元素的个数（我们这里没有用到），等于两个slice中较小的长度，所以我们不用担心覆盖会超出目标slice的范围。 为了提高内存使用效率，新分配的数组一般略大于保存x和y所需要的最低大小。 通过在每次扩展数组时直接将长度翻倍从而避免了多次内存分配，也确保了添加单个元素操的平均时间是一个常数时间 通常是将append返回的结果直接赋值给输入的slice变量的原因 内置的append函数可能使用比appendInt更复杂的内存扩展策略。 因此，通常我们并不知道append调用是否导致了内存的重新分配 因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。 同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。 1runes = append(runes, r) 要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。 要更新这些信息需要像上面例子那样一个显式的赋值操作。 从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型： 1234type IntSlice struct &#123; ptr *int len, cap int&#125; 改进appendint函数--追加多个数 1234567func appendInt(x []int, y ...int) []int &#123; var z []int zlen := len(x) + len(y) // ...expand z to at least zlen... copy(z[len(x):], y) return z&#125; 4.2.2. Slice内存技巧 下面的nonempty函数将在原有slice内存空间之上返回不包含空字符串的列表 1234567891011121314151617// Nonempty is an example of an in-place slice algorithm.package mainimport &quot;fmt&quot;// nonempty returns a slice holding only the non-empty strings.// The underlying array is modified during the call.func nonempty(strings []string) []string &#123; i := 0 for _, s := range strings &#123; if s != &quot;&quot; &#123; strings[i] = s i++ &#125; &#125; return strings[:i]&#125; 比较微妙的地方是，输入的slice和输出的slice共享一个底层数组。 这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样： 123data := []string&#123;&quot;one&quot;, &quot;&quot;, &quot;three&quot;&#125;fmt.Printf(&quot;%q\\n&quot;, nonempty(data)) // `[&quot;one&quot; &quot;three&quot;]`fmt.Printf(&quot;%q\\n&quot;, data) // `[&quot;one&quot; &quot;three&quot; &quot;three&quot;]` nonempty函数也可以使用append函数实现 123456789func nonempty2(strings []string) []string &#123; out := strings[:0] // zero-length slice of original for _, s := range strings &#123; if s != &quot;&quot; &#123; out = append(out, s) &#125; &#125; return out&#125; 无论如何实现，以这种方式重用一个slice一般都要求最多为每个输入值产生一个输出值，事实上很多这类算法都是用来过滤或合并序列中相邻的元素。 这种slice用法是比较复杂的技巧，虽然使用到了slice的一些技巧，但是对于某些场合是比较清晰和有效的。 用slice模拟stack 一个slice可以用来模拟一个stack。 最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack 1stack = append(stack, v) // push v stack的顶部位置对应slice的最后一个元素： 1top := stack[len(stack)-1] // top of stack 通过收缩stack可以弹出栈顶的元素 1stack = stack[:len(stack)-1] // pop 删除slice中的元素 要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成： 123456789func remove(slice []int, i int) []int &#123; copy(slice[i:], slice[i+1:]) return slice[:len(slice)-1]&#125;func main() &#123; s := []int&#123;5, 6, 7, 8, 9&#125; fmt.Println(remove(s, 2)) // &quot;[5 6 8 9]&quot;&#125; 如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素： 123456789func remove(slice []int, i int) []int &#123; slice[i] = slice[len(slice)-1] return slice[:len(slice)-1]&#125;func main() &#123; s := []int&#123;5, 6, 7, 8, 9&#125; fmt.Println(remove(s, 2)) // &quot;[5 6 9 8]&#125; 练习 练习 4.3： 重写reverse函数，使用数组指针代替slice。 练习 4.4： 编写一个rotate函数，通过一次循环完成旋转。 练习 4.5： 写一个函数在原地完成消除[]string中相邻重复的字符串的操作。 练习 4.6： 编写一个函数，原地将一个UTF-8编码的[]byte类型的slice中相邻的空格（参考unicode.IsSpace）替换成一个空格返回 练习 4.7： 修改reverse函数用于原地反转UTF-8编码的[]byte。是否可以不用分配额外的内存？ 4.3. Map 哈希表是一种巧妙并且实用的数据结构。 它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。 在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型 key必须是支持==比较运算符的数据类型、 创建一个Map 使用make函数 1ages := make(map[string]int) // mapping from strings to ints 使用map字面量，可指定一些最初的key/value 123456789ages := map[string]int&#123; &quot;alice&quot;: 31, &quot;charlie&quot;: 34,&#125;// 等价于ages := make(map[string]int)ages[&quot;alice&quot;] = 31ages[&quot;charlie&quot;] = 34 另外一种创建方法 1map[string]int&#123;&#125; Map元素 访问 12ages[&quot;alice&quot;] = 32fmt.Println(ages[&quot;alice&quot;]) // &quot;32&quot; 删除 12ages[&quot;alice&quot;] = 32fmt.Println(ages[&quot;alice&quot;]) // &quot;32&quot; 所有这些操作是安全的，即使这些元素不在map中也没有关系 如果一个查找失败将返回value类型对应的零值 x += y和x++等简短赋值语法也可以用在map上 map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作 1_ = &amp;ages[&quot;bob&quot;] // compile error: cannot take address of map element 遍历map中所有元素 可以使用range风格的for循环（无序） 123for name, age := range ages &#123; fmt.Printf(&quot;%s\\t%d\\n&quot;, name, age)&#125; Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。 在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Go","slug":"编程语言/Go","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://ye2222.github.io/tags/Go/"}]},{"title":"Go依赖管理","slug":"Go依赖管理","date":"2021-10-04T13:14:16.000Z","updated":"2023-04-26T11:19:54.681Z","comments":true,"path":"posts/21575/","link":"","permalink":"https://ye2222.github.io/posts/21575/","excerpt":"","text":"","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://ye2222.github.io/tags/Go/"}]},{"title":"Go3","slug":"Go3","date":"2021-10-04T13:13:16.000Z","updated":"2023-04-26T11:19:54.627Z","comments":true,"path":"posts/61661/","link":"","permalink":"https://ye2222.github.io/posts/61661/","excerpt":"第三章讲解了整数、浮点数、复数、布尔类型、字符串以及常量","text":"第三章讲解了整数、浮点数、复数、布尔类型、字符串以及常量 3.1 整型 有符号整数类型 int int8 int16 int32 int64 32bits/64bits 8bits 16bits 32bits 64bits 无符号整数类型 uint uint8 uint16 uint32 uint64 32bits/64bits 8bits 16bits 32bits 64bits 其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然 Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。 这两个名称可以互换使用。 byte是uint8类型的等价类型 byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。 无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针 uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。 不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。 二进制表示 有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位 一个n-bit的有符号数的值域是从\\(-2^{n-1}\\)到\\(2^{n-1}-1\\) 无符号整数的所有bit位都用于表示非负数 值域是0到\\(2^n-1\\) 例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255。 算术运算、逻辑运算和比较运算的二元运算符 按照优先级递减的顺序排列 二元运算符有五种优先级。 在同一个优先级，使用左优先结合规则 但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级 取模号和除号的特殊处 在Go语言中，%取模运算符的符号和被取模数的符号总是一致的 因此-5%3和-5%-3结果都是-2。 除法运算符/的行为则依赖于操作数是否全为整数 比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。 比较表达式 比较表达式的结果是布尔类型。 123456== 等于!= 不等于&lt; 小于&lt;= 小于等于&gt; 大于&gt;= 大于等于 bit位操作运算符 前面4个操作运算符并不区分是有符号还是无符号数 123456&amp; 位运算 AND| 位运算 OR^ 位运算 XOR&amp;^ 位清空（AND NOT）&lt;&lt; 左移&gt;&gt; 右移 位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反，也就是返回一个每个bit位都取反的数 位操作运算符&amp;^用于按位置零（AND NOT） 如果对应y中bit位为1的话，表达式z = x &amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。 12345678910111213141516171819var x uint8 = 1&lt;&lt;1 | 1&lt;&lt;5var y uint8 = 1&lt;&lt;1 | 1&lt;&lt;2fmt.Printf(&quot;%08b\\n&quot;, x) // &quot;00100010&quot;, the set &#123;1, 5&#125;fmt.Printf(&quot;%08b\\n&quot;, y) // &quot;00000110&quot;, the set &#123;1, 2&#125;fmt.Printf(&quot;%08b\\n&quot;, x&amp;y) // &quot;00000010&quot;, the intersection &#123;1&#125;fmt.Printf(&quot;%08b\\n&quot;, x|y) // &quot;00100110&quot;, the union &#123;1, 2, 5&#125;fmt.Printf(&quot;%08b\\n&quot;, x^y) // &quot;00100100&quot;, the symmetric difference &#123;2, 5&#125;fmt.Printf(&quot;%08b\\n&quot;, x&amp;^y) // &quot;00100000&quot;, the difference &#123;5&#125;for i := uint(0); i &lt; 8; i++ &#123; if x&amp;(1&lt;&lt;i) != 0 &#123; // membership test fmt.Println(i) // &quot;1&quot;, &quot;5&quot; &#125;&#125;fmt.Printf(&quot;%08b\\n&quot;, x&lt;&lt;1) // &quot;01000100&quot;, the set &#123;2, 6&#125;fmt.Printf(&quot;%08b\\n&quot;, x&gt;&gt;1) // &quot;00010001&quot;, the set &#123;0, 4&#125; 在x&lt;&lt;n和x&gt;&gt;n移位运算中，决定了移位操作的bit数部分必须是无符号数；被操作的x可以是有符号数或无符号数 算术上，一个x&lt;&lt;n左移运算等价于乘以\\(2^n\\)，一个x&gt;&gt;n右移运算等价于除以\\(2^n\\)。 左移运算用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位， 但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。 因为这个原因，最好用无符号运算，这样你可以将整数完全当作一个bit位模式处理。 类型转换操作 123var apples int32 = 1var oranges int16 = 2var compote int = apples + oranges // compile error 当尝试编译这三个语句时，将产生一个错误信息： 1invalid operation: apples + oranges (mismatched types int32 and int16) 常见方法 1var compote = int(apples) + int(oranges) 如果转换允许的话，类型转换操作T(x)将x转换为T类型。 许多整数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值。 但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度 八进制或十六进制 任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666； 或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef 十六进制数字可以用大写或小写字母。 如今八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式。 123456o := 0666fmt.Printf(&quot;%d %[1]o %#[1]o\\n&quot;, o) // &quot;438 666 0666&quot;x := int64(0xdeadbeef)fmt.Printf(&quot;%d %[1]x %#[1]x %#[1]X\\n&quot;, x)// Output:// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF fmt的两个使用技巧 通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数 第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。 字符使用%c参数打印，或者是用%q参数打印带单引号的字符 123456ascii := &#x27;a&#x27;unicode := &#x27;国&#x27;newline := &#x27;\\n&#x27;fmt.Printf(&quot;%d %[1]c %[1]q\\n&quot;, ascii) // &quot;97 a &#x27;a&#x27;&quot;fmt.Printf(&quot;%d %[1]c %[1]q\\n&quot;, unicode) // &quot;22269 国 &#x27;国&#x27;&quot;fmt.Printf(&quot;%d %[1]q\\n&quot;, newline) // &quot;10 &#x27;\\n&#x27;&quot; 3.2. 浮点数 Go语言提供了两种精度的浮点数 float32和float64 浮点数的极值 浮点数的范围极限值可以在math包找到 常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38 对应的math.MaxFloat64常量大约是1.8e308。 它们分别能表示的最小值近似为1.4e-45和4.9e-324。 浮点数的精度 一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度 通常应该优先使用float64类型 因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大 因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差 12var f float32 = 16777216 // 1 &lt;&lt; 24fmt.Println(f == f+1) // &quot;true&quot;! 小数 浮点数的字面值可以直接写小数部分 1const e = 2.71828 // (approximately) 小数点前面或后面的数字都可能被省略（例如.707或1.） 很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分 12const Avogadro = 6.02214129e23 // 阿伏伽德罗常数const Planck = 6.62606957e-34 // 普朗克常数 打印 用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度 对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适 123for x := 0; x &lt; 8; x++ &#123; fmt.Printf(&quot;x = %d e^x = %8.3f\\n&quot;, x, math.Exp(float64(x)))&#125; 12345678x = 0 e^x = 1.000x = 1 e^x = 2.718x = 2 e^x = 7.389x = 3 e^x = 20.086x = 4 e^x = 54.598x = 5 e^x = 148.413x = 6 e^x = 403.429x = 7 e^x = 1096.633 正无穷大和负无穷大 正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果； 还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1). 函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。 虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的 在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示 12nan := math.NaN()fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) // &quot;false false false&quot; 如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败 1234567func compute() (value float64, ok bool) &#123; // ... if failed &#123; return 0, false &#125; return result, true&#125; 3.3. 复数 Go语言提供了两种精度的复数类型： complex64和complex128 分别对应float32和float64两种浮点数精度 构建复数 内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部 12345var x complex128 = complex(1, 2) // 1+2ivar y complex128 = complex(3, 4) // 3+4ifmt.Println(x*y) // &quot;(-5+10i)&quot;fmt.Println(real(x*y)) // &quot;-5&quot;fmt.Println(imag(x*y)) // &quot;10&quot; 如果一个浮点数面值或一个十进制整数面值后面跟着一个i，它将构成一个复数的虚部，复数的实部是0 例如3.141592i或2i 1fmt.Println(1i * 1i) // &quot;(-1+0i)&quot;, i^2 = -1 x和y的声明语句还可以简化（用自然方法书写） 12x := 1 + 2iy := 3 + 4i 复数的比较 复数也可以用==和!=进行相等比较。 只有两个复数的实部和虚部都相等的时候它们才是相等的 复数的处理方法 math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。 1fmt.Println(cmplx.Sqrt(-1)) // &quot;(0+1i)&quot; 3.4. 布尔型 一个布尔类型的值只有两种：true和false。 if和for语句的条件部分都是布尔类型的值，并且==和&lt;等比较操作也会产生布尔型的值。 一元操作符!对应逻辑非操作，因此!true的值为false 和、或 布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合 并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值 1s ![] == &#x27;x&#x27; &amp;&amp;的优先级比||高 布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换 1234i := 0if b &#123; i = 1&#125; 包装成一个函数 1234567// btoi returns 1 if b is true and 0 if false.func btoi(b bool) int &#123; if b &#123; return 1 &#125; return 0&#125; 数字到布尔型的逆转换 12// itob reports whether i is non-zero.func itob(i int) bool &#123; return i != 0 &#125; 3.5. 字符串 一个字符串是一个不可改变的字节序列。 字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。 文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列 字符串长度和索引 内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目） 索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i&lt; len(s)条件约束。 123s := &quot;hello, world&quot;fmt.Println(len(s)) // &quot;12&quot;fmt.Println(s[0], s[7]) // &quot;104 119&quot; (&#x27;h&#x27; and &#x27;w&#x27;) 试图访问超出字符串索引范围的字节将会导致panic异常 1c := s[len(s)] // panic: index out of range 字节和字符 第i个字节并不一定是字符串的第i个字符 因为对于非ASCII字符的UTF8编码会要两个或多个字节 子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串 生成的新字符串将包含j-i个字节 1fmt.Println(s[0:5]) // &quot;hello&quot; 索引起始和终结 不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。 123fmt.Println(s[:5]) // &quot;hello&quot;fmt.Println(s[7:]) // &quot;world&quot;fmt.Println(s[:]) // &quot;hello, world&quot; 拼接、比较字符串 +操作符将两个字符串连接构造一个新字符串 1fmt.Println(&quot;goodbye&quot; + s[5:]) // &quot;goodbye, world&quot; 字符串可以用==和&lt;进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。 字符串的不变形 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值 123s := &quot;left foot&quot;t := ss += &quot;, right foot&quot; 这并不会导致原始的字符串值被改变，但是变量s将因为+=语句持有一个新的字符串值，但是t依然是包含原先的字符串值。 12fmt.Println(s) // &quot;left foot, right foot&quot;fmt.Println(t) // &quot;left foot&quot; 因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的 1s[0] = &#x27;L&#x27; // compile error: cannot assign to s[0] 不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。 3.5.1. 字符串面值 字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可 因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。 转义字符 在一个双引号包含的字符串面值中，可以用以反斜杠\\开头的转义序列插入任意的数据。 12345678910\\a 响铃\\b 退格\\f 换页\\n 换行\\r 回车\\t 制表符\\v 垂直制表符\\&#x27; 单引号（只用在 &#x27;\\&#x27;&#x27; 形式的rune符号面值中）\\&quot; 双引号（只用在 &quot;...&quot; 形式的字符串面值中）\\\\ 反斜杠 通过十六进制或八进制转义在字符串面值中包含任意的字节。 一个十六进制的转义形式是\\xhh，其中两个h表示十六进制数字（大写或小写都可以）。 一个八进制转义形式是\\ooo，包含三个八进制的o数字（0到7），但是不能超过\\377 对应一个字节的范围，十进制为255 每一个单一的字节表达一个特定的值。 原生的字符串 一个原生的字符串面值形式是，使用反引号代替双引号。 在原生的字符串面值中，没有转义操作 全部的内容都是字面的意思，包含退格和换行,因此一个程序中的原生字符串面值可能跨越多行 在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+\"`\"连接字符串常量完成 唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统 Windows系统会把回车和换行一起放入文本文件中 原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠 原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。 12345const GoUsage = `Go is a tool for managing Go source code.Usage: go command [arguments]...` 3.5.2. Unicode ASCII字符集：美国信息交换标准代码。 ASCII，更准确地说是美国的ASCII 使用7bit来表示128个字符：包含英文字母的大小写、数字、各种标点符号和设备控制符。 Unicode 收集了这个世界上所有的符号系统， 包括重音符号和其它变音符号，制表符和回车符 还有很多神秘的符号 每个符号都分配一个唯一的Unicode码点 Unicode码点对应Go语言中的rune整数类型（rune是int32等价类型） 通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型 将一个符文序列表示为一个int32序列。 这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样大小的32bit来表示 这种方式比较简单统一，但是它会浪费很多存储空间 因为大多数计算机可读的文本是ASCII字符，本来每个ASCII字符只需要8bit或1字节就能表示 而且即使是常用的字符也远少于65,536个，也就是说用16bit编码方式就能表达常用字符。 3.5.3. UTF-8 UTF8是一个将Unicode码点编码为字节序列的变长编码。 UTF8编码使用1到4个字节来表示每个Unicode码点 ASCII部分字符只使用1个字节 常用字符部分使用2或3个字节表示。 每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节。 如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容 如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。 更大的Unicode码点也是采用类似的策略处理。 12340xxxxxxx runes 0-127 (ASCII)110xxxxx 10xxxxxx 128-2047 (values &lt;128 unused)1110xxxx 10xxxxxx 10xxxxxx 2048-65535 (values &lt;2048 unused)11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536-0x10ffff (other values unused) 优点 变长的编码无法直接通过索引来访问第n个字符，但是UTF8编码获得了很多额外的优点。 UTF8编码比较紧凑，完全兼容ASCII码，并且可以自动同步 可以通过向前回朔最多3个字节就能确定当前字符编码的开始字节的位置 也是一个前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看 像GBK之类的编码，如果不知道起点位置则可能会出现歧义 没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串 搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰 UTF8编码的顺序和Unicode码点的顺序一致 可以直接排序UTF8编码序列 没有嵌入的NUL(0)字节 很好地兼容那些使用NUL作为字符串结尾的编程语言。 Go语言中的UTF8 Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色 unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等） unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能 有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符 Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式 \\uhhhh对应16bit的码点值 \\Uhhhhhhhh对应32bit的码点值 其中h是一个十六进制数字 一般很少需要使用32bit的形式。 每一个对应码点的UTF8编码。 1234&quot;世界&quot;&quot;\\xe4\\xb8\\x96\\xe7\\x95\\x8c&quot;&quot;\\u4e16\\u754c&quot;&quot;\\U00004e16\\U0000754c&quot; 上面三个转义序列都为第一个字符串提供替代写法，但是它们的值都是相同的。 Unicode转义也可以使用在rune字符中。下面三个字符是等价的： 1&#x27;世&#x27; &#x27;\\u4e16&#x27; &#x27;\\U00004e16&#x27; 对于小于256的码点值可以写在一个十六进制转义字节中 例如\\x41对应字符'A' 但是对于更大的码点则必须使用\\u或\\U转义形式 因此，\\xe4\\xb8\\x96并不是一个合法的rune字符，虽然这三个字节对应一个有效的UTF8编码的码点 得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作 例子：查看字节数 字符串包含13个字节，以UTF8形式编码，但是只对应9个Unicode字符 12345import &quot;unicode/utf8&quot;s := &quot;Hello, 世界&quot;fmt.Println(len(s)) // &quot;13&quot;fmt.Println(utf8.RuneCountInString(s)) // &quot;9&quot; 为了处理这些真实的字符，我们需要一个UTF8解码器。unicode/utf8包提供了该功能，我们可以这样使用： 1234567891011121314for i := 0; i &lt; len(s); &#123; r, size := utf8.DecodeRuneInString(s[i:]) i += size fmt.Printf(&quot;%d\\t%c\\n&quot;, i, r)&#125;1 H2 e3 l4 l5 o6 ,7 10 世13 界 每一次调用DecodeRuneInString函数都返回一个r和长度，r对应字符本身，长度对应r采用UTF8编码后的编码字节数目。 长度可以用于更新第i个字符在字符串中的字节索引位置。 简洁写法 12345678910111213for i, r := range &quot;Hello, 世界&quot; &#123; fmt.Printf(&quot;%d\\t%q\\t%d\\n&quot;, i, r, r)&#125;0 &#x27;H&#x27; 721 &#x27;e&#x27; 1012 &#x27;l&#x27; 1083 &#x27;l&#x27; 1084 &#x27;o&#x27; 1115 &#x27;,&#x27; 446 &#x27; &#x27; 327 &#x27;世&#x27; 1999010 &#x27;界&#x27; 30028 统计字符数 1234567n := 0for _, _ = range s &#123; n++&#125;for range s &#123; n++&#125; 每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码， 如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符\\uFFFD 在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号\"?\"。 当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串 UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。 将[]rune类型转换应用到UTF8编码的字符串，将返回字符串编码的Unicode码点序列 12345// &quot;program&quot; in Japanese katakanas := &quot;プログラム&quot;fmt.Printf(&quot;% x\\n&quot;, s) // &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot;r := []rune(s)fmt.Printf(&quot;%x\\n&quot;, r) // &quot;[30d7 30ed 30b0 30e9 30e0]&quot; 在第一个Printf中的% x参数用于在每个十六进制数字前插入一个空格。 如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码： 1fmt.Println(string(r)) // &quot;プログラム&quot; 将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串 12fmt.Println(string(65)) // &quot;A&quot;, not &quot;65&quot;fmt.Println(string(0x4eac)) // &quot;京&quot; 如果对应码点的字符是无效的，则用\\uFFFD无效字符作为替换 1fmt.Println(string(1234567)) // &quot;?&quot; 3.5.4. 字符串和Byte切片 标准库中有四个包对字符串处理尤为重要 bytes strings strconv unicode 4个包的功能 strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。 ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。 bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型 因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制 这种情况下，使用bytes.Buffer类型将会更有效 strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。 unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类 每个函数有一个单一的rune类型的参数，然后返回一个布尔值。 像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。 所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。 实现basename basename(s)将看起来像是系统路径的前缀删除，同时将看似文件类型的后缀名部分删除 123fmt.Println(basename(&quot;a/b/c.go&quot;)) // &quot;c&quot;fmt.Println(basename(&quot;c.d.go&quot;)) // &quot;c.d&quot;fmt.Println(basename(&quot;abc&quot;)) // &quot;abc&quot; 手工实现 123456789101112131415161718// e.g., a =&gt; a, a.go =&gt; a, a/b/c.go =&gt; c, a/b.c.go =&gt; b.cfunc basename(s string) string &#123; // Discard last &#x27;/&#x27; and everything before. for i := len(s) - 1; i &gt;= 0; i-- &#123; if s[i] == &#x27;/&#x27; &#123; s = s[i+1:] break &#125; &#125; // Preserve everything before last &#x27;.&#x27;. for i := len(s) - 1; i &gt;= 0; i-- &#123; if s[i] == &#x27;.&#x27; &#123; s = s[:i] break &#125; &#125; return s&#125; 使用strings.LastIndex库函数 12345678func basename(s string) string &#123; slash := strings.LastIndex(s, &quot;/&quot;) // -1 if &quot;/&quot; not found s = s[slash+1:] if dot := strings.LastIndex(s, &quot;.&quot;); dot &gt;= 0 &#123; s = s[:dot] &#125; return s&#125; 实现数字分隔 函数的功能是将一个表示整数值的字符串，每隔三个字符插入一个逗号分隔符，例如“12345”处理后成为“12,345”。 12345678// comma inserts commas in a non-negative decimal integer string.func comma(s string) string &#123; n := len(s) if n &lt;= 3 &#123; return s &#125; return comma(s[:n-3]) + &quot;,&quot; + s[n-3:]&#125; 输入comma函数的参数是一个字符串。如果输入字符串的长度小于或等于3的话，则不需要插入逗号分隔符。 否则，comma函数将在最后三个字符前的位置将字符串切割为两个子串并插入逗号分隔符，然后通过递归调用自身来得出前面的子串。 字符串和字节slice 一个字符串是包含只读字节的数组，一旦创建，是不可变的。 相比之下，一个字节slice的元素则可以自由地修改。 字符串和字节slice之间可以相互转换 123s := &quot;abc&quot;b := []byte(s)s2 := string(b) 从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组 编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变 将一个字节slice转换到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的。 为了避免转换中不必要的内存分配，bytes包和strings同时提供了许多实用函数 123456789101112131415// strings包func Contains(s, substr string) boolfunc Count(s, sep string) intfunc Fields(s string) []stringfunc HasPrefix(s, prefix string) boolfunc Index(s, sep string) intfunc Join(a []string, sep string) string// bytes包func Contains(b, subslice []byte) boolfunc Count(s, sep []byte) intfunc Fields(s []byte) [][]bytefunc HasPrefix(s, prefix []byte) boolfunc Index(s, sep []byte) intfunc Join(s [][]byte, sep []byte) []byte bytes包还提供了Buffer类型用于字节slice的缓存 一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长 一个bytes.Buffer变量并不需要初始化，因为零值也是有效的： 1234567891011121314151617// intsToString is like fmt.Sprint(values) but adds commas.func intsToString(values []int) string &#123; var buf bytes.Buffer buf.WriteByte(&#x27;[&#x27;) for i, v := range values &#123; if i &gt; 0 &#123; buf.WriteString(&quot;, &quot;) &#125; fmt.Fprintf(&amp;buf, &quot;%d&quot;, v) &#125; buf.WriteByte(&#x27;]&#x27;) return buf.String()&#125;func main() &#123; fmt.Println(intsToString([]int&#123;1, 2, 3&#125;)) // &quot;[1, 2, 3]&quot;&#125; 当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似'['和']'等ASCII字符则会更加有效。 练习 3.10： 编写一个非递归版本的comma函数，使用bytes.Buffer代替字符串链接操作。 12345678910111213141516171819202122232425func comma(s string) string &#123; if len(s) &lt;= 3 &#123; fmt.Println(s) return s &#125; var res bytes.Buffer var n uint8 = 0 for i := len(s) - 1; i &gt;= 0; i-- &#123; res.WriteByte(s[i]) n++ if n == 3 &amp;&amp; i != 0&#123; res.WriteString(&quot;,&quot;) n = 0 &#125; &#125; r := res.String() var ans bytes.Buffer for i := len(r) - 1; i &gt;= 0; i-- &#123; ans.WriteByte(r[i]) &#125; fmt.Println(ans.String()) return ans.String()&#125; 练习 3.11： 完善comma函数，以支持浮点数处理和一个可选的正负号的处理。 123456789101112131415161718192021// comma inserts commas in a non-negative decimal integer string.func comma(s string) string &#123; var flag bool if s[0] == &#x27;+&#x27; || s[0] == &#x27;-&#x27; &#123; flag = true &#125; n := len(s) for i := 0; i &lt; n; i++ &#123; if s[i] == &#x27;.&#x27; &amp;&amp; flag &#123; return string(s[0]) + comma(s[1:i]) + s[i:] &#125; else if s[i] == &#x27;.&#x27; &#123; return comma(s[:i]) + s[i:] &#125; &#125; if n &lt;= 3 &#123; return s &#125; return comma(s[:n-3]) + &quot;,&quot; + s[n-3:]&#125; 练习 3.12： 编写一个函数，判断两个字符串是否是相互打乱的，也就是说它们有着相同的字符，但是对应不同的顺序。 1234567891011121314151617181920func isSame(s1, s2 string) bool &#123; if len(s1) != len(s2) &#123; return false &#125; r1 := make(map[byte]int) r2 := make(map[byte]int) for i := 0; i &lt; len(s1); i++ &#123; r1[s1[i]]++ r2[s2[i]]++ &#125; for c, i := range r1 &#123; if r2[c] != i &#123; return false &#125; &#125; return true&#125; 3.5.5. 字符串和数字的转换 由strconv包提供这类转换功能。 整数转为字符串 将一个整数转为字符串， 一种方法是用fmt.Sprintf返回一个格式化的字符串； 另一个方法是用strconv.Itoa(“整数到ASCII”) 123x := 123y := fmt.Sprintf(&quot;%d&quot;, x)fmt.Println(y, strconv.Itoa(x)) // &quot;123 123&quot; FormatInt和FormatUint函数可以用不同的进制来格式化数字 1fmt.Println(strconv.FormatInt(int64(x), 2)) // &quot;1111011&quot; fmt.Printf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含有附加额外信息的时候 1s := fmt.Sprintf(&quot;x=%b&quot;, x) // &quot;x=1111011&quot; 字符串转为整数 可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数 12x, err := strconv.Atoi(&quot;123&quot;) // x is an inty, err := strconv.ParseInt(&quot;123&quot;, 10, 64) // base 10, up to 64 bit ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。 在任何情况下，返回的结果y总是int64类型，你可以通过强制类型转换将它转为更小的整数类型。 有时候也会使用fmt.Scanf来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。 3.6. 常量 常量表达式的值在编译期计算，而不是在运行期。 每种常量的潜在类型都是基础类型：boolean、string或数字。 一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改 1const pi = 3.14159 // approximately; math.Pi is a better approximation 批量声明 1234const ( e = 2.71828182845904523536028747135266249775724709369995957496696763 pi = 3.14159265358979323846264338327950288419716939937510582097494459) 所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。 当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。 常量间的所有算术运算、逻辑运算和比较运算的结果也是常量 对常量的类型转换操作或以下函数调用都是返回常量结果： len、cap、real、imag、complex和unsafe.Sizeof 因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分 1234567const IPv4Len = 4// parseIPv4 parses an IPv4 address (d.d.d.d).func parseIPv4(s string) IP &#123; var p [IPv4Len]byte // ...&#125; 一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型 12345const noDelay time.Duration = 0const timeout = 5 * time.Minutefmt.Printf(&quot;%T %[1]v\\n&quot;, noDelay) // &quot;time.Duration 0&quot;fmt.Printf(&quot;%T %[1]v\\n&quot;, timeout) // &quot;time.Duration 5m0s&quot;fmt.Printf(&quot;%T %[1]v\\n&quot;, time.Minute) // &quot;time.Duration 1m0s&quot; 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略 如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的 12345678const ( a = 1 b c = 2 d)fmt.Println(a, b, c, d) // &quot;1 1 2 2&quot; 3.6.1. iota 常量生成器 常量声明可以使用iota常量生成器初始化 它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式 在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。 类似于枚举类型 123456789101112type Weekday intconst ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday)// 周日将对应0，周一为1，如此等等。 也可以在复杂的常量表达式中使用iota 123456789101112131415161718192021222324type Flags uintconst ( FlagUp Flags = 1 &lt;&lt; iota // is up FlagBroadcast // supports broadcast access capability FlagLoopback // is a loopback interface FlagPointToPoint // belongs to a point-to-point link FlagMulticast // supports multicast access capability)func IsUp(v Flags) bool &#123; return v&amp;FlagUp == FlagUp &#125;func TurnDown(v *Flags) &#123; *v &amp;^= FlagUp &#125;func SetBroadcast(v *Flags) &#123; *v |= FlagBroadcast &#125;func IsCast(v Flags) bool &#123; return v&amp;(FlagBroadcast|FlagMulticast) != 0 &#125;func main() &#123; var v Flags = FlagMulticast | FlagUp fmt.Printf(&quot;%b %t\\n&quot;, v, IsUp(v)) // &quot;10001 true&quot; TurnDown(&amp;v) fmt.Printf(&quot;%b %t\\n&quot;, v, IsUp(v)) // &quot;10000 false&quot; SetBroadcast(&amp;v) fmt.Printf(&quot;%b %t\\n&quot;, v, IsUp(v)) // &quot;10010 false&quot; fmt.Printf(&quot;%b %t\\n&quot;, v, IsCast(v)) // &quot;10010 true&quot;&#125; 1234567891011const ( _ = 1 &lt;&lt; (10 * iota) KiB // 1024 MiB // 1048576 GiB // 1073741824 TiB // 1099511627776 (exceeds 1 &lt;&lt; 32) PiB // 1125899906842624 EiB // 1152921504606846976 ZiB // 1180591620717411303424 (exceeds 1 &lt;&lt; 64) YiB // 1208925819614629174706176) 不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符 练习 3.13： 编写KB、MB的常量声明，然后扩展到YB。 1234567891011const ( B = 1 &lt;&lt; (3 + 10 * iota) KB MB GB TB PB EB ZB YB) 3.6.2. 无类型常量 Go语言的常量有个不同寻常之处 虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型 但是许多常量并没有一个明确的基础类型。 编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算； 你可以认为至少有256bit的运算精度。 这里有六种未明确类型的常量类型，分别是 无类型的布尔型 无类型的整数 无类型的字符 无类型的浮点数 无类型的复数 无类型的字符串 通过延迟明确常量的具体类型 无类型的常量不仅可以提供更高的运算精度 而且可以直接用于更多的表达式而不需要显式的类型转换 1fmt.Println(YiB/ZiB) // &quot;1024&quot; 一个例子，math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方 123var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi 如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换 12345const Pi64 float64 = math.Pivar x float32 = float32(Pi64)var y float64 = Pi64var z complex128 = complex128(Pi64) 除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果 1234var f float64 = 212fmt.Println((f - 32) * 5 / 9) // &quot;100&quot;; (f - 32) * 5 is a float64fmt.Println(5 / 9 * (f - 32)) // &quot;0&quot;; 5/9 is an untyped integer, 0fmt.Println(5.0 / 9.0 * (f - 32)) // &quot;100&quot;; 5.0/9.0 is an untyped float 只有常量可以是无类型的。 当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句， 或者出现在有明确类型的变量声明的右边，如下面的其余三行语句， 无类型的常量将会被隐式转换为对应的类型，如果转换合法的话 1234var f float64 = 3 + 0i // untyped complex -&gt; float64f = 2 // untyped integer -&gt; float64f = 1e123 // untyped floating-point -&gt; float64f = &#x27;a&#x27; // untyped rune -&gt; float64 上面的语句相当于: 1234var f float64 = float64(3 + 0i)f = float64(2)f = float64(1e123)f = float64(&#x27;a&#x27;) 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。 对于浮点数和复数，可能会有舍入处理 123456789const ( deadbeef = 0xdeadbeef // untyped int with value 3735928559 a = uint32(deadbeef) // uint32 with value 3735928559 b = float32(deadbeef) // float32 with value 3735928576 (rounded up) c = float64(deadbeef) // float64 with value 3735928559 (exact) d = int32(deadbeef) // compile error: constant overflows int32 e = float64(1e309) // compile error: constant overflows float64 f = uint(-1) // compile error: constant underflows uint) 对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子 1234i := 0 // untyped integer; implicit int(0)r := &#x27;\\000&#x27; // untyped rune; implicit rune(&#x27;\\000&#x27;)f := 0.0 // untyped floating-point; implicit float64(0.0)c := 0i // untyped complex; implicit complex128(0i) 注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型 如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型 12var i = int8(0)var i int8 = 0 当尝试将这些无类型的常量转为一个接口值时，这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。 1234fmt.Printf(&quot;%T\\n&quot;, 0) // &quot;int&quot;fmt.Printf(&quot;%T\\n&quot;, 0.0) // &quot;float64&quot;fmt.Printf(&quot;%T\\n&quot;, 0i) // &quot;complex128&quot;fmt.Printf(&quot;%T\\n&quot;, &#x27;\\000&#x27;) // &quot;int32&quot; (rune)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Go","slug":"编程语言/Go","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://ye2222.github.io/tags/Go/"}]},{"title":"Go2","slug":"Go2","date":"2021-10-04T12:37:05.000Z","updated":"2023-04-26T11:19:54.679Z","comments":true,"path":"posts/12316/","link":"","permalink":"https://ye2222.github.io/posts/12316/","excerpt":"","text":"2.1 命名 关键字及内建名字 变量的作用范围 函数内部和外部 如果一个名字是在函数内部定义，那么它就只在函数内部有效。 如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。 名字的大小写 名字的开头字母的大小写决定了名字在包外的可见性。 如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问 包本身的名字一般总是用小写字母。 2.2 声明 声明语句定义了程序的各种实体对象以及部分或全部的属性。 Go语言主要有四种类型的声明语句： var 变量 const 常量 type 类型 func 函数实体 一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。 每个源文件中以包的声明语句开始，说明该源文件是属于哪个包 包声明语句之后是import语句导入依赖的其它包 然后是包一级的类型、变量、常量、函数的声明语句 包一级的各种类型的声明语句的顺序无关紧要 函数内部的名字则必须先声明之后才能使用 例子 1234567891011121314// Boiling prints the boiling point of water.package mainimport &quot;fmt&quot;const boilingF = 212.0func main() &#123; var f = boilingF var c = (f - 32) * 5 / 9 fmt.Printf(&quot;boiling point = %g°F or %g°C\\n&quot;, f, c) // Output: // boiling point = 212°F or 100°C&#125; 变量 常量boilingF是在包一级范围声明语句声明的 包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问 f和c两个变量是在main函数内部声明的声明语句声明的 局部声明的名字就只能在函数内部很小的范围被访问。 函数 一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。 如果函数没有返回值，那么返回值列表是省略的。 执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。 2.3 变量 var声明语句 1var 变量名字 类型 = 表达式 var声明语句可以创建一个特定类型的变量 给变量附加一个名字，并且设置变量的初始值 其中“类型”或“= 表达式”两个部分可以省略其中的一个。 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。 如果初始化表达式被省略，那么将用零值初始化该变量。 接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil 可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量 如果省略每个变量的类型，将可以声明多个类型不同的变量 12var i, j, k int // int, int, intvar b, f, s = true, 2.3, &quot;four&quot; // bool, float64, string 在包级别声明的变量会在main入口函数执行前完成初始化 局部变量将在声明语句被执行到的时候完成初始化。 一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化 1var f, err = os.Open(name) // os.Open returns a file and an error 2.3.1 简短的变量声明 “名字 := 表达式”形式声明变量 变量的类型根据表达式来自动推导 简短变量声明被广泛用于大部分的局部变量的声明和初始化 1t := 0.0 var形式的声明语句往往是用于需要显式指定变量类型的地方 或者因为变量稍后会被重新赋值而初始值无关紧要的地方。 12345i := 100 // an intvar boiling float64 = 100 // a float64var names []stringvar err errorvar p Point 多变量同时赋值 12i, j := 0, 1i, j = j, i // 交换 i 和 j 的值 注意 “:=”是一个变量声明语句，而“=”是一个变量赋值操作 1f, err := os.Open(name) 简短变量声明语句中必须至少要声明一个新的变量 123f, err := os.Open(infile)// ...f, err := os.Create(outfile) // compile error: no new variables 简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价 如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。 2.3.2. 指针 一个变量对应一个保存了变量对应类型值的内存空间。 普通变量在声明语句创建时被绑定到一个变量名 一个指针的值是另一个变量的地址。 一个指针对应变量在内存中的存储位置 并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。 如果用“var x int”声明语句声明一个x变量， 那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针 指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。 如果指针名字为p，那么可以说“p指针指向变量x”， 或者说“p指针保存了x变量的内存地址”。 同时*p表达式对应p指针指向的变量的值。 一般*p表达式读取指针指向的变量的值，这里为int类型的值， 同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。 12345x := 1p := &amp;x // p, of type *int, points to xfmt.Println(*p) // &quot;1&quot;*p = 2 // equivalent to x = 2fmt.Println(x) // &quot;2&quot; 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。 即使变量由表达式临时生成，那么表达式也必须能接受&amp;取地址操作。 任何类型的指针的零值都是nil。 如果p指向某个有效变量，那么p != nil测试为真。 指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。 12var x, y intfmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == nil) // &quot;true false false&quot; 在Go语言中，返回函数中局部变量的地址也是安全的。 12345678var p = f()func f() *int &#123; v := 1 return &amp;v&#125;fmt.Println(f() == f()) // &quot;false&quot; flag包 指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。 12345678910111213141516171819// Echo4 prints its command-line arguments.package mainimport ( &quot;flag&quot; &quot;fmt&quot; &quot;strings&quot;)var n = flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)var sep = flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)func main() &#123; flag.Parse() fmt.Print(strings.Join(flag.Args(), *sep)) if !*n &#123; fmt.Println() &#125;&#125; 调用flag.Bool函数会创建一个新的对应布尔型标志参数的变量。有三个属性 第一个是命令行标志参数的名字“n”， 然后是该标志参数的默认值（这里是false）， 最后是该标志参数对应的描述信息。 程序中的sep和n变量分别是指向对应命令行标志参数变量的指针，因此必须用*sep和*n形式的指针语法间接引用它们。 2.3.3. new函数 另一个创建变量的方法是调用内建的new函数 表达式new(T)将创建一个T类型的匿名变量 初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 1234p := new(int) // p, *int 类型, 指向匿名的 int 变量fmt.Println(*p) // &quot;0&quot;*p = 2 // 设置 int 匿名变量的值为 2fmt.Println(*p) // &quot;2&quot; 用new创建变量和普通变量声明语句方式创建变量没有什么区别 除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T) 12345678func newInt() *int &#123; return new(int)&#125;func newInt() *int &#123; var dummy int return &amp;dummy&#125; 每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的 123p := new(int)q := new(int)fmt.Println(p == q) // &quot;false&quot; 特殊情况：如果两个类型都是空的，也就是说类型的大小是0 例如struct&#123;&#125;和[0]int，有可能有相同的地址（依赖具体的语言实现） 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。 1func delta(old, new int) int &#123; return new - old &#125; 2.3.4. 变量的生命周期 变量的生命周期指的是在程序运行期间变量有效存在的时间段。 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。 而相比之下，局部变量的生命周期则是动态的： 每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收 函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。 Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？ 基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。 如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的 123456789101112var global *intfunc f() &#123; var x int x = 1 global = &amp;x&#125;func g() &#123; y := new(int) *y = 1&#125; f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的 *y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间 其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。 2.4 赋值 使用赋值语句可以更新一个变量的值 最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。 1234x = 1 // 命名变量的赋值*p = true // 通过指针间接赋值person.name = &quot;bob&quot; // 结构体字段赋值count[x] = count[x] * scale // 数组、slice或map的元素赋值 特定的二元算术运算符和赋值语句的复合操作有一个简洁形式 数值变量也可以支持++递增和--递减语句 1234count[x] *= scalev := 1v++ // 等价方式 v = v + 1；v 变成 2v-- // 等价方式 v = v - 1；v 变成 1 2.4.1. 元组赋值 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。 在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值 12345678910x, y = y, xa[i], a[j] = a[j], a[i]func gcd(x, y int) int &#123; for y != 0 &#123; x, y = y, x%y &#125; return x&#125; 元组赋值也可以使一系列琐碎赋值更加紧凑 1i, j, k = 2, 3, 5 但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。 有些表达式会产生多个值，比如调用一个有多个返回值的函数。 当这样一个函数调用出现在元组赋值右边的表达式中时 （译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。 1f, err = os.Open(&quot;foo.txt&quot;) // function call returns two values 通常，这类函数会用额外的返回值来表达某种错误类型 还有一些是用来返回布尔值，通常被称为ok。 123v, ok = m[key] // map lookupv, ok = x.(T) // type assertionv, ok = &lt;-ch // channel receive 和变量声明一样，我们可以用下划线空白标识符_来丢弃不需要的值。 12_, err = io.Copy(dst, src) // 丢弃字节数_, ok = x.(T) // 只检测类型，忽略具体值 2.4.2. 可赋值性 赋值语句是显式的赋值形式 但是程序中还有很多地方会发生隐式的赋值行为： 函数调用会隐式地将调用参数的值赋值给函数的参数变量， 一个返回语句会隐式地将返回操作的值赋值给结果变量， 一个复合类型的字面量（§4.2）也会产生赋值行为。 1medals := []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125; 隐式地对slice的每个元素进行赋值操作，类似这样写的行为 123medals[0] = &quot;gold&quot;medals[1] = &quot;silver&quot;medals[2] = &quot;bronze&quot; map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。 不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。 更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。 nil可以赋值给任何指针或引用类型的变量 2.5. 类型 变量或表达式的类型定义了对应存储值的属性特征 数值在内存的存储大小（或者是元素的bit个数） 它们在内部是如何表达的，是否支持一些操作符 以及它们自己关联的方法集等 在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。 一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。 新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的 1type 类型名字 底层类型 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。 1234567891011121314151617// Package tempconv performs Celsius and Fahrenheit temperature computations.package tempconvimport &quot;fmt&quot;type Celsius float64 // 摄氏温度type Fahrenheit float64 // 华氏温度const ( AbsoluteZeroC Celsius = -273.15 // 绝对零度 FreezingC Celsius = 0 // 结冰点温度 BoilingC Celsius = 100 // 沸水温度)func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9/5 + 32) &#125;func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 / 9) &#125; 在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。 它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。 类型转换 Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。 类型转换不会改变值本身，但是会使它们的语义发生变化。 对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型 如果T是指针类型，可能会需要用小括弧包装T，比如(*int)(0) 只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身 数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的 将一个浮点数转为整数将丢弃小数部分，将一个字符串转为[]byte类型的slice将拷贝一个字符串数据的副本 比较 比较运算符==和&lt;也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。 如果两个值有着不同的类型，则不能直接进行比较： 123456var c Celsiusvar f Fahrenheitfmt.Println(c == 0) // &quot;true&quot;fmt.Println(f &gt;= 0) // &quot;true&quot;fmt.Println(c == f) // compile error: type mismatchfmt.Println(c == Celsius(f)) // &quot;true&quot;! 注意最后那个语句。尽管看起来像函数调用，但是Celsius(f)是类型转换操作，它并不会改变值，仅仅是改变值的类型而已 测试为真的原因是因为c和g都是零值。 下面的声明语句，Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串 1func (c Celsius) String() string &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125; 许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印 1234567c := FToC(212.0)fmt.Println(c.String()) // &quot;100°C&quot;fmt.Printf(&quot;%v\\n&quot;, c) // &quot;100°C&quot;; no need to call String explicitlyfmt.Printf(&quot;%s\\n&quot;, c) // &quot;100°C&quot;fmt.Println(c) // &quot;100°C&quot;fmt.Printf(&quot;%g\\n&quot;, c) // &quot;100&quot;; does not call Stringfmt.Println(float64(c)) // &quot;100&quot;; does not call String 2.6. 包和文件 Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用 一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径 例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。 每个包都对应一个独立的名字空间。 例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。 要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。 在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的 例子 把变量的声明、对应的常量，还有方法都放到tempconv.go源文件中： 123456789101112131415161718// Package tempconv performs Celsius and Fahrenheit conversions.package tempconvimport &quot;fmt&quot;type Celsius float64type Fahrenheit float64type Kelvin float64const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC Celsius = 100)func (c Celsius) String() string &#123; return fmt.Sprintf(&quot;%g°C&quot;, c) &#125;func (f Fahrenheit) String() string &#123; return fmt.Sprintf(&quot;%g°F&quot;, f) &#125;func (k Kelvin) String() string &#123; return fmt.Sprintf(&quot;%g K&quot;, k) &#125; 转换函数则放在另一个conv.go源文件中 123456789101112131415package tempconv// CToF converts a Celsius temperature to Fahrenheit.func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9/5 + 32) &#125;// FToC converts a Fahrenheit temperature to Celsius.func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 / 9) &#125;func CToK(c Celsius) Kelvin &#123; return Kelvin(c - 273.15) &#125;func KToC(k Kelvin) Celsius &#123; return Celsius(k + 273.15) &#125;func FToK(f Fahrenheit) Kelvin &#123;return CToK(FToC(f)) &#125;func KToF(k Kelvin) Fahrenheit &#123;return CToF(KToC(k))&#125; 每个源文件都是以包的声明语句开始，用来指明包的名字。 当包被导入的时候，包内的成员将通过类似tempconv.CToF的形式访问。 而包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。 要注意的是tempconv.go源文件导入了fmt包，但是conv.go源文件并没有，因为这个源文件中的代码并没有用到fmt包。 包级别的常量名都是以大写字母开头，它们可以像tempconv.AbsoluteZeroC这样被外部代码访问： 1fmt.Printf(&quot;Brrrr! %v\\n&quot;, tempconv.AbsoluteZeroC) // &quot;Brrrr! -273.15°C&quot; 要将摄氏温度转换为华氏温度，需要先用import语句导入gopl.io/ch2/tempconv包，然后就可以使用下面的代码进行转换了： 要将摄氏温度转换为华氏温度，需要先用import语句导入gopl.io/ch2/tempconv包，然后就可以使用下面的代码进行转换了 1fmt.Println(tempconv.CToF(tempconv.BoilingC)) // &quot;212°F&quot; 在每个源文件的包声明前紧跟着的注释是包注释 通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释 （如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。 如果包注释很大，通常会放到一个独立的doc.go文件中。 2.6.1. 导入包 在Go语言程序中，每个包都有一个全局唯一的导入路径 除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。 导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。 如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理 在这种情况下，我们需要将不必要的导入删除或注释掉 可以使用golang.org/x/tools/cmd/goimports导入工具，它可以根据需要自动添加或删除导入的包 许多编辑器都可以集成goimports工具，然后在保存文件的时候自动运行。 类似的还有gofmt工具，可以用来格式化Go源文件 2.6.2. 包的初始化 包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化 12345var a = b + c // a 第三个初始化, 为 3var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c)var c = 1 // c 第一个初始化, 为 1func f() int &#123; return c + 1 &#125; 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化 Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。 对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的 例如某些表格数据初始化并不是一个简单的赋值过程。 在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数 1func init() &#123; /* ... */ &#125; 这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。 在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。 因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。 初始化工作是自下而上进行的，main包最后被初始化。 以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。 2.7. 作用域 一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。 声明语句的作用域是指源代码中可以有效使用这个名字的范围。 作用域和声明周期的区别 声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。 一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。 词法块 句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。 句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围 对全局的源代码来说，存在一个整体的词法块，称为全局词法块； 对于每个包；每个for、if和switch语句，也都有对应词法块； 每个switch或select的分支也有独立的词法块； 当然也包括显式书写的词法块（花括弧包含的语句）。 作用域大小 声明语句对应的词法域决定了作用域范围的大小。 对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。 任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的 一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。 当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。 如果查找失败，则报告“未声明的名字”这样的错误。 如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。 在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问 12345678910func f() &#123;&#125;var g = &quot;g&quot;func main() &#123; f := &quot;f&quot; fmt.Println(f) // &quot;f&quot;; local var f shadows package-level func f fmt.Println(g) // &quot;g&quot;; package-level var fmt.Println(h) // compile error: undefined: h&#125; 特别注意短变量声明语句的作用域范围 12345678var cwd stringfunc init() &#123; cwd, err := os.Getwd() // compile error: unused: cwd if err != nil &#123; log.Fatalf(&quot;os.Getwd failed: %v&quot;, err) &#125;&#125; 虽然cwd在外部已经声明过，但是:=语句还是将cwd和err重新声明为新的局部变量。 因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。 123456789var cwd stringfunc init() &#123; cwd, err := os.Getwd() // NOTE: wrong! if err != nil &#123; log.Fatalf(&quot;os.Getwd failed: %v&quot;, err) &#125; log.Printf(&quot;Working directory = %s&quot;, cwd)&#125; 全局的cwd变量依然是没有被正确初始化的，而且看似正常的日志输出更是让这个BUG更加隐晦。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Go","slug":"编程语言/Go","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://ye2222.github.io/tags/Go/"}]},{"title":"Go1","slug":"Go1","date":"2021-10-04T06:44:42.000Z","updated":"2023-04-26T11:19:54.664Z","comments":true,"path":"posts/12636/","link":"","permalink":"https://ye2222.github.io/posts/12636/","excerpt":"","text":"命令行参数接收 普通方法 123456var s, sep stringfor i := 1; i &lt; len(os.Args); i++ &#123; s += sep + os.Args[i] sep = &quot; &quot;&#125;fmt.Println(s) 使用range range产生一对值：索引以及在该索引处的元素值 123456s, sep := &quot;&quot;, &quot;&quot;for _, arg := range os.Args[1:] &#123; s += sep + arg sep = &quot; &quot;&#125;fmt.Println(s) Go语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。 变量声明 1234s := &quot;&quot;var s stringvar s = &quot;&quot;var s string = &quot;&quot; 第一种形式: 短变量声明 最简洁，但只能用在函数内部，而不能用于包变量。 第二种形式 依赖于字符串的默认初始化零值机制，被初始化为\"\" 第三种形式 用得很少，除非同时声明多个变量。 第四种形式 显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余， 但如果两者类型不同，变量类型就必须了 简洁高效的方法，使用strings 123func main() &#123; fmt.Println(strings.Join(os.Args[1:], &quot; &quot;))&#125; 查找重复行 Dup1 1234567891011121314151617181920212223// Dup1 prints the text of each line that appears more than// once in the standard input, preceded by its count.package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot;)func main() &#123; counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() &#123; counts[input.Text()]++ &#125; // NOTE: ignoring potential errors from input.Err() for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf(&quot;%d\\t%s\\n&quot;, n, line) &#125; &#125;&#125; IF语句 if语句条件两边也不加括号，但是主体部分需要加 if语句的else部分是可选的，在if的条件为false时执行。 map map存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取或测试操作。 键可以是任意类型，只要其值能用==运算符比较，最常见的例子是字符串 值则可以是任意类型。这个例子中的键是字符串，值是整数 从功能和实现上说，Go的map类似于Java语言中的HashMap，Python语言中的dict map的迭代顺序并不确定，从实践来看，该顺序随机，每次运行都会变化。 这种设计是有意为之的，因为能防止程序依赖特定遍历顺序，而这是无法保证的。 每次读取一行输入，该行被当做键存入map，其对应的值递增。 counts[input.Text()]++语句等价下面两句： 12line := input.Text()counts[line] = counts[line] + 1 bufio包 它使处理输入和输出方便又高效。 Scanner类型是该包最有用的特性之一，它读取输入并将其拆成行或单词； 通常是处理行形式的输入最简单的方法。 每次调用input.Scan()，即读入下一行，并移除行末的换行符 读取的内容可以调用input.Text()得到 Scan函数在读到一行时返回true，不再有输入时返回false。 Printf 12345678910%d 十进制整数%x, %o, %b 十六进制，八进制，二进制整数。%f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00%t 布尔：true或false%c 字符（rune） (Unicode码点)%s 字符串%q 带双引号的字符串&quot;abc&quot;或带单引号的字符&#x27;c&#x27;%v 变量的自然形式（natural format）%T 变量的类型%% 字面上的百分号标志（无操作数） Dup2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Dup2 prints the count and text of lines that appear more than once// in the input. It reads from stdin or from a list of named files.package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot;)func main() &#123; counts := make(map[string]int) files := os.Args[1:] // 如果命令行参数中没有文件参数，则按输入来进行计数 if len(files) == 0 &#123; countLines(os.Stdin, counts) &#125; // 读取文件 else &#123; // 遍历所有参数 for _, arg := range files &#123; // 打开文件 f, err := os.Open(arg) if err != nil &#123; fmt.Fprintf(os.Stderr, &quot;dup2: %v\\n&quot;, err) continue &#125; countLines(f, counts) // 关闭文件 f.Close() &#125; &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf(&quot;%d\\t%s\\n&quot;, n, line) &#125; &#125;&#125;func countLines(f *os.File, counts map[string]int) &#123; input := bufio.NewScanner(f) for input.Scan() &#123; counts[input.Text()]++ &#125; // NOTE: ignoring potential errors from input.Err()&#125; os.Open函数 返回两个值 第一个值是被打开的文件(*os.File） 第二个值是内置error类型的值 注意 countLines函数在其声明前被调用。 函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用 map的变化 map是一个由make函数创建的数据结构的引用 map作为参数传递给某函数时，该函数接收这个引用的一份拷贝（copy，或译为副本） 被调用函数对map底层数据结构的任何修改，调用者函数都可以通过持有的map引用看到 Dup3 dup的前两个版本以\"流”模式读取输入，并根据需要拆分成多个行 可以一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们。 引入了ReadFile函数（来自于io/ioutil包），其读取指定文件的全部内容， strings.Split函数把字符串分割成子串的切片 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;os&quot; &quot;strings&quot;)func main() &#123; counts := make(map[string]int) for _, filename := range os.Args[1:] &#123; data, err := ioutil.ReadFile(filename) if err != nil &#123; fmt.Fprintf(os.Stderr, &quot;dup3: %v\\n&quot;, err) continue &#125; for _, line := range strings.Split(string(data), &quot;\\n&quot;) &#123; counts[line]++ &#125; &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf(&quot;%d\\t%s\\n&quot;, n, line) &#125; &#125;&#125; ReadFile函数 返回一个字节切片（byte slice），必须把它转换为string，才能用strings.Split分割。 注意 bufio.Scanner、ioutil.ReadFile和ioutil.WriteFile都使用*os.File的Read和Write方法 练习 出现重复的行打印文件名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot;)func main() &#123; counts := make(map[string]int) file := os.Args[1:] if len(file) == 0 &#123; countLines1(os.Stdin, counts) &#125; else &#123; countFile := make(map[string]int) for _, filename := range file &#123; data, err := os.Open(filename) if err != nil &#123; fmt.Printf(&quot;error %v&quot;, err) &#125; countLines(data, counts, filename, countFile) &#125; for key, value := range countFile &#123; if value &gt;= 1 &#123; fmt.Println(key, value) &#125; &#125; &#125;// 出现重复的行时打印文件名称&#125;func countLines1(f *os.File, counts map[string]int) &#123; input := bufio.NewScanner(f) for input.Scan() &#123; counts[input.Text()]++ &#125; // NOTE: ignoring potential errors from input.Err()&#125;func countLines(f *os.File, counts map[string]int, filename string, countFile map[string]int) &#123; input := bufio.NewScanner(f) for input.Scan() &#123; counts[input.Text()]++ &#125; for _, value := range counts &#123; if value &gt; 1 &#123; countFile[filename]++ &#125; &#125; // NOTE: ignoring potential errors from input.Err()&#125; GIF动画--image包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Lissajous generates GIF animations of random Lissajous figures.package mainimport ( &quot;image&quot; &quot;image/color&quot; &quot;image/gif&quot; &quot;io&quot; &quot;math&quot; &quot;math/rand&quot; &quot;os&quot; &quot;time&quot;)var palette = []color.Color&#123;color.White, color.Black&#125;const ( whiteIndex = 0 // first color in palette blackIndex = 1 // next color in palette)func main() &#123; // The sequence of images is deterministic unless we seed // the pseudo-random number generator using the current time. // Thanks to Randall McPherson for pointing out the omission. rand.Seed(time.Now().UTC().UnixNano()) lissajous(os.Stdout)&#125;func lissajous(out io.Writer) &#123; const ( cycles = 5 // number of complete x oscillator revolutions res = 0.001 // angular resolution size = 100 // image canvas covers [-size..+size] nframes = 64 // number of animation frames delay = 8 // delay between frames in 10ms units ) freq := rand.Float64() * 3.0 // relative frequency of y oscillator anim := gif.GIF&#123;LoopCount: nframes&#125; phase := 0.0 // phase difference for i := 0; i &lt; nframes; i++ &#123; rect := image.Rect(0, 0, 2*size+1, 2*size+1) img := image.NewPaletted(rect, palette) for t := 0.0; t &lt; cycles*2*math.Pi; t += res &#123; x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex) &#125; phase += 0.1 anim.Delay = append(anim.Delay, delay) anim.Image = append(anim.Image, img) &#125; gif.EncodeAll(out, &amp;anim) // NOTE: ignoring encoding errors&#125; import了一个包路径包含有多个单词的package时，比如image/color（image和color两个单词），通常我们只需要用最后那个单词表示这个包就可以 当我们写color.White时，这个变量指向的是image/color包里的变量，同理gif.GIF是属于image/gif包里的变量 常量 常量是指在程序编译后运行时始终都不会变化的值，比如圈数、帧数、延迟值 常量声明和变量声明一般都会出现在包级别，所以这些常量在整个包中都是可以共享的， 或者你也可以把常量声明定义在函数体内部，那么这种常量就只能在函数体内用 复合声明 []color.Color{...}和gif.GIF{...}这两个表达式就是我们说的复合声明 前者生成的是一个slice切片，后者生成的是一个struct结构体。 struct是一组值或者叫字段的集合，不同的类型集合在一个struct可以让我们以一个统一的单元进行处理 anim是一个gif.GIF类型的struct变量。 这种写法会生成一个struct变量，并且其内部变量LoopCount字段会被设置为nframes，其它的字段会被设置为各自类型默认的零值。 struct内部的变量可以以一个点（.）来进行访问 lissajous函数 内部有两层嵌套的for循环 外层循环会循环64次，每一次都会生成一个单独的动画帧 生成了一个包含两种颜色的201*201大小的图片，白色和黑色 所有像素点都会被默认设置为其零值（也就是调色板palette里的第0个值），这里我们设置的是白色。 每次外层循环都会生成一张新图片，并将一些像素设置为黑色。 结果会append到之前结果之后。这里我们用到了append(参考4.2.1)内置函数，将结果append到anim中的帧列表末尾，并设置一个默认的80ms的延迟值 循环结束后所有的延迟值被编码进了GIF图片中，并将结果写入到输出流。 内层循环设置两个偏振值。x轴偏振使用sin函数。y轴偏振也是正弦波，但其相对x轴的偏振是一个0-3的随机值，初始偏振值是一个零值，随着动画的每一帧逐渐增加 循环会一直跑到x轴完成五次完整的循环。每一步它都会调用SetColorIndex来为(x,y)点来染黑色。 main函数调用lissajous函数，用它来向标准输出流打印信息 12go build gopl.io/ch1/lissajouslissajous &gt;out.gif 获取URL--net包 1234567891011121314151617181920212223242526// Fetch prints the content found at a URL.package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;os&quot;)func main() &#123; for _, url := range os.Args[1:] &#123; resp, err := http.Get(url) if err != nil &#123; fmt.Fprintf(os.Stderr, &quot;fetch: %v\\n&quot;, err) os.Exit(1) &#125; b, err := ioutil.ReadAll(resp.Body) resp.Body.Close() if err != nil &#123; fmt.Fprintf(os.Stderr, &quot;fetch: reading %s: %v\\n&quot;, url, err) os.Exit(1) &#125; fmt.Printf(&quot;%s&quot;, b) &#125;&#125; http.Get函数是创建HTTP请求的函数，如果获取过程没有出错，那么会在resp这个结构体中得到访问的请求结果 resp的Body字段包括一个可读的服务器响应流 ioutil.ReadAll函数从response中读取到全部内容；将其结果保存在变量b中。 resp.Body.Close关闭resp的Body流，防止资源泄露，Printf函数会将结果b写出到标准输出流中。 练习 12345678910111213141516171819202122232425262728293031323334// Fetch prints the content found at a URL.package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net/http&quot; &quot;os&quot; &quot;strings&quot;)func main() &#123; for _, url := range os.Args[1:] &#123; if !strings.HasPrefix(url,&quot;https://&quot;) &#123; url = &quot;https://&quot;+url &#125; resp, err := http.Get(url) fmt.Println(resp.Status) if err != nil &#123; fmt.Fprintf(os.Stderr, &quot;fetch: %v\\n&quot;, err) os.Exit(1) &#125; dst := io.Writer(os.Stdout) _, err = io.Copy(dst, resp.Body) resp.Body.Close() if err != nil &#123; fmt.Fprintf(os.Stderr, &quot;fetch: reading %s: %v\\n&quot;, url, err) os.Exit(1) &#125; fmt.Printf(&quot;%s&quot;, os.Stdout) &#125;&#125; 并发获取多个URL 12345678910111213141516171819202122232425262728293031323334353637383940// Fetchall fetches URLs in parallel and reports their times and sizes.package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;os&quot; &quot;time&quot;)func main() &#123; start := time.Now() ch := make(chan string) for _, url := range os.Args[1:] &#123; go fetch(url, ch) // start a goroutine &#125; for range os.Args[1:] &#123; fmt.Println(&lt;-ch) // receive from channel ch &#125; fmt.Printf(&quot;%.2fs elapsed\\n&quot;, time.Since(start).Seconds())&#125;func fetch(url string, ch chan&lt;- string) &#123; start := time.Now() resp, err := http.Get(url) if err != nil &#123; ch &lt;- fmt.Sprint(err) // send to channel ch return &#125; nbytes, err := io.Copy(ioutil.Discard, resp.Body) resp.Body.Close() // don&#x27;t leak resources if err != nil &#123; ch &lt;- fmt.Sprintf(&quot;while reading %s: %v&quot;, url, err) return &#125; secs := time.Since(start).Seconds() ch &lt;- fmt.Sprintf(&quot;%.2fs %7d %s&quot;, secs, nbytes, url)&#125; goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递 main函数本身也运行在一个goroutine中，而go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。 main函数中用make函数创建了一个传递string类型参数的channel 对每一个命令行参数，我们都用go这个关键字来创建一个goroutine，并且让函数在这个goroutine异步执行http.Get方法 io.Copy会把响应的Body内容拷贝到ioutil.Discard输出流中 可以把这个变量看作一个垃圾桶，可以向里面写一些不需要的数据），因为我们需要这个方法返回的字节数，但是又不想要其内容 每当请求返回内容时，fetch函数都会往ch这个channel里写入一个字符串，由main函数里的第二个for循环来处理并打印channel里的这个字符串。 当一个goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处，直到另一个goroutine从这个channel里接收或者写入值，这样两个goroutine才会继续执行channel操作之后的逻辑 Web服务器 123456789101112131415161718// Server1 is a minimal &quot;echo&quot; server.package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot;)func main() &#123; http.HandleFunc(&quot;/&quot;, handler) // each request calls handler log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))&#125;// handler echoes the Path component of the request URL r.func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;URL.Path = %q\\n&quot;, r.URL.Path)&#125; 对请求的次数进行计算 123456789101112131415161718192021222324252627282930313233// Server2 is a minimal &quot;echo&quot; and counter server.package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;sync&quot;)var mu sync.Mutexvar count intfunc main() &#123; http.HandleFunc(&quot;/&quot;, handler) http.HandleFunc(&quot;/count&quot;, counter) log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))&#125;// handler echoes the Path component of the requested URL.func handler(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() count++ mu.Unlock() fmt.Fprintf(w, &quot;URL.Path = %q\\n&quot;, r.URL.Path)&#125;// counter echoes the number of calls so far.func counter(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() fmt.Fprintf(w, &quot;Count %d\\n&quot;, count) mu.Unlock()&#125; handler函数会把请求的http头和请求的form数据都打印出来 123456789101112131415// handler echoes the HTTP request.func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;%s %s %s\\n&quot;, r.Method, r.URL, r.Proto) for k, v := range r.Header &#123; fmt.Fprintf(w, &quot;Header[%q] = %q\\n&quot;, k, v) &#125; fmt.Fprintf(w, &quot;Host = %q\\n&quot;, r.Host) fmt.Fprintf(w, &quot;RemoteAddr = %q\\n&quot;, r.RemoteAddr) if err := r.ParseForm(); err != nil &#123; log.Print(err) &#125; for k, v := range r.Form &#123; fmt.Fprintf(w, &quot;Form[%q] = %q\\n&quot;, k, v) &#125;&#125; 加入前面的gif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// Server2 is a minimal &quot;echo&quot; and counter server.package mainimport ( &quot;fmt&quot; &quot;image&quot; &quot;image/color&quot; &quot;image/gif&quot; &quot;io&quot; &quot;log&quot; &quot;math&quot; &quot;math/rand&quot; &quot;net/http&quot; &quot;sync&quot;)var mu sync.Mutexvar count intfunc main() &#123; http.HandleFunc(&quot;/&quot;, handler) http.HandleFunc(&quot;/image&quot;, func(w http.ResponseWriter, r *http.Request) &#123; lissajous(w) &#125;) http.HandleFunc(&quot;/count&quot;, counter) log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))&#125;// handler echoes the Path component of the requested URL.// handler echoes the HTTP request.func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;%s %s %s\\n&quot;, r.Method, r.URL, r.Proto) for k, v := range r.Header &#123; fmt.Fprintf(w, &quot;Header[%q] = %q\\n&quot;, k, v) &#125; fmt.Fprintf(w, &quot;Host = %q\\n&quot;, r.Host) fmt.Fprintf(w, &quot;RemoteAddr = %q\\n&quot;, r.RemoteAddr) if err := r.ParseForm(); err != nil &#123; log.Print(err) &#125; for k, v := range r.Form &#123; fmt.Fprintf(w, &quot;Form[%q] = %q\\n&quot;, k, v) &#125;&#125;// counter echoes the number of calls so far.func counter(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() fmt.Fprintf(w, &quot;Count %d\\n&quot;, count) mu.Unlock()&#125;// Lissajous generates GIF animations of random Lissajous figures.var palette = []color.Color&#123;color.White, color.Black&#125;const ( whiteIndex = 0 // first color in palette blackIndex = 1 // next color in palette)func lissajous(out io.Writer) &#123; const ( cycles = 5 // number of complete x oscillator revolutions res = 0.001 // angular resolution size = 100 // image canvas covers [-size..+size] nframes = 64 // number of animation frames delay = 8 // delay between frames in 10ms units ) freq := rand.Float64() * 3.0 // relative frequency of y oscillator anim := gif.GIF&#123;LoopCount: nframes&#125; phase := 0.0 // phase difference for i := 0; i &lt; nframes; i++ &#123; rect := image.Rect(0, 0, 2*size+1, 2*size+1) img := image.NewPaletted(rect, palette) for t := 0.0; t &lt; cycles*2*math.Pi; t += res &#123; x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex) &#125; phase += 0.1 anim.Delay = append(anim.Delay, delay) anim.Image = append(anim.Image, img) &#125; gif.EncodeAll(out, &amp;anim) // NOTE: ignoring encoding errors&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Go","slug":"编程语言/Go","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://ye2222.github.io/tags/Go/"}]},{"title":"每日英语","slug":"每日英语","date":"2021-10-04T06:44:42.000Z","updated":"2023-04-26T11:19:54.803Z","comments":true,"path":"posts/44664/","link":"","permalink":"https://ye2222.github.io/posts/44664/","excerpt":"","text":"1月份 1-10 泰勒斯威夫特 单词 1. stock 股票;(商店的)现货，存货，库存；股份；名声 存货;贮备，贮存(食物、书籍等) adj. 老一套的;陈腐的;(商店里)常备的，通常有的 例句 常用搭配 my stock was up and down 股票跌或涨 比喻顺境和逆境 同根词 2. negativity 否定性；消极性 同根词 3. resistance 反对；抵制；抗拒；抵抗；反抗 常用搭配 同根词 4. turbulence 骚乱，动荡；（空气或水的）湍流，紊流 例句 同根词 5. cynicism 愤世嫉俗；冷嘲热讽 例句 同根词 6. scepticism 怀疑主义；怀疑态度 例句 同根词 句式 1. take ... for granted 认为…是理所当然的;（因视作理所当然而）不把…当回事，对…不予重视（或不知感激） 例句 2. there be time/times when 曾经一度、有一个时期、有时 例句","categories":[],"tags":[{"name":"英语","slug":"英语","permalink":"https://ye2222.github.io/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"深度学习-10","slug":"深度学习-10","date":"2021-10-04T05:06:55.000Z","updated":"2023-04-26T11:19:54.806Z","comments":true,"path":"posts/62884/","link":"","permalink":"https://ye2222.github.io/posts/62884/","excerpt":"","text":"参数管理 访问参数，用于调试、诊断和可视化。 参数初始化。 在不同模型组件间共享参数 参数访问 用Sequential类定义模型，可通过索引来访问模型的任一层 模型像一个列表，每层的参数在其属性中 目标参数 每个参数都表示为参数类的一个实例 要对参数执行任何操作，首先要访问底层的数值 可以访问权重、偏置、梯度等参数 一次性访问所有参数： 第一种： 12print(*[(name, param.shape) for name, param in net[0].named_parameters()])print(*[(name, param.shape) for name, param in net.named_parameters()]) 第二种： 1net.state_dict()[&#x27;2.bias&#x27;].data 从嵌套块收集参数 12345678910111213def block1(): return nn.Sequential(nn.Linear(4, 8), nn.ReLU(), nn.Linear(8, 4), nn.ReLU())def block2(): net = nn.Sequential() for i in range(4): # 在这里嵌套 net.add_module(f&#x27;block &#123;i&#125;&#x27;, block1()) return netrgnet = nn.Sequential(block2(), nn.Linear(4, 1))rgnet(X) 1234567891011121314151617181920212223242526272829Sequential( (0): Sequential( (block 0): Sequential( (0): Linear(in_features=4, out_features=8, bias=True) (1): ReLU() (2): Linear(in_features=8, out_features=4, bias=True) (3): ReLU() ) (block 1): Sequential( (0): Linear(in_features=4, out_features=8, bias=True) (1): ReLU() (2): Linear(in_features=8, out_features=4, bias=True) (3): ReLU() ) (block 2): Sequential( (0): Linear(in_features=4, out_features=8, bias=True) (1): ReLU() (2): Linear(in_features=8, out_features=4, bias=True) (3): ReLU() ) (block 3): Sequential( (0): Linear(in_features=4, out_features=8, bias=True) (1): ReLU() (2): Linear(in_features=8, out_features=4, bias=True) (3): ReLU() ) ) (1): Linear(in_features=4, out_features=1, bias=True)) 参数初始化 内置初始化 下面的代码将所有权重参数初始化为标准差为0.01的高斯随机变量，且将偏置参数设置为0。 12345678def init_normal(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, mean=0, std=0.01) // 也可以给定常数 //nn.init.constant_(m.weight, 1) nn.init.zeros_(m.bias)net.apply(init_normal)net[0].weight.data[0], net[0].bias.data[0] 自定义初始化 12345678910111213def my_init(m): if type(m) == nn.Linear: print(&quot;Init&quot;, *[(name, param.shape) for name, param in m.named_parameters()][0]) nn.init.uniform_(m.weight, -10, 10) m.weight.data *= m.weight.data.abs() &gt;= 5net.apply(my_init)net[0].weight[:2]net[0].weight.data[:] += 1net[0].weight.data[0, 0] = 42net[0].weight.data[0] 参数绑定 在多个层间共享参数 定义一个稠密层，然后使用它的参数来设置另一个层的参数。 123456789101112# 我们需要给共享层一个名称，以便可以引用它的参数。shared = nn.Linear(8, 8)net = nn.Sequential(nn.Linear(4, 8), nn.ReLU(), shared, nn.ReLU(), shared, nn.ReLU(), nn.Linear(8, 1))net(X)# 检查参数是否相同print(net[2].weight.data[0] == net[4].weight.data[0])net[2].weight.data[0, 0] = 100# 确保它们实际上是同一个对象，而不只是有相同的值。print(net[2].weight.data[0] == net[4].weight.data[0]) 共享参数的好处： 共享参数通常可以节省内存，并在以下方面具有特定的好处： 对于图像识别中的CNN，共享参数使网络能够在图像中的任何地方而不是仅在某个区域中查找给定的功能。 对于RNN，它在序列的各个时间步之间共享参数，因此可以很好地推广到不同序列长度的示例。 对于自动编码器，编码器和解码器共享参数。 在具有线性激活的单层自动编码器中，共享权重会在权重矩阵的不同隐藏层之间强制正交。 延后初始化--defers initialization 框架的延后初始化（defers initialization），即等到我们第一次将数据通过模型传递时，才会动态地推断出每个层的大小。 123456import tensorflow as tfnet = tf.keras.models.Sequential([ tf.keras.layers.Dense(256, activation=tf.nn.relu), tf.keras.layers.Dense(10),]) 自定义层 不带参数的层 1234567891011import torchimport torch.nn.functional as Ffrom torch import nnclass CenteredLayer(nn.Module): def __init__(self): super().__init__() def forward(self, X): return X - X.mean() 带参数的层 12345678class MyLinear(nn.Module): def __init__(self, in_units, units): super().__init__() self.weight = nn.Parameter(torch.randn(in_units, units)) self.bias = nn.Parameter(torch.randn(units,)) def forward(self, X): linear = torch.matmul(X, self.weight.data) + self.bias.data return F.relu(linear) 读写文件 加载和保存张量 123456import torchfrom torch import nnfrom torch.nn import functional as Fx = torch.arange(4)torch.save(x, &#x27;x-file&#x27;) 加载和保存模型参数 1234567891011121314151617181920class MLP(nn.Module): def __init__(self): super().__init__() self.hidden = nn.Linear(20, 256) self.output = nn.Linear(256, 10) def forward(self, x): return self.output(F.relu(self.hidden(x)))net = MLP()X = torch.randn(size=(2, 20))Y = net(X)# 存储文件torch.save(net.state_dict(), &#x27;mlp.params&#x27;)# 直接读取文件中存储的参数clone = MLP()clone.load_state_dict(torch.load(&#x27;mlp.params&#x27;))clone.eval() 1234MLP( (hidden): Linear(in_features=20, out_features=256, bias=True) (output): Linear(in_features=256, out_features=10, bias=True)) GPU 计算设备 在PyTorch中，CPU和GPU可以用torch.device('cpu')和torch.cuda.device('cuda')表示。 cpu设备意味着所有物理CPU和内存。这意味着PyTorch的计算将尝试使用所有CPU核心。 gpu设备只代表一个卡和相应的显存。如果有多个GPU 使用torch.cuda.device(f'cuda:&#123;i&#125;')来表示第i块GPU（i从0开始） cuda:0和cuda是等价的。 1234import torchfrom torch import nntorch.device(&#x27;cpu&#x27;), torch.cuda.device(&#x27;cuda&#x27;), torch.cuda.device(&#x27;cuda:1&#x27;) 查询GPU的数量 1torch.cuda.device_count() 请求GPU 12345678910111213def try_gpu(i=0): #@save &quot;&quot;&quot;如果存在，则返回gpu(i)，否则返回cpu()。&quot;&quot;&quot; if torch.cuda.device_count() &gt;= i + 1: return torch.device(f&#x27;cuda:&#123;i&#125;&#x27;) return torch.device(&#x27;cpu&#x27;)def try_all_gpus(): #@save &quot;&quot;&quot;返回所有可用的GPU，如果没有GPU，则返回[cpu(),]。&quot;&quot;&quot; devices = [torch.device(f&#x27;cuda:&#123;i&#125;&#x27;) for i in range(torch.cuda.device_count())] return devices if devices else [torch.device(&#x27;cpu&#x27;)]try_gpu(), try_gpu(10), try_all_gpus() 这两个函数允许我们在请求的GPU不存在的情况下运行代码 张量与gpu 默认情况下，张量是在CPU上创建的。 查询张量所在的设备: 1x.ctx 存储在GPU上 12X = np.ones((2, 3), ctx=try_gpu())X 第二个GPU上创建一个随机张量 12Y = np.random.uniform(size=(2, 3), ctx=try_gpu(1))Y 复制 计算X+Y，可以将X传输到第二个GPU进行操作 123Z = X.copyto(try_gpu(1))print(X)print(Z) 只想在变量存在于不同设备中时进行复制。在这种情况下，我们可以调用as_in_ctx。 如果变量已经存在于指定的设备中，则这不会进行任何操作。除非你特别想创建一个复制，否则选择as_in_ctx方法。 1Z.as_in_ctx(try_gpu(1)) is Z 神经网络与GPU 神经网络模型可以指定设备 12net = nn.Sequential(nn.Linear(3, 1))net = net.to(device=try_gpu()) 小结 我们可以指定用于存储和计算的设备，例如CPU或GPU。默认情况下，数据在主内存中创建，然后使用CPU进行计算。 深度学习框架要求计算的所有输入数据都在同一设备上，无论是CPU还是GPU。 不经意地移动数据可能会显著降低性能。一个典型的错误如下：计算GPU上每个小批量的损失，并在命令行中将其报告给用户（或将其记录在NumPy ndarray中）时，将触发全局解释器锁，从而使所有GPU阻塞。最好是为GPU内部的日志分配内存，并且只移动较大的日志。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"深度学习-9","slug":"深度学习-9","date":"2021-10-03T03:29:43.000Z","updated":"2023-04-26T11:19:54.816Z","comments":true,"path":"posts/25469/","link":"","permalink":"https://ye2222.github.io/posts/25469/","excerpt":"","text":"层和块 单个神经元： 接受一些输入 生成相应的标量输出 具有一组相关参数 参数可以更新以优化某些感兴趣的目标函数 层： 接受一组输入 生成相应的输出 由一组可调整参数描述 使用softmax回归时，一个单层本身就是模型 块： 块可以描述单个层、由多个层组成的组件或整个模型本身。 使用块进行抽象的一个好处是可以将一些块组合成更大的组件，这一过程通常是递归的 块由类表示 它的任何子类都必须定义一个将其输入转换为输出的正向传播函数，并且必须存储任何必需的参数。 注意，有些块不需要任何参数。 最后，为了计算梯度，块必须具有反向传播函数。 自动微分有一些后端实现，只需要考虑正向传播函数和必需的参数。 多层感知机 12345678import torchfrom torch import nnfrom torch.nn import functional as Fnet = nn.Sequential(nn.Linear(20, 256), nn.ReLU(), nn.Linear(256, 10))X = torch.rand(2, 20)net(X) nn.Sequential()定义了一个特殊的Module，即在PyTorch中表示一个块的类。 两个全连接层都是Linear类的实例，Linear类本身就是Module的子类。 正向传播（forward）函数也非常简单：它将列表中的每个块连接在一起，将每个块的输出作为下一个块的输入。 自定义块 块的基本功能： 将输入数据作为其正向传播函数的参数。 通过正向传播函数来生成输出。请注意，输出的形状可能与输入的形状不同。例如，我们上面模型中的第一个全连接的层接收任意维的输入，但是返回一个维度256的输出。 计算其输出关于输入的梯度，可通过其反向传播函数进行访问。通常这是自动发生的。 存储和访问正向传播计算所需的参数。 根据需要初始化模型参数。 12345678910111213class MLP(nn.Module): # 用模型参数声明层。这里，我们声明两个全连接的层 def __init__(self): # 调用`MLP`的父类`Block`的构造函数来执行必要的初始化。 # 这样，在类实例化时也可以指定其他函数参数，例如模型参数`params`（稍后将介绍） super().__init__() self.hidden = nn.Linear(20, 256) # 隐藏层 self.out = nn.Linear(256, 10) # 输出层 # 定义模型的正向传播，即如何根据输入`X`返回所需的模型输出 def forward(self, X): # 注意，这里我们使用ReLU的函数版本，其在nn.functional模块中定义。 return self.out(F.relu(self.hidden(X))) 顺序块--Sequential 两个关键函数： 一种将块逐个追加到列表中的函数 一种正向传播函数，用于将输入按追加块的顺序传递给块组成的“链条”。 12345678910111213class MySequential(nn.Module): def __init__(self, *args): super().__init__() for block in args: # 这里，`block`是`Module`子类的一个实例。我们把它保存在&#x27;Module&#x27;类的成员变量 # `_modules` 中。`block`的类型是OrderedDict。 self._modules[block] = block def forward(self, X): # OrderedDict保证了按照成员添加的顺序遍历它们 for block in self._modules.values(): X = block(X) return X 在__init__方法中，我们将每个块逐个添加到有序字典_modules中。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"操作系统L9","slug":"操作系统L9","date":"2021-09-30T02:10:54.000Z","updated":"2023-04-26T11:19:54.791Z","comments":true,"path":"posts/8675/","link":"","permalink":"https://ye2222.github.io/posts/8675/","excerpt":"","text":"Memory Management 内存管理 理想情况下，程序员需要内存 大 快 非易失性 Memory hierarchy 内存层次结构 少量快速、昂贵的内存 – 缓存 (cache) 一些中速、中等价格的主内存 (main memory) 千兆字节的慢速、廉价磁盘存储 (disk storage) 基本的内存管理：只有操作系统和一个用户进程 第一种方案：操作系统位于RAM的底部，以前被用在大型机和小型计算机 第二种方案：用于一些掌上电脑和嵌入式系统中 第三种方案：用于早期的个人计算机中，在ROM中的系统部分称为BIOS 第一种和第三种方案的缺点是用户程序出现的错误可能摧毁操作系统 不使用存储器抽象的情况下运行多个程序：重定位问题 每个内存块有一个用于标记的4位的保护键，会进行识别，然而会有重定位问题，对于内存地址不正确访问 使用绝对物理地址，造成两个程序同时运行时冲突 可以使用静态重定位技术，给所有的可执行程序提供额外的信息来区别那些内存字中存有可重定位的地址 地址空间 物理地址暴露给进程带来的问题： 如果用户程序可以寻址内存的每个字节，他们就可以很容易的破坏操作系统，从而使系统慢慢地停止运行。除非使用特殊硬件进行保护，如IBM360的锁键模式 使用这种模型，想要同时运行多个程序比较困难 概念 解决问题的关键：保护和重定位 地址空间--新的存储器抽象 是一个进程可用于寻址内存的一套地址集合 每个进程都有自己的一个地址空间，并且这个地址空间独立于其他进程的地址空间 基址寄存器和界限寄存器 使用了动态重定位，简单地把每个进程的地址空间映射到物理内存的不同部分 给每个CPU配置两个特殊硬件寄存器，基址寄存器和界限寄存器 使用这两个寄存器时，程序装载到内存中连续的空闲位置且装载期间无须重定位 定位时，会将进程的地址值加上基址寄存器中的值，同时也会检查程序提供的地址是否大于等于界限寄存器里的值。 缺点：每次访问内存都需要进行加法和比较运算 Multiprogramming with Fixed Partitions 固定分区的多道程序设计 每个分区有单独的输入队列 单个输入队列 由于分区大小是固定的，因此特定作业未使用的任何空间都会丢失。 要说明特定作业需要多大的分区可能并不容易。 Swapping &amp; Virtual Memory 交换和虚拟内存 是克服内存限制的两种方法 交换将进程在内存和磁盘上来回放置。 虚拟内存允许程序运行，即使它们只是部分在主内存中 Swapping 交换在内存中产生了多个空闲区--称为空洞(hole)，这时候可以使用内存紧缩 内存紧缩 memory compaction 通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块 会耗费大量的CPU时间 空闲内存管理 有两种方法跟踪内存使用情况：位图和空闲区链表 Memory Management with Bit Maps &amp; List 使用位图的存储管理 0表示空闲，1表示占用（或者相反） 缺点：在映射中查找连续的 0 位是耗时的 Memory Management with Linked Lists 使用链表的存储管理 链表中的每一个结点都包含以下域 空闲区(H)或进程(P)的指示标志 起始地址 长度 指向下一结点的指针 四种内存管理的算法 First fit 首次适配：从头开始搜索适合的空洞。 Next fit 下次适配：从上次停止的地方搜索适合的空洞。 Best fit 最佳适配：搜索整个列表并取适合的最小空洞。 Worst fit 最差适配：搜索适合的最大空洞。 还有一种叫快速适配(quick fit)的算法，维护一个存储空闲区信息的链表 Virtual Memory 问题：程序太大，放不进内存中去 解决：虚拟内存 -- 操作系统将当前正在使用的程序部分保留在内存中 OS keeps the part of the program currently in use in memory Paging 分页是一种用于实现虚拟内存的技术。 Virtual Address 虚拟地址是程序生成的地址。 MMU (memory management unit)（内存管理单元）将虚拟地址转换为物理地址。 虚拟地址空间(virtual address space)按照固定大小分为(虚拟)页面(pages)，物理内存中对应的为页框(page frames)，页面和页框大小通常是一样的 一个在/不在位跟踪页面是否被映射。 对未映射页面的引用会导致 CPU 陷入操作系统。 这个陷阱被称为页面错误(page fault)。 MMU 选择一个很少使用的页框，将其内容写入磁盘，获取刚刚引用的页面放到刚才回收的页框中，修改映射关系，并重新启动被捕获的指令 Pure paging Page Table 页表 给出的虚拟地址和物理内存地址的关系 用页号作为索引，以得出对应于该虚拟页面的页框号。 “在/不在”位为0，则将引起一个操作系统陷阱 两个主要问题： 虚拟地址空间很大的话，页表也会非常大（例如大多数计算机使用）32 位地址，4k 页大小，12 位偏移 20 位虚拟页号 100 万个条目 映射必须很快，因为它是在每次内存访问时完成的 针对大内存的页表 Multilevel Page Tables 多级页表 减少表大小。 另外，不要将不需要的页表保留在内存中 32位的虚拟地址被划分为 10位的PT1域 10位的PT2域 12位的Offset(偏移量)域 偏移量是12位，所以页面大小为4KB，共有\\(2^{20}\\)个页面 由索引顶级页表得到的表项中含有二级页表的地址或页框号。 顶级页表的表项0指向程序正文的页表，表项1指向数据的页表，表项1023指向堆栈的页表，其他的表项未用 示例 32位虚拟地址：0x00403004（十进制为4206596）位于数据部分12292字节处 它的虚拟地址对应PT1 = 1, PT2 = 3, Offset = 4 首先用PT1作为索引访问顶级页表得到表项1 对应地址范围为4M到8M-1 然后用PT2作为索引访问刚刚找到的二级页表并得到表项3 在他的4M块中的12288~16383 如果该页面在内存中，从二级页表中得到的页框号与偏移量结合形成物理地址 Inverted page table 倒排页表 在这种设计中，实际内存中的每个页框对应一个表项，而不是每个虚拟页面对应一个表项 原因：一个进程对应一个页表，每一个页表中会包含大量的entries 使用倒排页表，一个entry能够对应一个内存中的页框 表项中记录了哪一个（进程、虚拟页面）对定位于该页框 表项： &lt;process-id, page-number&gt; 然后在反转页表中搜索匹配项。 如果找到匹配项 i，则生成物理地址 &lt;i, offset&gt;。 否则，已尝试非法地址访问 虽然减少了存储每个页表所需的内存，但增加了发生页引用时查找表所需的时间 不足：从虚拟地址到物理地址的转换会变得很困难 Page Tables 大多数操作系统为每个进程分配一个页表。 由一组硬件寄存器组成的单页表。 加载进程时，寄存器加载页表。 优点 - 简单 缺点 - 如果表很大并且在每次上下文切换时加载完整页表会损害性能，则代价高昂。 将页表留在内存中——单个寄存器指向表 优点 - 上下文切换便宜 缺点 - 一个或多个内存引用来读取表条目 页表结构 Page frame number 页框号：对应页框号 Present/absent bit 在/不在位：1/0对应有效/无效条目 Protection bit 保护位：允许什么类型的访问，使用三位，读、写、执行。 Modified 修改位：在修改和写入磁盘时设置，记录 Referenced 访问位： 页面被引用时设置（帮助决定要驱逐的页面），记录 Caching disabled 高速缓存禁止位：用于将逻辑上属于磁盘的数据保留在内存中以提高性能 加速分页过程 TLB 观察：大多数程序对少量页面进行大量引用 为计算机配备一个小型硬件设备，称为转换检测缓冲区(Translation Look-aside Buffer，TLB)或关联内存，无需使用页表即可将虚拟地址映射到物理地址。 问题 虚拟地址空间总共大小为：\\(16 * 2048 = 2^{15}B=32KB\\)，所以需要至少15位来标记 Check Points What is the drawback of the bitmap method for free memory management? What is the purpose of virtual memory? What is page table? What is the purpose of using multi-level page table? What is the purpose of using TLB？ What is invert page table？ Solution to find consecutive 0 bits in the map is time-consuming. 在一定程度上缓解内存不足的压力 The relation between virtual addresses and physical memory addresses given by page table reduce the table size. Also, don't keep page tables in memory that are not needed. 加快分页过程 There is one entry for each real page (frame) of memory.","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"深度学习--7","slug":"深度学习-7","date":"2021-09-28T07:06:04.000Z","updated":"2023-04-26T11:19:54.815Z","comments":true,"path":"posts/63469/","link":"","permalink":"https://ye2222.github.io/posts/63469/","excerpt":"","text":"权重衰退 简单地说，就是在损失函数中对权重进行惩罚 使用均方范数作为硬件限制 使用均方范数作为柔性限制 演示 参数更新法则 总结 丢弃法 动机 无偏差的加入噪音 使用丢弃法 推理中的丢弃法 总结 数值稳定性 神经网络的梯度 数值稳定性的常见两个问题 例子 梯度爆炸 梯度消失 总结","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"深度学习--6","slug":"深度学习-6","date":"2021-09-28T06:21:38.000Z","updated":"2023-04-26T11:19:54.811Z","comments":true,"path":"posts/14124/","link":"","permalink":"https://ye2222.github.io/posts/14124/","excerpt":"","text":"模型选择 训练误差和泛化误差 训练误差 模型在训练数据上的误差 泛化误差 模型在新数据上的误差 几个倾向于影响模型泛化的因素 可调整参数的数量。当可调整参数的数量（有时称为自由度）很大时，模型往往更容易过拟合。 参数采用的值。当权重的取值范围较大时，模型可能更容易过拟合。 训练样本的数量。即使你的模型很简单，也很容易过拟合只包含一两个样本的数据集。而过拟合一个有数百万个样本的数据集则需要一个极其灵活的模型。 验证数据集和测试数据集 验证数据集 一个用来评估模型好坏的数据集 例如拿出50%的训练数据 不要跟训练数据混在一起(常犯错误) 测试数据集 只用一次的数据集 例子 未来的考试 出价的房子的实际成交价 用在Kaggle私有排行榜的数据集 K-则交叉验证 没有足够多的数据时使用 算法： 将训练数据分割成K块 For i = 1, ... , K 使用第i块作为验证数据集，其余的作为训练数据集 报告K个验证集误差的平均 常用： K = 5或10 过拟合和欠拟合 模型容量 拟合各种函数的能力 低容量的模型难以拟合训练数据 高容量的模型可以记住所有的训练数据 模型容量的影响 估计模型容量 VC维 线性分类器的VC维 VC维的用处 数据复杂度 总结","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"深度学习-5","slug":"深度学习-5","date":"2021-09-28T02:19:14.000Z","updated":"2023-04-26T11:19:54.813Z","comments":true,"path":"posts/26237/","link":"","permalink":"https://ye2222.github.io/posts/26237/","excerpt":"","text":"感知机 二分类：输出为-1或1 回归输出实数 Softmax回归输出概率 收敛定理 XOR问题 感知机不能拟合XOR函数，只能产生线性分割面 总结 多层感知机 XOR问题 单隐藏层 单分类 隐藏层需要非线性的激活函数 激活函数 Sigmoid激活函数 Tanh激活函数 ReLU激活函数 多类分类 多隐藏层 总结","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"深度学习-4","slug":"深度学习-4","date":"2021-09-28T02:12:12.000Z","updated":"2023-04-26T11:19:54.812Z","comments":true,"path":"posts/42684/","link":"","permalink":"https://ye2222.github.io/posts/42684/","excerpt":"","text":"回归和分类，softmax回归 回归：估计一个连续值 单连续数值输出 自然区间R 跟真实值的区别作为损失 分类：预测一个离散类别 通常多个输出 输出i是预测为第i类的置信度 从回归到多类分类 均方损失 对类别进行一位有效编码 \\(y = [y_1, y_2, y_3, \\ldots, y_n]^T\\) \\(y_i = \\begin{cases} 1, &amp; if\\quad i = y \\\\0, &amp; otherwise\\end{cases}\\) 使用均方损失训练 最大值作为预测 \\(\\hat{y} = argmax{o_i}\\) 需要更置信的识别正确类 校验比例 输出匹配概率（非负，和为1） \\(\\hat{y} = softmax(o)\\) \\(\\hat{y_i} = \\frac{exp(o_i)}{\\sum_{k} exp(o_k)}\\) 概率\\(y和\\hat{y}\\)的区别作为损失 交叉熵 常用来衡量两个概率的区别 \\(H(p, q) = \\sum_i - p_ilog(q_i)\\) 将它作为损失 \\(l(y, \\hat{y}) = - \\sum_i y_ilog(\\hat{y_i})\\) = \\(-log\\hat{y}_y\\) 其梯度是真实概率和预测概率的区别 \\(\\partial_{o_i}l(y, \\hat{y}) = softmax(o)_i - y_i\\) 总结 Softmax回归是一个多类分类模型 使用Softmax操作子得到每个类的预测置信度 使用交叉熵来测量预测和标号的区别作为损失函数 损失函数 L2 Loss \\(l(y, y&#39;) = \\frac{1}{2}(y - y&#39;)^2\\) \\(y:真实值，y&#39;:预测值\\) L1 Loss \\(l(y, y&#39;) = |y - y&#39;|\\) Huber's Robust Loss \\(l(y, y&#39;) = \\begin{cases} |y - y&#39;| - \\frac{1}{2} &amp; if \\quad |y - y&#39;| &gt; 1 \\\\ \\frac{1}{2}(y - y&#39;)^2 &amp; otherwise \\end{cases}\\) 图像分类数据集 MNIST数据集是图像分类中广泛使用的数据集之一，过于简单 使用类似但更复杂的Fashion-MNIST数据集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import torchimport torchvisionfrom torch.utils import datafrom torchvision import transformsfrom d2l import torch as d2limport osos.environ[&quot;KMP_DUPLICATE_LIB_OK&quot;]=&quot;TRUE&quot;d2l.use_svg_display()# 通过框架中的内置函数将Fashion-MNIST数据集下载并读取到内存中# 通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式# 并除以255是的所有像素的数据均在0到1之间trans = transforms.ToTensor()mnist_train = torchvision.datasets.FashionMNIST( root = &#x27;../data&#x27;, train = True, transform = trans, download = False)mnist_test = torchvision.datasets.FashionMNIST( root = &#x27;../data&#x27;, train = False, transform = trans, download = False)def get_fashion_mnist_labels(labels): &#x27;&#x27;&#x27;返回Fashion-MNIST数据集的文本标签&#x27;&#x27;&#x27; text_labels = [ &#x27;t-shirt&#x27;, &#x27;trouser&#x27;, &#x27;pullover&#x27;, &#x27;dress&#x27;, &#x27;coat&#x27;, &#x27;sandal&#x27;, &#x27;shirt&#x27;, &#x27;sneaker&#x27;, &#x27;bag&#x27;, &#x27;ankle boot&#x27;] return [text_labels[int(i)] for i in labels]def show_images(imgs, num_rows, num_cols, titles = None, scale = 1.5): figsize = (num_cols * scale, num_rows * scale) _, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize) axes = axes.flatten() for i, (ax, img) in enumerate(zip(axes, imgs)): if torch.is_tensor(img): ax.imshow(img.numpy()) else: ax.imshow(img)batch_size = 256def get_dataloader_workers(): &quot;&quot;&quot;使用4个进程来读取数据&quot;&quot;&quot; return 4# 为了使我们在读取训练集和测试集时更容易，我们使用内置的数据迭代器# 数据加载器每次都会读取一小批量数据，大小为batch_size。# 我们在训练数据迭代器中还随机打乱了所有样本。train_iter = data.DataLoader(mnist_train, batch_size, shuffle=True, num_workers=get_dataloader_workers())# 读取训练数据所需的时间timer = d2l.Timer()for X, y in train_iter: continueprint(f&#x27;&#123;timer.stop():.2f&#125; sec&#x27;)# 定义 load_data_fashion_mnist 函数 用于获取和读取Fashion-MNIST数据集# 返回训练集和验证集的数据迭代器# 还接受一个可选参数，用来将图像大小调整为另一种形状def load_data_fashion_mnist(batch_size, resize=None): #@save &quot;&quot;&quot;下载Fashion-MNIST数据集，然后将其加载到内存中。&quot;&quot;&quot; trans = [transforms.ToTensor()] if resize: trans.insert(0, transforms.Resize(resize)) trans = transforms.Compose(trans) mnist_train = torchvision.datasets.FashionMNIST(root=&quot;../data&quot;, train=True, transform=trans, download=False) mnist_test = torchvision.datasets.FashionMNIST(root=&quot;../data&quot;, train=False, transform=trans, download=False) return (data.DataLoader(mnist_train, batch_size, shuffle=True, num_workers=get_dataloader_workers()), data.DataLoader(mnist_test, batch_size, shuffle=False, num_workers=get_dataloader_workers()))train_iter, test_iter = load_data_fashion_mnist(32, resize=64)for X, y in train_iter: print(X.shape, X.dtype, y.shape, y.dtype) break","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"操作系统L7","slug":"操作系统L7","date":"2021-09-28T01:42:48.000Z","updated":"2023-04-26T11:19:54.788Z","comments":true,"path":"posts/58722/","link":"","permalink":"https://ye2222.github.io/posts/58722/","excerpt":"","text":"死锁--deadlock 定义：当一组进程中的每个进程都在等待只能由该组中的另一个进程释放的资源时，该组进程（例如）处于死锁状态。 资源--Resource 资源是任何可以在一段时间内获得、使用和发布的东西。是需要排他性使用的对象。 分类： 可抢占资源--preemptable resource 可以从拥有它的进程中抢占而不会产生任何副作用 例如：存储器 不可抢占资源--nonpreemptable resource 是指在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来 涉及可抢占资源的潜在死锁通常可以通过将资源从一个进程重新分配到另一个进程来解决 一个资源所需要的事件顺序： 请求资源--request 使用资源--use 释放资源--release 如果请求被拒绝必须等待 请求的进程可能被阻塞 可能因为错误代码失败 死锁的条件 死锁建模 用圆形表示进程，用方形表示资源 从资源节点到进程节点的有向边代表该资源已被请求、授权并被进程占用 由进程节点到资源节点的有向边表明当前进程正在请求该资源 基本的判断 图中没有环，没有死锁 如果有一个循环 如果一个资源里只有一个实例，那么是死锁 如果一个资源里有多个实例，那么可能没被占用完，可能不是死锁 最简单的解决办法：鸵鸟算法 忽略死锁 死锁发生的很少 维护的花费很高 死锁检测和死锁恢复 使用这种技术时，系统并不视图阻止死锁的产生，而是允许死锁发生，当死锁发生后，采取措施进行恢复 每种类型一个资源的死锁检测 一个简单的算法 对有向图进行检测，并在发现图中有环路存在或确定无环路时结束 每种类型多个资源的死锁检测 提供一种基于矩阵的算法来检测从\\(P_1到P_n\\)这n个进程中的死锁 m为资源的类型数，\\(E_i\\)代表资源类型i E是现有资源向量，代表每种已存在的资源总数；A是可用资源向量 C代表当前分配矩阵，R代表请求矩阵 从死锁中恢复 利用抢占恢复 preemption 从其他一些进程中获取资源 取决于资源的性质 利用回滚恢复 rollback 周期性地对进程进行检查点检查 进程点检查就是将进程的状态写入一个文件以备重启 检查点恢复进程，定期使用此保存状态 如果发现进程陷入僵局，则重新启动进程 通过杀死进程恢复 杀死一个或若干个进程 一种方法：杀掉环中的一个进程 另一种方法：选一个环外的进程作为牺牲品来释放该进程的资源 问题 Check points What is deadlock? A set of processes is in a deadlock state when every process in the set is waiting for a resource that can only be released by another process in the set What is resource in computer? A resource is anything that can be acquired, used, and released over the course of time. What are the four conditions for a deadlock to occur? mutual hold and wait no preemption circular wait How to detect deadlock? One resource of each type：cycle Multi resource of each type: How to recovery from deadlock kill one process preemption rollback","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"numpyL1","slug":"numpyL1","date":"2021-09-28T01:12:58.000Z","updated":"2023-04-26T11:19:54.686Z","comments":true,"path":"posts/26391/","link":"","permalink":"https://ye2222.github.io/posts/26391/","excerpt":"","text":"NumPy NumPy中的ndarray是一个多维数组对象，该对象由两部分组成： 实际的数据； 描述这些数据的元数据。 大部分的数组操作仅仅修改元数据部分，而不改变底层的实际数据 array函数可以依据给定的对象生成数组。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"}]},{"title":"操作系统L2","slug":"操作系统L2","date":"2021-09-28T01:12:58.000Z","updated":"2023-04-26T11:19:54.769Z","comments":true,"path":"posts/59042/","link":"","permalink":"https://ye2222.github.io/posts/59042/","excerpt":"","text":"进程--Process 进程的定义 是一个在运行的程序 是一个容纳运行一个程序所需要的所有信息的容器 进程表--Process table 存储进程的信息 PCB--Process control block UID PID GID 进程树--Process Tree 父进程和子进程 IPC：协作(cooperate)和同步(synchronize)进程的通信称为进程间通信（IPC--Inter Process Connect）。 地址空间--Address Space 一个进程不能看到其他进程的地址空间 同样的地址指针在不同的进程里会指向不同的内存 可以动态地改变映射 进程和程序的不同之处 进程是动态的，程序是静态的。一个进程有一个确定的生命周期，一个程序是一个指令的集合体 一个程序可以同时对应多个进程，通过多个进程来实现一个进程，但是一个进程只能对应一个程序 除了程序代码外，进程还包含运行程序所需的资源。 文件 文件系统--file system 目录--directory 路径--path name 根目录--root directory：是目录 分级的最高端 工作目录--working directory(PWD)：每一个进程有一个当前的工作目录 文件描述符--File descriptor 一个小的整型数字 在可移动介质中装入文件系统。 保护 操作系统的任务：保证文件对于有权限的使用者是可访问的 Shell Shell是一个让使用者能够去接入操作系统服务的一个接口 系统调用 是运行中的程序和操作系统间的接口 比较重要的系统调用 windows系统调用的特点 程序往往是事件驱动的 event-driven Unix和windows系统调用几乎是一一对应的，但是名字不同 one-to-one relationship Windows使用Win32 API去取得OS的服务 Win32 API调用的数量十分巨大，但是不是所有都在内核模式下运行 操作系统结构 单体结构--Monolithic System 所有的操作系统的操作被放入一个单独的文件中 操作系统是过程的集合，每一个都可调用其他的 层次式结构--Layered System 操作系统被组织为进程层的层次结构 The operating system is organized as a hierarchy of layers of processes 微内核--Microkernels 将操作系统分成多个模块，只有一个以内核模式运行，其他的以使用者模式运行 尽可能少地投入到内核模式中，可以提高系统的稳定性 客户端-服务器模式--Client-Server Model 包含两类进程：服务器和客户端。 服务器和客户端之间的通信是通过消息传递完成的。 它是一种可用于单个机器或机器网络的抽象 虚拟机--Virtual Machine 操作系统是提供多道程序设计的分时系统；VM监视器是裸硬件的精确副本， 问题 What are the major tasks of an OS? 通过资源管理，提高系统的使用效率； 改善人机界面，向用户提供友好的工作环境。 What is multiprogramming? 多道程序设计是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 when the system is booted, many processes are running simultaneously, e.g., QQ, WeChat, etc. A computer has a pipeline with 4 stages. Each stage takes the same time to do its work, namely 1 nsec. How many instructions per second can this machine execute? 100000000 - 4 + 1 What is the purpose of a “system call” in an OS? 使得用户可以使用操作系统提供的有关设备管理、输入/输入系统、文件系统和进程控制、通信以及存储管理 资源等方面的功能 What are monolithic system and microkernel? What is a process? A program in execution A container that include the information to run a program","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L6","slug":"操作系统L6","date":"2021-09-26T06:11:23.000Z","updated":"2023-04-26T11:19:54.779Z","comments":true,"path":"posts/9635/","link":"","permalink":"https://ye2222.github.io/posts/9635/","excerpt":"","text":"经典IPC问题 Readers and Writers Problem 读者-写者问题 例如，有一个飞机订票系统，有许多竞争的进程试图读写其中的数据 多个进程同时读数据库是可以接受的 但如果一个进程正在更新(写)数据库，则所有其他进程都不能访问数据库，即使读操作也不行 画作图表示： Solution: 这里的竞争条件是指会同时有多个Reader来修改这个reader变量 例题： Sleeping Barber Problem 没有顾客，理发师睡觉 第一个顾客会叫醒理发师 后面顾客来了之后，会坐下或者离开 Dining Philosophers Problem--哲学家就餐问题 五个哲学家围坐在一张圆桌周围，每个哲学家面前都有一盘通心粉，需要两把叉子才能夹住，相邻两个盘子之间放有一把叉子 两个状态：吃饭和思考 饿了时，分两次去取其左边和右边的叉子，每次拿一把，但不分次序 得到两把则可以吃饭，后继续思考 关键问题：使其不会造成死锁，即不会都在等待拿叉子 错误解法1，会造成死锁： 同时拿起左叉子，都在等待右叉子，陷入等待中 错误解法2： 一个哲学家拿了两把叉子在吃，释放了锁，但是叉子还在使用，当其他哲学家需要这两把叉子中的一把便陷入了等待 正确解法 例子 Monitor 监视器是一组过程、变量和数据结构，一次只能由一个进程访问（出于互斥目的）。 为了允许进程在监视器内等待，必须声明一个条件变量（condition variable） 条件变量只能与操作wait 和signal 一起使用（用于同步目的） x.wait():意味着调用此操作的进程被挂起，直到另一个进程调用 x.signal():x.signal 操作会恢复了一个挂起的进程。 如果没有进程被挂起，则信号操作无效 例子： 优点：易于编程 缺点：应用昂贵 Monitor和Semaphores的对比 监视器中条件变量的等待和信号操作类似于计数信号量的 P 和 V 操作。 wait 语句可以阻塞一个进程的执行，而一个signal 语句可以导致另一个进程被解除阻塞。 不同之处： 当进程执行P操作时，它不一定会阻止该进程，因为计数信号量可能大于零。相反，当执行wait语句时，它总是阻塞进程 当任务对信号量执行V操作时，它要么取消阻止等待该信号量的任务，要么在没有要解锁的任务时增加信号量计数器。另一方面，如果一个进程在没有其他进程取消阻塞时执行signal语句，则对条件变量没有影响 信号量和监视器之间的另一个区别是，被V操作唤醒的用户可以毫不延迟地恢复执行。相反，被signal操作唤醒的用户只有在监视器解锁时才会重新启动 Message Passing 为每个进程分配一个唯一的地址,然后直接向进程发送消息 消息传递通常用于并行编程系统。 Message Passing API 消息传递适用于： 同一台计算机内的进程。 网络化/分布式系统中的进程 Synchronization in message passing 消息传递中的同步 消息传递可能是堵塞或者不堵塞的 阻塞(Blocking)被认为是同步（synchronous）的 阻止发送(Blocking send)会阻止发送方，直到收到消息 阻塞接收(Blocking receive)会阻塞接收器，直到消息可用 非阻塞(Non-blocking)被认为是异步(asynchronous)的 非阻塞发送(non-blocking send)让发送方发送消息并继续 非阻塞接收(non-blocking receive)使接收器接收到有效消息或空 Sender:发出send后不被阻止更自然 可以向多个目的地发送多条消息。 但发送方通常期望收到消息确认（在接收方失败的情况下） Receiver: 发出receive后不被阻塞 接受者通常在继续之前需要这些信息。 但如果发送方进程无法发送，则可能被无限期阻止。 还有一些其他的方法：blocking send, blocking receive 总结，有三种组合 Blocking send, Blocking receive; Nonblocking send, Nonblocking receive; Nonblocking send, Blocking receive – most popular 问题 Check points What is Race Condition? What is Critical Region? What is IO-bound process? What is Turnaround time? What is the drawback of the SJF algorithm? What is the advantage of RR scheduling? What is condition variable in monitor? What are the two operations in monitor","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统L4","slug":"操作系统L4","date":"2021-09-26T03:44:24.000Z","updated":"2023-04-26T11:19:54.780Z","comments":true,"path":"posts/58402/","link":"","permalink":"https://ye2222.github.io/posts/58402/","excerpt":"","text":"进程间通信--Inter Process Communication 三个问题 一个进程如何把信息传递给另一个 pass information among processes 确保两个或者更多的进程在Critical Region中不会出现交叉 get into each other's way 存在依赖关系时的正确排序（如果该顺序是有关联的话） 第一个问题：共享一个地址空间 竞争条件--Race Conditions 两个或多个进程读写某些共享数据，而最后的结果取决于操作的顺序 随着内核数量的增加导致并行性的增加，竞争条件变得越来越普遍。 临界区--Critical Region 避免竞争条件的关键：禁止超过一个进程同时对共享数据进行读取和写入，即互斥 临界区：对共享内存进行访问的程序片段 满足4个条件的一个解决方案： 任何两个进程不能同时(simultaneously)处于其临界区 不应对CPU的速度和数量做任何假设 临界区外运行的进程不得阻塞其他进程 不得使进程无限期等待进入临界区 忙等待的互斥--Mutual Exclusion Solution mutux：互斥量 实现互斥的几种方案 屏蔽中断--Disabling Interrupts 使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断 屏蔽中断后，时钟中断也被屏蔽 CPU只有发生时钟中断或其他中断后才会进行进程切换，屏蔽中断后，CPU将不会被切换到其他进程 缺点 一个线程可能一直不会打开中断 多处理器系统中，屏蔽了一个CPU，其他CPU仍然能继续运行，可以访问共享内存 锁变量--Lock Variable 设置一个共享锁变量，其初始值为0 当一个进程想进入其临界区时，首先测试这把锁 当锁值为0，则该进程将其设置为1并进入临界区 当锁值为1，则进程等待直到其值变为0 疏漏 一个进程发现锁值为0，恰好将值设置为1之前，另一个进程被调度运行，将锁值变为1，当第一个进程再次运行，同样也将该锁设置为1，此时同时有两个进程进入临界区 严格轮换法--Strict Alternation 整形变量turn，初始值为0，用于记录哪个进程进入临界区，检查或更新共享内存 开始时，进程0检查turn，发现其值为0，进入临界区 进程1也发现其值为0，在一个等待循环中不断地测试turn，看其值何时变为1 连续测试一个变量直到某个值出现为止，称为忙等待（busy waiting） 浪费CPU时间。应避免 用于忙等待的锁，称为自旋锁（spin lock） 一个进程比另一个慢了许多的情况下，轮流进入临界区不是一个好办法 Peterson解法 将锁变量与警告变量的思想结合，提出一个不需要严格轮换的软件互斥算法 TSL指令 需要硬件支持 复制内存中的一个值（flag）到CPU的寄存器中，将这个值设为1 Mutual Exclusion with Busy Waiting Busy-Waiting: 执行代码的进程将处于紧密循环中，占用 CPU 周期，一遍又一遍地测试某些条件，直到它变成真的。 忙等待可能导致优先级倒置问题 睡眠与唤醒 优先级反转问题--priority inversion problem,忙等待问题会导致这个问题 设置了两个参数：sleep、wakeup sleep:一个将引起调用进程阻塞的系统调用，即被挂起 wakeup:有一个参数，指定要被唤醒的进程 Producer-Consumer Problem 生产者-消费者问题 考虑一个可以容纳N个项目的循环缓冲区。 生产者将项目添加到缓冲区，消费者从缓冲区中删除项目 生产者消费者问题是限制对缓冲区的访问 Semaphores 信号量 首先要知道，信号量有两种 一种用于互斥，防止同时访问一些变量 一般初始化为1，表示只有一个进程可以进入 一种用于同步，用于通知其他的进程。 一般初始化为0，有人释放，增加1，就可以被其他的进程检测知道 举一个简单例子：放水果给孩子吃，有两种水果：苹果和梨子，一次只能放一个 放水果这个行为限定了次数，因此用互斥的信号量，防止放多个 孩子吃到水果，则使用同步的信号量，我放了一个苹果，通知他可以吃了 信号量是一种结构，包含两个部分 COUNT，一个用于计数的整数 Q，阻塞的进程的pid的队列 123456struct sem_struct &#123; int count; queue Q;&#125; semaphore;semaphore S; 信号量的操作 UP DOWN 这些操作必须原子性地执行(即互斥)。 假设P是进行系统调用的进程，操作定义为 1234567891011121314151617DOWN(S): if (S.count &gt; 0) S.count = S.count - 1; else block(P); /*that is, (a) enqueue the pid of P in S.Q, (b) block process P (remove the pid from the ready queue) (c) pass control to the scheduler*/UP(S): if (S.Q is nonempty) wakeup(P) /*for some process P in S.Q; that is, (a) remove a pid from S.Q (the pid of P), (b) put the pid in the ready queue, and (c) pass control to the scheduler.*/ else S.count = S.count + 1 Semaphores do not require busy-waiting, instead they involve BLOCKING 1234semaphore mutex = 1; // set mutex.count = 1DOWN(mutex); - critical section -UP(mutex); Mutexes 互斥量 A mutex is a semaphore that can be in one of two states: unlocked (0) or locked (1) 互斥量是一种信号量，有两种状态：unlocked (0) （临界区可用）和 locked (1) 信号量解决生产者消费者问题 使用信号量 进程同步(Synchronization) 同步时的信号量初始化为0，当优先级高的进程执行完毕后，便会释放，即增加1。 例题 Check Points What is Race Condition? What is Critical Region? What is Busy Waiting? What is Semaphore? What is Mutex Solution Two or more processes access shared resourse and the final result depend on the order of the process The program that access the shared resourse The process is running the program over and over again until some condition become true, the CPU is keep running a process executing the entry code will sit in a tight loop using up CPU cycles, testing some condition over and over, until it becomes true A SEMAPHORE, S, is a structure consisting of two parts: (a) an integer counter, COUNT (b) a queue of pids of blocked processes, Q A kind of semaphore that has two status: locked and unlocked","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计网L5","slug":"计网L5","date":"2021-09-25T08:19:07.000Z","updated":"2023-04-26T11:19:54.837Z","comments":true,"path":"posts/5612/","link":"","permalink":"https://ye2222.github.io/posts/5612/","excerpt":"","text":"DLL--数据链路层 数据链路层使用物理层提供的服务在通信信道上发送和接收比特。 数据链路层从网络层获得数据包（package），然后将这些数据包封装成帧（frame ）以便传输。 每个帧包含一个帧头(Header)、一个有效载荷(Payload field)（用于存放数据包〉以及一个帧尾(Trailer) 实现两个相连机器稳定有效的交流(reliable, efficient communication) 主要功能 为网络层提供定义好的服务接口 处理传输错误 规定数据流，这样处理较慢的接受机器不会被淹没 DLL提供的服务 数据链路层提供了许多种服务，实际上提供的服务在系统间存在差异 三种常见的服务 Unacknowledged connectionless service. 无确认的无连接服务 指源机器向目标机器发送独立的帧，目标机器并不对这些帧进行确认 采用这种服务，事先不需要建立逻辑连接，事后也不用释放逻辑连接。 若由于线路的噪声而造成了某一帧的丢失，数据链路层并不试图去检测这样的丢帧情况，更不会去试图恢复丢失的帧。 使用场合 错误率很低的场合 实时通信 Acknowledged connectionless service. 有确认的无连接服务 数据链路层仍然没有使用逻辑连接，但其发送的每一帧都需要单独确认。 发送方可知道一个帧是否已经正确地到达目的地。如果一个帧在指定的时间间隔内还没有到达，则发送方将再次发送该帧。 适用于不可靠的信道 不要求这种确认服务由数据链路层实现。 Acknowledged connection-oriented service. 有确认的面向连接服务 建立了两个机器的连接，帧可以传输 在连接发送的每一个帧是编号的(numbered)和确认的(acknowledged) 帧保证仅按顺序到达一次(Only once and in order)。 一旦通信完成，就会释放连接。 这与“可靠”比特流相同。 例子：两个路由间的数据流动 路由：1）通过网络传输信息 2）确定最佳路径 Frame--帧 为了向网络层提供服务(use the service)，数据链路层必须使用物理层提供的服务。 物理层只能在传输介质上放置原始比特流(use the service)。 位流不保证没有错误。 数据链路层负责检测并在必要时纠正错误。 成帧 DDL 能够将位流分解为离散的帧(break up the bit stream into discrete frames)。 计算每个帧的校验和，当帧到达目的地时重新计算校验和。 将比特流分解成帧有点困难。 时间间隔 我们需要看看其他表示帧开始和结束的方法。 四种成帧的方法 Character count（字符计数法） 使用帧头中的字段来指定帧中的字符数 缺点：出现错误后，找不到下一帧的正确起始位置，重传也不知道从哪里开始 Flag bytes with byte stuffing（带字节/字符填充的分界符法） 使用一些特殊的字节作为开始和结束，通常都相同，成为标志字节(flag byte) 使用了两个连续的标志字符代表了一帧的结束和下一帧的开始 问题1：如果标志字节出现在数据中，会干扰到帧的分界 解决：添加转义字节，接收方的数据链路层在将数据传递给网络层之前必须删除转义字节，称为字节填充 问题2：如果转义字节也出现在数据中，怎么办 解决：同样用字节填充。用一个转义字节来填充 缺点：只能使用8比特的字节 Starting and ending flags, with bit stuffing（带位填充的分界标志法） 帧的划分可以在比特级完成 每个帧的开始和结束由一个特殊的比特模式标记，如01111110或者十六进制0x7E 这种模式是一个标志字节。每当发送方的数据链路层在数据中遇到连续五个1 ，它 便自动在输出的比特流中填入一个比特 。 比特填充还确保了转换的最小密度，这将有助于物理层保持同步。 Physical layer coding violations（物理层编码违例法） 使用物理层的捷径 比特编码成信号通常包括一些冗余比特，以便帮助接收器同步接收。这种冗余意味着一些信号将不会出现在常规数据中。 例如，在 4B/5B 线性编码模式下， 个数据位被映射成 个信号比特，通过这种方法确保线路上的信号有足够的跳变。这意味着 32 个可能的信号中有 16 个是不会被使用的。 可以使用保留的信号来指示帧的开始和结束 大多数 DLL 协议将字符计数与另一种方法结合使用以提高安全性。 这增加了发现错误的机会。 差错控制--Error Control 我们使用字节填充、位填充和校验和作为检测和确定我们发送的数据中的错误的方法。 我们还必须确保帧能够到达目的地。 接收器发回一个控制帧(control frame)，确认接收到的帧和帧的状态。 如果确认没有到达，可能会发生超时，导致帧被重新发送。 超时间隔 重新发送帧也会导致问题——当同一帧被接收两次或更多次时会发生什么？ 我们还可以对帧进行顺序编号(sequentially number the frames)以防止出现此问题。 有许多不同的方法可以进行这种类型的错误控制（也可以在不同的级别上进行）。 管理定时器和序列号是数据链路层职责的重要部分。 流量控制--Flow Control 我们必须处理发送方以高于接收方接收数据的速率发送数据的问题。 有两种方法可以解决这个问题： 基于反馈的流量控制 -- feedback-based flow control 反馈用于告诉发送方接收方正在做什么或发送另一个帧 基于速率的流量控制 -- rate-based flow control 传输速率由发件人固定 这从未在 DLL 中使用过 Why do we need Error Detection And Correction? 本地环路仍然是模拟双绞线，错误仍然很常见。 无线通信正变得越来越普遍，错误率比局间光纤干线上的差几个数量级。 传输错误将伴随我们很多年。 Types of Error 错误的类型 错误突然出现 Burst errors 独立的单位错误 Independent single-bit errors 例子 块大小为 1000 位 错误率为每比特 0.001 突发错误比孤立错误更难纠正 错误处理--Error Processing 这两种技术中的每一种都适用于不同的情况 Error-correcting codes 纠错码 在发送的每个数据块中包含足够的冗余信息。 接收机可以推断发送的数据 纠错码的使用通常被称为前向纠错(前向纠错). 开销很高，但它减少了重新发送帧的需要。 最适合高误差（无线）网络 Error-detecting codes 检错码 只包含足够的冗余 允许接收方推断出发生了错误，但不更正错误，只让它请求重新传输。 适用于高可靠性信道(highly reliable channel)，如光纤 只要在发现错误时重新传输即可 Hamming code 汉明码 纠错码位数：r 数据位数：m 例子： 获得汉明码 问题：Original data: 10101111,even-parity Hamming code 偶校验汉明码, if hope to correct one single error, What is the Hamming code for it? 解法：m = 8， 根据公式 \\((m+r+1) \\le 2^r\\)得到\\(r = 4\\) 12 11 10 9 8* 7 6 5 4* 3 2* 1* 1100 1011 1010 1001 1000 0111 0110 0101 0100 0011 0010 0001 1 1 1 1 0 1 0 1 计算校验位用在相应位置上为1的数进行异或 P1：\\(B1 \\oplus B3 \\oplus B5 \\oplus B7 \\oplus B9 \\oplus B11 = 1\\) 同理： P2：0 P3：0 P4：0 这里自己位置设置为0，检验的时侯计算这些位置做异或运算一定得等于0 所以汉明码为101001001111 利用汉明码检测错误 收到一个代码为100110001100（m = 8, r = 4） 这个代码是否正确，如果错了该改正哪里 12 11 10 9 8* 7 6 5 4* 3 2* 1* 1100 1011 1010 1001 1000 0111 0110 0101 0100 0011 0010 0001 0 0 1 1 0 0 0 1 1 0 0 1 P1：\\(B1 \\oplus B3 \\oplus B5 \\oplus B7 \\oplus B9 \\oplus B11 = 1\\) 同理： P2：1 P3：0 P4：0 0011是第三个位置出现了错误，改为相反数 即101110001100 Error Detection 错误检测代码仅包含足够的数据，以便接收器确定数据是否有故障。 如果物理链路的错误率更低，则错误检测和重传通常更有效。 铜线或光纤 为了比较，考虑错误率为每比特\\(10^{-6}\\)的信道。让块大小为1000bits。 要纠正单个错误（通过汉明码），每个块需要10个校验位。要传输1000个块，需要10000个校验位（开销）。 要检测单个错误，每个块一个奇偶校验位就足够了。为了传输1000个块，只需重新传输一个额外的块（由于每比特的错误率为\\(10^{-6}\\)），从而产生开销(开销） 只有2001（=1000*1+1001）位。 Polynomial Code(多项式编码) Also known as a CRC (Cyclic Redundancy Check，循环冗余校验码). 基于将位字符串视为系数为0和1的多项式的表示 例子：110001 6项5阶多项式 \\(1\\times x^5+1\\times x^4+0\\times x^3+0\\times x^2+0\\times x^1+1\\times x^0 = x^5+x^4+1\\) 多项式运算是模2(modulo 2)完成的。加法和减法都与异或相同(等同于异或） EXCLUSIVE OR What is modulo 2？ Modulo 2 addition &amp; substraction: XOR logic ​ CRC方法的基本思想是： 发送方和接收方提前就在生成多项式(generator polynomial)上达成一致, G(x)。 发送方在帧的末尾追加校验和(checksum)，校验和帧表示的多项式可以被G(x)整除。 当接收器获得帧时，它会尝试将其除以相同的G(x)。如果有余数，则一定是发生了错误，并将请求重新传输。 计算校验和 r：G(x)的维度 添加r个零位到帧的低阶端，使其现在包含m+r位，并对应于多项式\\(x^rM(x)\\)。 使用模2除法将对应于\\(G(x)\\)的位字符串划分为对应于\\(x^rM(x)\\)的位字符串。 使用模2减法从与\\(x^rM(x)\\)对应的位字符串中减去余数（始终为r或更少的位）。 结果是要传输的校验和帧。称其为多项式\\(T(x)\\)。 例子","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"计网L4","slug":"计网L4","date":"2021-09-23T01:05:29.000Z","updated":"2023-04-26T11:19:54.833Z","comments":true,"path":"posts/54573/","link":"","permalink":"https://ye2222.github.io/posts/54573/","excerpt":"","text":"Structure of the Telephone System PSTN (Public Switched Telephone Network) 公共交换电话网络 Fully-interconnected network. Centralized switch. Two-level hierarchy. 一个典型的电话电路 Components of the Telephone System local loops 本地回路 用于家庭和企业的模拟双绞线 传输线有三个主要的问题： 衰减 Attenuation 延迟失真 Delay distortion 噪声 Noise 数字信号中使用的方波具有很宽的频谱（通常是高频），因此会受到很强的衰减和延迟失真。 Modems 调制解调器 使用模拟和数字传输进行计算机到计算机的呼叫。 转换由调制解调器(Modems)和编解码器(codecs)完成。 调制解调器（调制器-解调器）是将输出数字信号调制为模拟信号的设备。 Amplitude：两种不同的振幅表示0和1 Frequency：使用不同的频道 Phase：波形是平移的 事项： 数据元素：bit 数据速率：bits/s 信号元素：signal 信号速度：signal/s 基本的编码技术： 数字信号到模拟信号 ASK--Amplitude-shift keying FSK--Frequency-shift keying PSK--Phase-shift keying baud 波特 每秒的采样数/符号数以波特为单位。 QPSK 四相/正交相移键控 quadrature phase-shift keying 四个角度通常相差90°，用于传输2位/符号。比特率是波特率的两倍。 QAM-64 正交幅度调制正交幅度调制-64 Quadratrue Amplitude Modulation 允许64种不同的组合，因此每个符号可以传输16位。 连接通向 full duplex: 全双峰 双向 half duplex：半双峰 允许双向，一次只能一个方向 simplex: 单峰 单向 Trunks and Multiplexing 多路复用 两类多路复用方案用于在单个物理中继上多路复用多个会话 FDM (Frequency Division multiplexing) 在频分复用（FDM）中，频谱被划分为多个频带。对于光纤信道，使用WDM（波分复用）(Wavelength Division Multiplexing)。 TDM (Time Division Multiplexing) 在TDM（时分多路复用）中，整个带宽用于一段时间段。 FDM WDM TDM Switching 交换 电路交换 寻找从发送方到接收方的物理路径。在发送数据之前，必须（概念上）建立端到端路径。 消息交换 没有预先建立路径。消息存储在第一个交换局中，然后一次转发一个跃点。 数据包交换 对数据块大小进行限制，以允许数据包在交换办公室的主内存中进行缓冲。 Second Generation Mobile Phones: Digital Voice CDMA: Code Division Multiple Access 码分多址 在有很多人交谈的机场休息室里： TDMA：轮流发言 FDMA：人们在分散的群体中，每个群体都有自己的对话 CDMA：同时通话，但每对使用不同的语言 CDMA 的关键是能够提取所需的信号，同时将其他一切作为随机噪声拒之门外。 在CDMA中，每个比特时间被细分为m个称为码片(chips)的短间隔。 通常，每比特有 64 或 128 个码片。 每个站都分配有一个唯一的 m 位代码，称为码片序列(chip sequence)。 为了传输 1 ，它发送它的码片序列。 为了传输 0 ，它发送其码片序列的 1 的补码。 过程 首先，给每个站分配到的chip sequence二极化，0为-1, 1为1 然后，给出几个例子，查看是否与C站有关 +：直接相加 \\(\\bar{c}\\)：直接取反 四个站的二进制码片序列 Bipolar chip sequences 传输的六个例子 C站信号的恢复 Communication Satellites 通讯卫星 卫星就像天空中的大型微波中继器 包含转发器：收听频谱的某些部分，放大信号，然后以另一个频率重新广播（以避免干扰传入信号） 卫星越高，轨道周期越长 种类 GEO（地球静止轨道）卫星： 每颗卫星通常都有多个向下波束，聚焦于称为点波束的小地理区域（如南非）。 用于电视（例如 DSTV） MEO（中地球轨道）卫星： 24 颗卫星用于 GPS（全球定位系统）。 不用于电信。 LEO（低地球轨道）卫星： Iridium &amp; Globalstar：用于全球卫星电话（船舶、农村地区等）的卫星系统。 Teledesic：用于互联网用户，完全绕过电话系统（空间分组交换） GEO GEO 卫星需要更多电力进行通信 由于所涉及的距离，GEO 的信噪比更差 几个 GEO 可以覆盖地球的大部分表面 请注意，GEO 无法“看到”极地地区 由于它们看起来是静止的，GEO 不需要跟踪 GEO 有利于广域广播 Major problems for satellites 主要问题 Positioning in orbit 位置 一种方法是使用小型火箭发动机 这些使用燃料——大多数卫星重量的一半以上是由燃料组成的 通常是燃料可用性决定了卫星的寿命 卫星的商业寿命通常为 10-15 年 Stability 健壮性 卫星稳定很重要 确保太阳能电池板正确对齐 确保通信天线正确对齐 早期卫星使用自旋稳定 这要么需要一个低效的全向天线 或者天线精确地反向旋转以提供稳定的通信 现代卫星使用反作用轮稳定——一种陀螺稳定的形式 Power 能源 现代卫星使用多种动力方式 太阳能电池板现在效率很高，所以太阳能被用来发电 有时需要电池，因为有时卫星在地球后面——这发生在 LEO 卫星的一半左右 核电已被使用 Communications 交流 卫星也可以与其他卫星通信 通信可以通过微波或光学激光 Harsh environment 恶劣的环境 卫星组件需要特别“硬化” 在地面上工作的电路在太空中会很快失效 温度也是一个问题——所以卫星使用电加热器来保持电路和其他重要部件的温度——它们还需要小心地控制温度 有许多组件需要对齐 太阳能板 触角 这些必须在不同的时间指向天空的不同部分，所以问题并不简单 LEO 低地球轨道卫星 - 比如说 100 - 1500 英里 LEO 的信噪比应该更好 更短的延迟 - 通常在 1 - 10 ms 之间 由于 LEO 相对于地球移动，因此它们需要跟踪 轨道 Orbit 圆形轨道是最简单的 倾斜轨道可用于覆盖赤道地区 椭圆轨道可用于提供从地球看的准静止行为 通信卫星与其他传输媒体相比具有许多优势。 通信卫星有GEO、MEO和LEO三种类型，分别部署不同的目标。 不同的频段被划分并用于各种场合。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"操作系统L5","slug":"操作系统L5","date":"2021-09-18T02:48:45.000Z","updated":"2023-04-26T11:19:54.778Z","comments":true,"path":"posts/9443/","link":"","permalink":"https://ye2222.github.io/posts/9443/","excerpt":"","text":"Process Behavior--进程行为 几乎所有进程都会交替使用I/O请求进行计算 CPU-bound：计算密集型 花费大量时间在计算上 IO-bound：I/O密集型 在等待I/O上花费了绝大多数时间 Process Scheduling--进程调度 Scheduler--调度程序 决定接下来要运行哪一个进程，是操作系统的一部分 Scheduling Algorithm--调度算法 调度程序用于做出该决定的策略 为了确保进程不会运行太长时间，使用时钟来引起周期性中断（通常在50-60 Hz左右）；也就是说，大约每20毫秒。 Preemptive Scheduling--抢占式调度 允许暂时挂起可运行的进程（将其变为ready状态），以便其他进程有机会使用CPU 什么时候进行调度 当一个新的进程被创建 当一个进程退出 当一个进程阻塞在I/O 在一个I/O中断发生时 Scheduling Algorithm Goals Fairness Efficiency Response Time Turnaround Time 周转时间 从提交批处理工作到完成的平均时间 Throughput 吞吐量 每小时处理工作的数量 FCFS Scheduling 先来先服务 First-Come, First Served 按顺序来 SJF Scheduling 最短作业优先 Shortest-Job-First 与每个进程关联其下一个CPU突发的长度。选取最短的运行 缺点：确定下一个CPU请求的长度上有困难 有两种模式： nonpreemptive 非抢占 一旦CPU给到进程，除非计算完成，否则其他进程不能抢占 preemptive 抢占 若新进程到达时，且新进程的CPU占用时长小于当前执行进程的剩余时间，则抢占。 这一模式称为SRTF ( Shortest-Remaining-Time-First) 最短剩余时间优先 SJF是最优的–为给定的一组进程提供最小的平均等待时间。 非抢占 抢占 RR Scheduling 轮转调度 Round Robin 每个进程被分配一个时间段，称为时间片，允许该进程在该时间段中运行 所有进程都在等待队列中，切换后，原来的进程会进入到等待队列的末尾 通常，平均周转率高于SJF，但响应更好。 时间片 时间片设得太短会导致过多的进程切换，降低了CPU效率 时间片设得太长可能引起对短的交互请求的响应时间变长。 将时间片设为20~50ms是一个比较合理的折中 Priority Scheduling 优先度调度 给每一个进程一个优先级，允许优先级最高的可运行进程先运行 CPU会分配给优先级最高的进程 SJF就是一种优先级调度，优先级就是预测的下一个CPU突发时间 缺点： Starvation：低优先级的进程永远不会运行 解决：随着时间增加进程的优先级 更多的调度 Shortest Process Next 通过根据过去的行为估计运行时间来在交互式环境中使用 a T0 + (1-a) T1 其中 T0 是前一次估计，T1 是当前运行时间。 Guaranteed Scheduling Lottery Scheduling Fair-Share Scheduling Thread Scheduling 进程调度的算法也可以用于在线程调度中。 在实践中，轮流调度和优先级调度是常用的。 用户级线程和内核级线程 用户级线程和内核级线程的主要区别在于性能。 用户级线程可以采用特定于应用程序的线程调度器 问题 Check points What is IO-bound process? When to schedule processes? What are the goals of Scheduling algorithms? What is the drawback of the SJF algorithm? What is RR scheduling Solution Cost most time for waiting I/O 4个 新进程建立 进程删除 进程阻塞在I/O I/O中断 5个 Fairness Effcient Respond time Turnaround time Throughput 可能会造成优先级问题 分发给每一个进程一个固定的时间片，进行不断地切换","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"深度学习-3","slug":"深度学习-3","date":"2021-09-15T06:10:37.000Z","updated":"2023-04-26T11:19:54.810Z","comments":true,"path":"posts/25853/","link":"","permalink":"https://ye2222.github.io/posts/25853/","excerpt":"","text":"线性模型 衡量预估质量 训练数据 参数学习 显示解（只有线性回归有） 总结 基础优化方法 ​ - 梯度下降 ​ - ​ - 梯度是下降最快的地方 ​ - 学习率的选择 ​ - 不能太小，也不能太大 ​ - ​ - 小批量随机梯度下降 ​ - ​ - 选择批量大小 ​ - 总结 从零开始实现线性回归 自己构建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import osimport randomimport torchfrom d2l import torch as d2limport matplotlib os.environ[&#x27;KMP_DUPLICATE_LIB_OK&#x27;] = &#x27;TRUE&#x27;# y = Xw + b + e# 根据带有噪声的线性模型构造一个的人造数据集def synthetic_data(w, b, num_examples): # 均值为0，方差为1，大小 X = torch.normal(0, 1, (num_examples, len(w))) y = torch.matmul(X, w) + b y += torch.normal(0, 0.01, y.shape) # 加入噪音 return X, y.reshape((-1, 1)) # 做成一个列向量返回# 接受批量大小、特征矩阵和标签向量作为输入# 输出大小为batch_size的小批量def data_iter(batch_size, features, labels): num_examples = len(features) indices = list(range(num_examples)) # 样本是随机读取的，没有特定的顺序 random.shuffle(indices) for i in range(0, num_examples, batch_size): batch_indices = torch.tensor( indices[i:min(i + batch_size, num_examples)]) yield features[batch_indices], labels[batch_indices]true_w = torch.tensor([2, -3.4])true_b = 4.2features, labels = synthetic_data(true_w, true_b, 1000)# 查看特征和标签的相关性# d2l.set_figsize()# d2l.plt.scatter(features[:, 1].detach().numpy(),# labels.detach().numpy(), 1)# d2l.plt.show()batch_size = 10# 定义初始化模型参数w = torch.normal(0, 0.01, size=(2, 1), requires_grad=True)b = torch.zeros(1, requires_grad=True)# 定义模型def linreg(X, w, b): &#x27;&#x27;&#x27;线性回归模型&#x27;&#x27;&#x27; return torch.matmul(X, w) + b# 定义损失函数def squared_loss(y_hat, y): &#x27;&#x27;&#x27;均方损失&#x27;&#x27;&#x27; return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2# 定义优化算法def sgd(params, lr, batch_size): &#x27;&#x27;&#x27;小批量随机梯度下降&#x27;&#x27;&#x27; with torch.no_grad(): for param in params: param -= lr * param.grad / batch_size param.grad.zero_()# 训练过程lr = 0.03 # 学习率num_epochs = 3net = linregloss = squared_lossfor epoch in range(num_epochs): for X, y in data_iter(batch_size, features, labels): l = loss(net(X, w, b), y) # x和y的小批量损失 # 因为l形状是（batch_size, 1），而不是一个标量。 # l中的所有元素被加到一起 # 并以此计算关于[w, b]的梯度 l.sum().backward() sgd([w, b], lr, batch_size) with torch.no_grad(): train_l = loss(net(features, w, b), labels) print(f&#x27;epoch &#123;epoch + 1&#125;, loss &#123;float(train_l.mean()):f&#125;&#x27;) 使用模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import numpy as npimport torch from torch.utils import datafrom d2l import torch as d2ltrue_w = torch.tensor([2, -3.4])true_b = 4.2features, labels = d2l.synthetic_data(true_w, true_b, 1000)def load_array(data_arrays, batch_size, is_train=True): &#x27;&#x27;&#x27;构造一个PyTorch的数据迭代器&#x27;&#x27;&#x27; dataset = data.TensorDataset(*data_arrays) return data.DataLoader(dataset, batch_size, shuffle=is_train)batch_size = 10data_iter = load_array((features, labels), batch_size)next(iter(data_iter))# 使用框架的预定义好的层# &#x27;nn&#x27;是神经网络的缩写from torch import nnnet = nn.Sequential(nn.Linear(2, 1)) # 输入二维，输出一维# 初始化模型参数net[0].weight.data.normal_(0, 0.01)net[0].bias.data.fill_(0)# 均方误差loss = nn.MSELoss()# SGDtrainer = torch.optim.SGD(net.parameters(), lr=0.03)num_epochs = 3for epoch in range(num_epochs): for X, y in data_iter: l = loss(net(X), y) trainer.zero_grad() l.backward() trainer.step() l = loss(net(features), labels) print(f&#x27;epoch &#123;epoch + 1&#125;, loss &#123;l:f&#125;&#x27;)","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"深度学习-1","slug":"深度学习-1","date":"2021-09-15T06:10:33.000Z","updated":"2023-04-26T11:19:54.804Z","comments":true,"path":"posts/42364/","link":"","permalink":"https://ye2222.github.io/posts/42364/","excerpt":"概述","text":"概述 学习内容： - 深度学习基础--线性神经网络，多层感知机 - 卷积神经网络--LeNet，AlexNet，VGG，Inception，ResNet - 循环神经网络--RNN，GRU，LSTM，seq2seq - 注意力机制--Attention，Transformer - 优化算法--SGD，Momentum，Adam - 高性能计算--并行，多GPU，分布式 - 计算机视觉--目标检测，语义分割 - 自然语言处理--词嵌入，BERT 深度学习有哪些技术 如何实现和调参 背后的原因（直觉、数学）","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"深度学习-2","slug":"深度学习-2","date":"2021-09-15T06:10:33.000Z","updated":"2023-04-26T11:19:54.808Z","comments":true,"path":"posts/42044/","link":"","permalink":"https://ye2222.github.io/posts/42044/","excerpt":"","text":"线性代数 torch.tensor() 构建张量 torch.tensor([3.0]) 标量由只有一个元素的张量来表示 torch.arange() torch.arange(4): tensor([0, 1, 2, 3]) 向量可视为标量值组成的列表 用张量的索引访问任一元素 len(x)：张量的长度 x.shape：张量的形状 torch.arange(20).reshape(5, 4) 构建m x n的矩阵 矩阵的转置 A.T 对称矩阵等于其转置 torch.arange(24).reshape(2, 3, 4) 更多轴的数据结构 clone() 克隆 哈达玛积：两个矩阵的按元素乘法 A * B，两个矩阵中的对应位置的元素相乘 得到的是一个矩阵 求和 计算矩阵中元素的和 sum() 指定轴进行求和 A.sum(axis = 0) A.sum(axis = 1) A.sum(axis = [0, 1]) 平均值 mean() 指定列进行求平均值 A.mean(axis = 0) 计算总和或均值时保持轴数不变 A.sum(axis = 1, keepdims=True) 通过广播除法 相同轴数的张量相除 A / sum_A sum_A = A.sum(axis = 1, keepdims = True) 某个轴计算A元素的累计总和 A.cumsum(axis = 0) 点积 torch.dot(A, B) 相同位置的按元素乘积的和 矩阵的向量积 torch.mv(A, x) 矩阵-矩阵乘法AB torch.mm(A, B) 范数 L2范数是向量元素平方和的平方根 torch.norm() L1范数是向量元素的绝对值之和 torch.abs(u).sum() 弗罗贝尼乌斯范数（Frobenius norm） 是矩阵元素平方和的平方根 torch.norm(torch.ones((4, 9))) 导数 导数和亚导数 亚导数：将原函数分段 梯度 将导数扩展到向量 粗体是向量，普通为标量 ​ ​ 样例： ​ ​ 扩展到向量对向量的求导 样例： ​ 扩展到矩阵 ​ 向量的链式法则 ​ ​ ​ 符号求导和数值求导 数值求导：用极限的方法 计算图 ​ 自动求导 ​ 前向：从最里面的开始求导 ​ 反向：从最外面的开始求导 总结 前向：执行图，存储中间结果 反向：从相反方向执行图，去除不需要的枝 ​ 复杂度 反向： 计算复杂度：O(n)，n是操作子个数 内存复杂度：O(n)，需要存储正向的所有中间结果 正向： 计算复杂度：O(n)，用来计算一个变量的梯度 内存复杂度：O(1) 自动求导的实现 ​ 存储梯度： x = torch.arange(4.0, requires_grad = True) ​ 梯度：x.grad(默认是None) ​ 反向传播函数：y.backward() ​ 清除之前的梯度：x.grad.zero_() ​ y.detach()，将y视为一个常","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"}],"tags":[]},{"title":"操作系统L3","slug":"操作系统L3","date":"2021-09-13T09:44:26.000Z","updated":"2023-04-26T11:19:54.776Z","comments":true,"path":"posts/9827/","link":"","permalink":"https://ye2222.github.io/posts/9827/","excerpt":"","text":"Process Multiprogramming CPU快速地在进程和进程间切换，每一个运行几十或几百毫秒 在任何时候，CPU只运行一个进程 when the system is booted, many processes are running simultaneously Process Creation 进程创建 事件会造成进程创建 1.System initialization 2.Created by a running process. 3.User request to create a new process 4.Initiation of a batch job Foreground processes：与用户交互并为其执行工作的流程 Background processes ：处理一些传入请求，称为守护进程 daemons。 Process Termination 进程中止 造成进程中止地条件 正常退出（自愿的） 出错退出（自愿的） 严重错误（非自愿） 被其他进程杀死（非自愿） Process state 进程的状态 进程从阻塞状态出来后，会进入等待队列的末尾，等待进入运行状态 Process implement 进程的实现 进程表--process table 操作系统为每个进程维护一个进程表，其中包含一个条目（称为进程控制块 (PCB)）。 process control block 包含了进程状态的重要信息 Context switch 上下文切换 从P1切换到P2的时候，进程P1(Running)会保存在进程P1的PCB中，P2(Ready)会从P2的PCB中重新读取到CPU寄存器中 伪并行：进程之间的快速切换产生了真正并行的假象，称为伪并行。 Pseudo-parallelism Multiprogramming 多道程序设计模型 n个进程，p概率等待 \\[ CPU利用率=1 - p^n \\] Thread 线程 执行线程是可由调度程序独立管理的最小编程指令序列，调度程序通常是操作系统的一部分 can be managed independently by a scheduler 线程和进程的实现在操作系统之间有所不同，但在大多数情况下，线程是进程的一个组件。 a thread is a component of a process 一个进程中可以存在多个线程，并发执行并共享内存等资源，而不同的进程不共享这些资源。特别是，进程的线程在任何给定时间共享其可执行代码及其变量的值。 can exist within one process, executing concurrently and sharing resources 需要线程的原因 响应能力：可以同时完成多个活动。 资源共享：线程共享进程的内存和资源。 经济性：线程很容易创建和销毁。 MP（多处理器）体系结构的利用：线程在多CPU系统上很有用。 单线程进程和多线程进程 Thread Model 线程模型 在一个进程中，一些项目被所有线程共享，一些项目对于每个线程来说是私密的 进程和线程的比较 线程 是轻量级的进程，是CPU利用的基本单位, 一个基本的CPU执行单元 线程包含一个线程ID、一个程序计数器、一组寄存器和一个栈 线程是进程中的一个实体，是被系统独立调度和分派的基本单位 线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。 进程 传统的进程可控制单线程 如果进程有多线程的控制，可以在同一时间进行多个任务 线程是调度执行的最小单位,进程是资源分配的最小单位(如虚拟内存资源) Process：used to group resources together; Thread：the entity scheduled for execution on the CPU 引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量； 而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 POSIX thread POSIX (Portable Operating System Interface) 是一组基于Unix操作系统的标准操作系统接口 在用户空间中实现线程 优点： 快速，灵活的，可扩展 用户级线程包可以在不支持线程的操作系统上实现 允许每个进程有自己定制的调度算法 缺点： 阻塞进程中的所有线程； 多处理器上没有线程级并行。 在内核空间中实现线程 优点： 只阻塞进程中的适当线程; 支持多处理器上的线程级并行 缺点： 线程管理速度慢； 庞大的线程表 混合使用 在内核线程上多路复用用户级线程。 内核只知道内核级线程，并对其进行调度。 更灵活，但更复杂。 System overhead: 系统开销 Cpu utilization: Cpu利用率 System throughput: 系统吞吐量 Check points How many states can a process have? How to create and terminate a process in Windows? What is PCB? What is Context Switch? What are the differences between process and thread？ Solution there are three states: running, block, ready CreateProcess是Windows下用于创建进程的API函数,用来创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件。 第一阶段：打开目标映像文件 第二阶段：创建内核中的进程对象 第三阶段：创建初始线程 第四阶段：通知windows子系统进程csrss.exe进程来对新进程进行管理 第五阶段：启动初始线程 第六阶段：用户空间的初始化和Dll连接 TerminateProcess PCB is process control block, which includes the neccessary information that process needs and the process. 从P1切换到P2的时候，进程P1(Running)会保存在进程P1的PCB中，P2(Ready)会从P2的PCB中重新读取到CPU寄存器中 Thread is the basic unit of CPU utilization and scheduler execution is a part of the process, is the light process can share some resourse of the process with the other threads in the process, but some items are private to each thread Process is the basic unit of resourse ditribution can control single thread or multi thread","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机图形学L2","slug":"计算机图形学L2","date":"2021-09-12T15:38:08.000Z","updated":"2023-04-26T11:19:54.821Z","comments":true,"path":"posts/31675/","link":"","permalink":"https://ye2222.github.io/posts/31675/","excerpt":"","text":"扫描转换(Scan Conversion) 就是几何图元的扫描转换(线段,圆,多边形,椭圆等) 在点阵中找到图元的最优近似点集 从连续的图元到离散像素集合的映射 本质上是一个采样问题 例子：线段(0,0)到(5,3)，最优点集：点到直线上的距离最小 线段扫描转换(Scan conversion of line segments) 平凡算法 缺点：多次乘法运算，取整运算 DDA算法--Digital differential analyzer 缺点：仍然需要取整 Bresenham算法 下一次可选点的约束 当前像素一旦确定，下一个点是有限制的，只能从两个点中选一个 算法只涉及+、-、移位 用于绘图仪、显卡等硬件实现 缩小可选点的范围 从 \\(x = x_0\\)出发，每次增加1 选中的第i个像素点为(\\(\\bar{x}_i, \\bar{y}_i\\)) 第\\(i+1\\)个像素点只能从2个点中选择 (\\(\\bar{x}_i + 1, \\bar{y}_i\\))，(\\(\\bar{x}_i + 1, \\bar{y}_i + 1\\)) 选点判定准则(Criteria) 选择离直线较近的那个像素点，即离\\((x_{i+1}, y_{i+1})\\)较近的点 \\(x_{i+1} = x_i+1\\) \\(y_{i+1} = mx_{i+1} +B = mx_i+m+B\\) 判别准则计算 化简 \\(p_i\\)的迭代公式 \\(p_0\\)的计算 例子 多边形扫描转换(Scan conversion of polygon) 光栅图形的本质：点阵表示 线框多边形物体：只需扫描转换线段 填充多边形物体：要扫描转换多边形 线框图：先扫描转换 简单的多边形：无自相交 图形学中多边形的两种表示方法 顶点表示（对象表示）:多边形的有序顶点序列 优点：直观,有几何意义、便于几何变换、存贮量小 缺点：不能直接用于多边形着色 点阵表示（图像表示）:多边形内部的像素集合 区域填充--Fill-area algorithms 多边形描线填充算法--Scan-line polygon-fill algorithm","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"课程笔记/图形学","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[]},{"title":"计算机图形学L1","slug":"计算机图形学L1","date":"2021-09-11T08:43:56.000Z","updated":"2023-04-26T11:19:54.819Z","comments":true,"path":"posts/31483/","link":"","permalink":"https://ye2222.github.io/posts/31483/","excerpt":"LCD、CRT","text":"LCD、CRT 光栅显示系统结构 s(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20210911185252515.png) 计算机图形系统的构成 软件 输入设备 输出设备 s(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20210911185423115.png) 视频显示设备简介 图形学基础算法：根据视频显示设备的特性进行设计 液晶显示(Liquid Crystal Display)--LCD 液晶具有各向异性 LCD结构与工作原理：不施加电场，利用电压改变液晶的分子排列顺序，控制光通过，达到显示目的。 不施加电场,光通过 施加电场，光通过受限 彩色LCD 增加了彩色滤光器 背光版发出的是白光,通过滤光片RGB产生彩色。 可视角度 LCD显示器光源经折射和反射后输出时有一定方向性，从大于某个角度（可视角度）观看会产生色彩失真。 120度为选择标准 LCD显示器一般采用荧光背光板 LED显示器采用发光二极管作为背光源 LED显示器是LCD显示器的一种 阴极射线管(Cathode Ray Tube)--CRT s(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20210911190816761.png) 持续时间和分辨率 （Persistence and Resolution） 持续时间:磷涂层被轰击后发光的持续时间（余辉） 长：利于静态复杂图象的显示； 短：利于动画显示 分辨率: CRT荧屏所能显示的不重叠的最大点数称为它的分辨率。 光栅扫描显示（Raster-Scan Display） 大部分采用CRT的显示器都是光栅扫描显示器 s(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20210911191052313.png) s(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20210911191103454.png) 扫描线(Scan line): 屏幕的每一行称为一条扫描线。 像素(pixel, picture elements): 扫描线上的每个点称为一个像素。 刷新缓冲区(Refresh buffer)或帧缓冲区(Frame buffer)与显示区域对应，每个单元保存一个像素的color及其它信息。 例： 1024X1024，每像素24位，则要3M字节帧缓存。 屏幕纵横比(aspect ratio)： 列数/扫描线数。 逐行扫描与隔行扫描 光栅化（Rasterization）和扫描转换（Scan conversion） 如何使光栅图形最完美地逼近实际图形，是光栅图形学的研究内容。 扫描转化算法 确定逼近图形的最佳像素集，并用指定的颜色或灰度设置像素的过程叫做图形的扫描转换。 随机扫描显示(Random-scan display) 彩色CRT显示器 常用彩色CRT显示器是阴罩式CRT显示器 其结构与单色CRT显示器类似，但有不同之处 ￭ 荧光屏的每个象素点由三个磷涂层点构成，分别发红绿蓝三种颜色的光。 ￭ 有三支电子枪分别对应三种颜色的点。 ￭ 在屏幕后有一个荫罩，上面的小孔与每个象素点对应。 ￭ 所看到的色彩是三种颜色混合的结果。 s(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20210911192815303.png) OpenGL 是一个图形库，全称为Open Graphics Library 是应用程序与图形处理的接口 为移植到不同环境形成了一个开放式的OpenGL 功能模块 绘制几何图形 几何变换 颜色和光照 反走样（反混淆） 纹理映射 雾化 图元属性 OpenGL函数 OpenGL核心库函数：opengl32.lib 核心库函数以gl开头 函数名本身往往指出参数个数及类型 OpenGL实用程序库函数：glu.lib 这一部分函数有核心库函数实现，以glu为前缀 可看作是核心库函数的扩展，提供更高级的图形功能 扩展库 核心库函数是设备独立的,与操作系统和硬件无关。 扩展库提供的函数用来扩展窗口系统的功能 OpenGL实用工具包 freeglut (Graphics Library Utility Toolkits) 图形库实用工具包提供与任意屏幕窗口系统进行交互的函数库 独立于屏幕窗口系统 简化应用程序的工作，也方便移植 GLUT库函数以glut为前缀 http://freeglut.sourceforge.net/ Version 3.2.1(Released: 29 September 2019) GLUT函数分类 初始化和创建窗口 s(https://fastly.jsdelivr.net/gh/Ye2222/blogImage@main/images/image-20210911194335915.png) Mode--可以指定显示模式 Mode参数是一个GLUT库中预定义的可能的布尔组合 1：GLUT_RGBA或者GLUT_RGB。指定一个RGBA窗口，这是一个默认的颜色模式 2：GLUT_INDEX。指定颜色索引模式。 还允许你选择单缓冲区或双缓冲区窗口 1：GLUT_SINGLE.单缓冲区窗口。 2：GLUT_BUFFER.双缓冲区窗口，这是产生流畅动画必须选的 特殊缓冲 1：GLUT_ACCUM.累积缓冲区。 2：GLUT_STENCIL.模板缓冲区。 3：GLUT_DEPTH.深度缓冲区。 创建单颜色缓冲区、深度缓冲区的RGB窗口，用“或“（|）操作符来建立。 glutInitDisplayMode(GLUT_RGB|GLUT_SINGLE|GLUT_DEPTH); 处理窗口和接收键盘和鼠标输入 绘制三维物体 后台管理 运行程序","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"课程笔记/图形学","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[]},{"title":"每日一题--4.1","slug":"每日一题-4-1","date":"2021-09-10T02:41:00.000Z","updated":"2023-04-26T11:19:54.802Z","comments":true,"path":"posts/43574/","link":"","permalink":"https://ye2222.github.io/posts/43574/","excerpt":"","text":"表达式计算 一般借助数据结构栈来完成，特别是带有括号的表达式 常见的运算表达式 中缀表达式 操作数① 运算符② 操作数③ 例如 1 + 1 后缀表达式 操作数① 操作数③ 运算符② 例如 1 1 + 求解没有括号的中缀表达式时，可以概括为：遇到乘除立即算，遇到加减先入栈 乘除立即算：把栈顶的元素和当前的元素进行*或者/的计算 加减先入栈：+号将当前数字进栈，-号将当前数的相反数进栈 表达式的难点在于各个操作符的优先级 代码 1234567891011121314151617public int clumsy(int N)&#123; Deque&lt;Integer&gt; t = new LinkedList&lt;&gt;(); t.push(N); int op = 0; for(int i = N - 1; i &gt; 0; i-- )&#123; if(op % 4 == 0) t.push(t.pop() * i); // * 乘 else if(op % 4 == 1) t.push(t.pop() / i); // / 除 else if(op % 4 == 2) t.push(i); // + 加 else t.push(-i); // - 减 op++; &#125; int res = 0; while(!t.isEmpty())&#123; res += t.pop(); &#125; return res;&#125; 复杂度分析 时间复杂度：O(N)。从N到1进栈一次，出栈一次 空间复杂度：O(N)。","categories":[{"name":"每日一题","slug":"每日一题","permalink":"https://ye2222.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[],"author":"GuoYB"},{"title":"正则表达式--1","slug":"正则表达式-1","date":"2021-09-10T01:46:00.000Z","updated":"2023-04-26T11:19:54.800Z","comments":true,"path":"posts/60363/","link":"","permalink":"https://ye2222.github.io/posts/60363/","excerpt":"正则表达式 Regular Expression（regex） 是一种字符串匹配的模式(pattern)，更像是一种逻辑公式","text":"正则表达式 Regular Expression（regex） 是一种字符串匹配的模式(pattern)，更像是一种逻辑公式 可以用来检查一个串是否含有某种子串 配的子串替换 从某个串中取出符合某个条件的子串 语法 java中一些特殊的地方： 在Java中，\\表示：我要插入一个正则表达式的反斜线，所有其后的字符具有特殊的意义 在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。 在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用 简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 ，这也就是为什么表示一位数字的正则表达式是\\\\d，而表示一个普通的反斜杠是 \\\\\\\\ \\\\\\\\预编译会变成\\\\，而这个在正则表达式中就是一个\\的意思 由两种字符构成： 元字符（特殊字符）：表示正则表达式功能的最小单元，如*^$ $：匹配输入字符串的结尾位置 如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '' 或 '。要匹配 $ 字符本身，请使用 $。 ()：标记一个子表达式的开始和结束位置。 *：匹配前面的子表达式零次或多次。 +：匹配前面的子表达式一次或多次 .：匹配除换行符 之外的任何单字符 ？：匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。 ：将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 例如， 'n' 匹配字符 'n'。'' 匹配换行符。序列'\\\\' 匹配\"\\\"，而 '\\('则匹配 \"(\"。 ^：如果不是在方括号内使用，是匹配输入字符串的开始位置；该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。 [：标记一个中括号表达式的开始。 {：标记限定符表达式的开始。 |：指明两项之间的一个选择。 普通字符 []：匹配括号中的所有字符 例如 [aeiou] 匹配字符串 \"google runoob taobao\" 中所有的 e o u a 字母。 [^]：匹配除了括号内字符的所有字符 例如 [^aeiou] 匹配字符串 \"google runoob taobao\" 中除了 e o u a 字母的所有字母。 [-]：表示一个区间 例如[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母 匹配除换行符（、之外的任何单个字符，相等于 [^\\n\\r] []：匹配所有空白符，包括换行 []：匹配任何非空白符 ：匹配字母、数字、下划线 等价于 [A-Za-z0-9_] 数字字符匹配。等效于 [0-9] ：非数字字符匹配。等效于 [^0-9] 匹配一个字边界，即字与空格间的位置。 ：非字边界匹配。 ：匹配由x指明的控制字符 匹配一个换页符。 ：匹配一个换行符。 匹配一个回车符。 匹配一个制表符 匹配一个垂直制表符。 限定符(有6种) *：匹配前面的子表达式零次或多次。等价于{0,} +：匹配前面的子表达式一次或多次。等价于 {1,} ？：匹配前面的子表达式零次或一次。等价于 {0,1} {n}：n 是一个非负整数。匹配确定的 n 次。 {n, }：n 是一个非负整数。至少匹配n 次。 {n,m}：最少匹配 n 次且最多匹配 m 次。请注意在逗号和两个数之间不能有空格。 贪婪和非贪婪： 前提条件：整个表达式匹配成功 贪婪：* +，它们会尽可能地多匹配字符，在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。 就是在整个表达式匹配成功的前提下，尽可能多的匹配。 比如：&lt;div&gt;.*&lt;/div&gt;在适配&lt;/div&gt;后仍然会向后匹配直到末尾 而非贪婪模式：&lt;div&gt;.*?&lt;/div&gt;在适配到&lt;/div&gt;便停止，重新开始从第一个字符开始匹配 非贪婪：可以限定匹配，通过在 *、+ 或 ? 限定符之后放置 ?将表达式转换为\"非贪婪\"表达式或者最小匹配。 例子1：匹配两位数数字： [1-9][0-9]? [1-9][0-9]{0,1} 例子2：匹配h1标签：&lt;h1&gt;RUNOOB-菜鸟教程&lt;/h1&gt; &lt;.*&gt;匹配整个标签 &lt;.*?&gt;匹配&lt;h1&gt;和&lt;\\h1&gt; &lt;\\w+?&gt;匹配&lt;h1&gt; 定位符 定位符使您能够将正则表达式固定到行首或行尾 这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界 ^ 和 $ 分别指字符串的开始与结束，述单词的前或后边界，表示非单词边界。 ^：匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 或 后的位置匹配。 \\(：匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，\\) 还会与 或 前的位置匹配。 匹配一个单词边界，即字与空格间的位置 ：非单词边界匹配 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首： /^Chapter [1-9][0-9]{0,1}$/ 符的位置是非常重要的。 如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如：// 如果它位于字符串的结尾，它在单词的结尾处查找匹配项。如：/ter 关于/b It's a nice day today. 'I' 占一个位置，'t' 占一个位置，所有的单个字符（包括不可见的空白字符）都会占一个位置，这样的位置我给它取个名字叫“显式位置”。 注意：字符与字符之间还有一个位置，例如 'I' 和 't' 之间就有一个位置（没有任何东西），这样的位置我给它取个名字叫“隐式位置”。 “隐式位置”就是 关键！通俗的理解，是“隐式位置”。 “隐式位置” 匹配这样的位置：它的前一个“显式位置”字符和后一个“显式位置”字符不全是 。 匹配a nice：a 选择 用圆括号()将所有选择项括起来 相邻的选择项之间用|分隔 ()捕获分组，会把每个分组里的匹配的值保存起来 多个匹配值可以通过数字n来查看，n是一个数字，表示第n个捕获组的内容 ?=、?&lt;=、?!、?&lt;! 的使用区别 exp1(?=exp2)：查找 exp2 前面的 exp1。 字符：123455runoob123runoob456 正则表达式runoob(?=[]) 匹配数组前面的runoob字符串 (?&lt;=exp2)exp1：查找exp2后面的exp1 字符：123456google123runoob456 正则表达式：(?&lt;=[0-9]+)runoob 匹配数字后面的runoob字符串 exp1(?!exp2)：查找后面不是 exp2 的 exp1 字符：123456google123runoob-456 正则表达式：runoob(?[]+) 匹配后面不是数字的runoob (?&lt;!exp2)exp1：查找前面不是 exp2 的 exp1 字符：123456googlerunoob456 正则表达式：(?&lt;[]+)runoob 匹配前面不是数字的runoob 反向引用 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，就是在java中matcher的group中 所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储 缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。 每个缓冲区都可以使用 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。 例子： Is is the cost of of gasoline going up up? 设计一种方法定位该句子，而不必查找每个单词的相邻重复出现 正则表达式：\"\\\\b(?i)(\\\\w+)\\\\b\\\\s+\\\\1\" \\1 指定第一个子匹配项：要与第一个匹配到的相同 (?i)：忽略大小写 反向引用还可以将通用资源指示符 (URI) 分解为其组件。 例子：将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径： http://www.runoob.com:80/html/html-tutorial.html http www.runoob.com :80 /html/html-tutorial.html","categories":[{"name":"杂学","slug":"杂学","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/"},{"name":"正则表达式","slug":"杂学/正则表达式","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[],"author":"GuoYB"}],"categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://ye2222.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"统计学习方法","slug":"机器学习/统计学习方法","permalink":"https://ye2222.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/categories/Linux/"},{"name":"一个64位的系统","slug":"Linux/一个64位的系统","permalink":"https://ye2222.github.io/categories/Linux/%E4%B8%80%E4%B8%AA64%E4%BD%8D%E7%9A%84%E7%B3%BB%E7%BB%9F/"},{"name":"趣谈Linux操作系统","slug":"Linux/趣谈Linux操作系统","permalink":"https://ye2222.github.io/categories/Linux/%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"李宏毅","slug":"深度学习/李宏毅","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E5%AE%8F%E6%AF%85/"},{"name":"画图","slug":"画图","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/"},{"name":"origin","slug":"画图/origin","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/origin/"},{"name":"hexo搭建","slug":"hexo搭建","permalink":"https://ye2222.github.io/categories/hexo%E6%90%AD%E5%BB%BA/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"课程笔记/操作系统","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"杂学","slug":"杂学","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/"},{"name":"Git","slug":"杂学/Git","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/Git/"},{"name":"计算机网络","slug":"课程笔记/计算机网络","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"图形学","slug":"课程笔记/图形学","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"软件工程","slug":"课程笔记/软件工程","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"编程语言","slug":"编程语言","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"编程语言/python","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"pandas","slug":"编程语言/python/pandas","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/pandas/"},{"name":"matplotlib","slug":"画图/matplotlib","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/matplotlib/"},{"name":"seaborn","slug":"画图/seaborn","permalink":"https://ye2222.github.io/categories/%E7%94%BB%E5%9B%BE/seaborn/"},{"name":"数据分析","slug":"数据分析","permalink":"https://ye2222.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"论文","slug":"论文","permalink":"https://ye2222.github.io/categories/%E8%AE%BA%E6%96%87/"},{"name":"numpy","slug":"编程语言/python/numpy","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/numpy/"},{"name":"语音","slug":"论文/语音","permalink":"https://ye2222.github.io/categories/%E8%AE%BA%E6%96%87/%E8%AF%AD%E9%9F%B3/"},{"name":"OpenGL","slug":"课程笔记/OpenGL","permalink":"https://ye2222.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/OpenGL/"},{"name":"vim","slug":"杂学/vim","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/vim/"},{"name":"李沐","slug":"深度学习/李沐","permalink":"https://ye2222.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9D%8E%E6%B2%90/"},{"name":"Go","slug":"编程语言/Go","permalink":"https://ye2222.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/"},{"name":"每日一题","slug":"每日一题","permalink":"https://ye2222.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"正则表达式","slug":"杂学/正则表达式","permalink":"https://ye2222.github.io/categories/%E6%9D%82%E5%AD%A6/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ye2222.github.io/tags/Linux/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://ye2222.github.io/tags/DeepLearning/"},{"name":"origin","slug":"origin","permalink":"https://ye2222.github.io/tags/origin/"},{"name":"hexo","slug":"hexo","permalink":"https://ye2222.github.io/tags/hexo/"},{"name":"课程:操作系统","slug":"课程-操作系统","permalink":"https://ye2222.github.io/tags/%E8%AF%BE%E7%A8%8B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Git","slug":"Git","permalink":"https://ye2222.github.io/tags/Git/"},{"name":"python","slug":"python","permalink":"https://ye2222.github.io/tags/python/"},{"name":"Go","slug":"Go","permalink":"https://ye2222.github.io/tags/Go/"},{"name":"英语","slug":"英语","permalink":"https://ye2222.github.io/tags/%E8%8B%B1%E8%AF%AD/"}]}