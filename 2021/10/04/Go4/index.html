<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flat-top.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ye2222.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第四章：复合数据类型">
<meta property="og:type" content="article">
<meta property="og:title" content="Go4">
<meta property="og:url" content="https://ye2222.github.io/2021/10/04/Go4/index.html">
<meta property="og:site_name" content="Yeの博客">
<meta property="og:description" content="第四章：复合数据类型">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-04T13:14:16.000Z">
<meta property="article:modified_time" content="2022-05-05T02:04:04.440Z">
<meta property="article:author" content="GuoYB">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ye2222.github.io/2021/10/04/Go4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Go4 | Yeの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <!-- <div class="headband"></div> -->
    <a target="_blank" rel="noopener" href="https://github.com/Ye2222" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yeの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">28</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">96</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ye2222.github.io/2021/10/04/Go4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.gif">
      <meta itemprop="name" content="GuoYB">
      <meta itemprop="description" content="欢迎欢迎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-04 21:14:16" itemprop="dateCreated datePublished" datetime="2021-10-04T21:14:16+08:00">2021-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-05 10:04:04" itemprop="dateModified" datetime="2022-05-05T10:04:04+08:00">2022-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">第四章：复合数据类型</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2><span id="41-数组">4.1. 数组</span></h2><ul>
<li>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。</li>
<li>Go语言中很少直接使用数组，因为数组的长度是固定的</li>
<li><p>和数组对应的类型是<strong>Slice（切片）</strong>，它是<strong>可以增长和收缩的动态序列</strong>，slice功能也更灵活，</p>
<ul>
<li>但是要理解slice工作原理的话需要先理解数组</li>
</ul>
</li>
<li><p>创建数组和切片的直接区别：定义了长度</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="keyword">int</span> <span class="comment">// 切片</span></span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> y = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 数组</span></span><br></pre></td></tr></table></figure>
<h4><span id="数组">数组</span></h4><ul>
<li>数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。</li>
<li>内置的len函数将返回数组中元素的个数。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span>             <span class="comment">// array of 3 integers</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>])        <span class="comment">// print the first element</span></span><br><span class="line">fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>]) <span class="comment">// print the last element, a[2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the indices and elements.</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the elements only.</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="数组的初始化">数组的初始化</span></h4><ul>
<li>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。</li>
<li>可以使用数组字面值语法用一组值来初始化数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// &quot;0&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在数组字面值中，如果在数组的长度位置出现的是<strong>“…”省略号</strong>，则表示数组的长度是根据初始化值的个数来计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, q) <span class="comment">// &quot;[3]int&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以指定一个索引和对应值列表的方式初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Currency <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    USD Currency = <span class="literal">iota</span> <span class="comment">// 美元</span></span><br><span class="line">    EUR                 <span class="comment">// 欧元</span></span><br><span class="line">    GBP                 <span class="comment">// 英镑</span></span><br><span class="line">    RMB                 <span class="comment">// 人民币</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">symbol := [...]<span class="keyword">string</span>&#123;USD: <span class="string">&quot;$&quot;</span>, EUR: <span class="string">&quot;€&quot;</span>, GBP: <span class="string">&quot;￡&quot;</span>, RMB: <span class="string">&quot;￥&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(RMB, symbol[RMB]) <span class="comment">// &quot;3 ￥&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>未指定初始值的元素将用零值初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>
<h4><span id="数组的长度">数组的长度</span></h4><ul>
<li>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型</li>
<li>数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">q = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// compile error: cannot assign [4]int to [3]int</span></span><br></pre></td></tr></table></figure>
<h4><span id="数组的比较">数组的比较</span></h4><ul>
<li>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的</li>
<li>这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的</li>
<li>不相等比较运算符!=遵循同样的规则</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">c := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(a == b, a == c, b == c) <span class="comment">// &quot;true false false&quot;</span></span><br><span class="line">d := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(a == d) <span class="comment">// compile error: cannot compare [2]int == [3]int</span></span><br></pre></td></tr></table></figure>
<h5><span id="例子">例子</span></h5><p>crypto/sha256包的Sum256函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应[32]byte数组类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := sha256.Sum256([]<span class="keyword">byte</span>(<span class="string">&quot;x&quot;</span>))</span><br><span class="line">    c2 := sha256.Sum256([]<span class="keyword">byte</span>(<span class="string">&quot;X&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x\n%x\n%t\n%T\n&quot;</span>, c1, c2, c1 == c2, c1)</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span></span><br><span class="line">    <span class="comment">// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// [32]uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ptr &#123;</span><br><span class="line">        ptr[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    *ptr = [<span class="number">32</span>]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="42-slice">4.2. Slice</span></h2><ul>
<li>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型</li>
<li>一个slice类型一般写作[]T，其中T代表slice中元素的类型；</li>
<li>slice的语法和数组很像，只是没有固定长度而已</li>
<li>一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象</li>
</ul>
<h4><span id="slice的构成">slice的构成</span></h4><ul>
<li>一个slice由三个部分构成：指针、长度和容量。</li>
<li>指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。</li>
<li>长度对应slice中元素的数目；长度不能超过容量，</li>
<li>容量一般是从slice的开始位置到底层数据的结尾位置。</li>
<li>内置的len和cap函数分别返回slice的长度和容量</li>
</ul>
<p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</p>
<h4><span id="切片">切片</span></h4><ul>
<li>slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。</li>
<li>新的slice将只有j-i个元素。</li>
<li><p>如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替</p>
</li>
<li><p>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;January&quot;</span>, <span class="comment">/* ... */</span>, <span class="number">12</span>: <span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">Q2 := months[<span class="number">4</span>:<span class="number">7</span>]</span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(Q2)     <span class="comment">// [&quot;April&quot; &quot;May&quot; &quot;June&quot;]</span></span><br><span class="line">fmt.Println(summer) <span class="comment">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> summer &#123;</span><br><span class="line">    <span class="keyword">for</span> _, q := <span class="keyword">range</span> Q2 &#123;</span><br><span class="line">        <span class="keyword">if</span> s == q &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s appears in both\n&quot;</span>, s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(summer[:<span class="number">20</span>]) <span class="comment">// panic: out of range</span></span><br><span class="line"></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="comment">// extend a slice (within capacity)</span></span><br><span class="line">fmt.Println(endlessSummer)  <span class="comment">// &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure>
<h4><span id="字符串和byte的切片">字符串和[]byte的切片</span></h4><ul>
<li>字符串的切片操作和[]byte字节类型切片的切片操作是类似的。</li>
<li>都写作x[m:n]</li>
<li>并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度</li>
<li><p>x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte</p>
</li>
<li><p>换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名</p>
</li>
</ul>
<h4><span id="例子">例子</span></h4><p>reverse函数在原内存空间将[]int类型的slice反转，而且它可以用于任意长度的slice</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverse reverses a slice of ints in place.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">reverse(a[:])</span><br><span class="line">fmt.Println(a) <span class="comment">// &quot;[5 4 3 2 1 0]&quot;</span></span><br></pre></td></tr></table></figure>
<p>一种将slice元素循环向左旋转n个元素的方法是三次调用reverse反转函数，第一次是反转开头的n个元素，然后是反转剩下的元素，最后是反转整个slice的元素。（如果是向右循环旋转，则将第三个函数调用移到第一个调用位置就可以了。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// Rotate s left by two positions.</span></span><br><span class="line">reverse(s[:<span class="number">2</span>])</span><br><span class="line">reverse(s[<span class="number">2</span>:])</span><br><span class="line">reverse(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// &quot;[2 3 4 5 0 1]&quot;</span></span><br></pre></td></tr></table></figure>
<h4><span id="切片的初始化">切片的初始化</span></h4><ul>
<li>slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，</li>
<li>但是对于slice并没有指明序列的长度。</li>
<li>这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。</li>
<li>slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化</li>
</ul>
<h4><span id="切片的比较">切片的比较</span></h4><ul>
<li><strong>slice之间不能比较</strong>，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素</li>
<li>标准库<strong>提供</strong>了高度优化的<strong>bytes.Equal函数来判断两个字节型slice是否相等</strong>（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(x, y []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x) != <span class="built_in">len</span>(y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> x &#123;</span><br><span class="line">        <span class="keyword">if</span> x[i] != y[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为何slice不直接支持比较运算符呢</p>
<ul>
<li><p>第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身，虽然有很多办法处理这种情形，但是没有一个是简单有效的。</p>
<ul>
<li>当slice声明为[]interface{}时，slice的元素可以是自身</li>
</ul>
</li>
<li><p>第二个原因，因为slice的元素是间接引用的，一个固定的slice值（注：指slice本身的值，不是元素的值）在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改</p>
<ul>
<li>例如Go语言中map的key只做简单的浅拷贝，它要求key在整个生命周期内保持不变性<ul>
<li>例如slice扩容，就会导致其本身的值/地址变化</li>
</ul>
</li>
<li>而用深度相等判断的话，显然在map的key这种场合不合适。对于像指针或chan之类的引用类型，==相等测试可以判断两个是否是引用相同的对象</li>
<li>一个针对slice的浅相等测试的==操作符可能是有一定用处的，也能临时解决map类型的key问题</li>
<li>但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作</li>
</ul>
</li>
</ul>
<h5><span id="slice唯一合法的比较操作是和nil比较">slice唯一合法的比较操作是和nil比较</span></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> summer == <span class="literal">nil</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个零值的slice等于nil。</li>
<li>一个nil值的slice并没有底层数组。</li>
<li>一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。</li>
<li>与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>如果你需要测试一个slice是否是空的，使用len(s) == 0来判断</strong>，而不应该用s == nil来判断。</li>
<li>除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样</li>
<li>除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。</li>
</ul>
<h4><span id="make函数创建slice">make函数创建slice</span></h4><ul>
<li>内置的make函数创建一个指定元素类型、长度和容量的slice</li>
<li>容量部分可以省略，在这种情况下，容量将等于长度。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。</li>
<li>在第一种语句中，slice是整个数组的view。</li>
<li>在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。</li>
</ul>
<h4><span id="slice的索引">slice的索引</span></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo_8.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sli := [] <span class="keyword">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[0:3] ==&quot;</span>, sli[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(sli[<span class="number">0</span>:<span class="number">3</span>]),<span class="built_in">cap</span>(sli[<span class="number">0</span>:<span class="number">3</span>]),sli[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[0:3:4] ==&quot;</span>, sli[<span class="number">0</span>:<span class="number">3</span>:<span class="number">4</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(sli[<span class="number">0</span>:<span class="number">3</span>:<span class="number">4</span>]),<span class="built_in">cap</span>(sli[<span class="number">0</span>:<span class="number">3</span>:<span class="number">4</span>]),sli[<span class="number">0</span>:<span class="number">3</span>:<span class="number">4</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sli[0:3] == [1 2 3]</span></span><br><span class="line"><span class="comment">// len=3 cap=6 slice=[1 2 3]</span></span><br><span class="line"><span class="comment">// sli[0:3:5] == [1 2 3]</span></span><br><span class="line"><span class="comment">// len=3 cap=4 slice=[1 2 3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述切片方式中</p>
<ul>
<li>第一种：s[i:j]：从i截取到j</li>
<li>第二种：s[i:j:k]：从i截取到j，容量为k</li>
</ul>
<h3><span id="421-append函数">4.2.1. append函数</span></h3><p>内置的append函数用于向slice追加元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="keyword">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">    runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, runes) <span class="comment">// &quot;[&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;,&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>
<p>对应这个特殊的问题我们可以通过Go语言内置的[]rune(“Hello, 世界”)转换操作完成。</p>
<p>append函数对于理解slice底层是如何工作的非常重要，所以让我们仔细查看究竟是发生了什么</p>
<h4><span id="实现appendint函数">实现appendInt函数</span></h4><p>专门用于处理[]int类型的slice</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="keyword">int</span>, y <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z []<span class="keyword">int</span></span><br><span class="line">    zlen := <span class="built_in">len</span>(x) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">        <span class="comment">// There is room to grow.  Extend the slice.</span></span><br><span class="line">        z = x[:zlen]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There is insufficient space.  Allocate a new array.</span></span><br><span class="line">        <span class="comment">// Grow by doubling, for amortized linear complexity.</span></span><br><span class="line">        zcap := zlen</span><br><span class="line">        <span class="keyword">if</span> zcap &lt; <span class="number">2</span>*<span class="built_in">len</span>(x) &#123;</span><br><span class="line">            zcap = <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">        &#125;</span><br><span class="line">        z = <span class="built_in">make</span>([]<span class="keyword">int</span>, zlen, zcap)</span><br><span class="line">        <span class="built_in">copy</span>(z, x) <span class="comment">// a built-in function; see text</span></span><br><span class="line">    &#125;</span><br><span class="line">    z[<span class="built_in">len</span>(x)] = y</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次调用appendInt函数，必须先检测slice底层数组是否有足够的容量来保存新添加的元素。</li>
<li><p>如果有足够空间的话，直接扩展slice（依然在原有的底层数组之上），将新添加的y元素复制到新扩展的空间，并返回slice。因此，输入的x和输出的z共享相同的底层数组。<strong>（line 4~6）</strong></p>
</li>
<li><p>如果没有足够的增长空间的话，appendInt函数则会先分配一个足够大的slice用于保存新的结果，先将输入的x复制到新的空间，然后添加y元素。结果z和输入的x引用的将是不同的底层数组。<strong>（line10~15）</strong></p>
</li>
<li><p>内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。</p>
<ul>
<li>copy函数的第一个参数是要复制的目标slice</li>
<li>第二个参数是源slice</li>
<li>目标和源的位置顺序和<code>dst = src</code>赋值语句是一致的。</li>
<li>两个slice可以共享同一个底层数组，甚至有重叠也没有问题。</li>
<li>copy函数将返回成功复制的元素的个数（我们这里没有用到），等于两个slice中较小的长度，所以我们不用担心覆盖会超出目标slice的范围。</li>
</ul>
</li>
<li><p>为了提高内存使用效率，新分配的数组一般略大于保存x和y所需要的最低大小。</p>
<ul>
<li>通过在每次扩展数组时直接将长度翻倍从而避免了多次内存分配，也确保了添加单个元素操的平均时间是一个常数时间</li>
</ul>
</li>
</ul>
<h5><span id="通常是将append返回的结果直接赋值给输入的slice变量的原因">通常是将append返回的结果直接赋值给输入的slice变量的原因</span></h5><ul>
<li>内置的append函数可能使用比appendInt更复杂的内存扩展策略。</li>
<li>因此，通常我们并不知道append调用是否导致了内存的重新分配</li>
<li>因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。</li>
<li>同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runes = <span class="built_in">append</span>(runes, r)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>要正确地使用slice，需要记住<strong>尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的</strong>。</p>
</li>
<li><p>要更新这些信息需要像上面例子那样一个显式的赋值操作。</p>
</li>
<li>从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">    ptr      *<span class="keyword">int</span></span><br><span class="line">    <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="改进appendint函数追加多个数">改进appendint函数—追加多个数</span></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="keyword">int</span>, y ...<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z []<span class="keyword">int</span></span><br><span class="line">    zlen := <span class="built_in">len</span>(x) + <span class="built_in">len</span>(y)</span><br><span class="line">    <span class="comment">// ...expand z to at least zlen...</span></span><br><span class="line">    <span class="built_in">copy</span>(z[<span class="built_in">len</span>(x):], y)</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="422-slice内存技巧">4.2.2. Slice内存技巧</span></h3><p>下面的nonempty函数将在原有slice内存空间之上返回不包含空字符串的列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nonempty is an example of an in-place slice algorithm.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nonempty returns a slice holding only the non-empty strings.</span></span><br><span class="line"><span class="comment">// The underlying array is modified during the call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonempty</span><span class="params">(strings []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">        <span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            strings[i] = s</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings[:i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较微妙的地方是，输入的slice和输出的slice共享一个底层数组。</p>
<p>这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, nonempty(data)) <span class="comment">// `[&quot;one&quot; &quot;three&quot;]`</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, data)           <span class="comment">// `[&quot;one&quot; &quot;three&quot; &quot;three&quot;]`</span></span><br></pre></td></tr></table></figure>
<p>nonempty函数也可以使用append函数实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonempty2</span><span class="params">(strings []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    out := strings[:<span class="number">0</span>] <span class="comment">// zero-length slice of original</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">        <span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            out = <span class="built_in">append</span>(out, s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无论如何实现，以这种方式重用一个slice一般都要求最多为每个输入值产生一个输出值，事实上很多这类算法都是用来过滤或合并序列中相邻的元素。</li>
<li>这种slice用法是比较复杂的技巧，虽然使用到了slice的一些技巧，但是对于某些场合是比较清晰和有效的。</li>
</ul>
<h4><span id="用slice模拟stack">用slice模拟stack</span></h4><p>一个slice可以用来模拟一个stack。</p>
<p>最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = <span class="built_in">append</span>(stack, v) <span class="comment">// push v</span></span><br></pre></td></tr></table></figure>
<p>stack的顶部位置对应slice的最后一个元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// top of stack</span></span><br></pre></td></tr></table></figure>
<p>通过收缩stack可以弹出栈顶的元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// pop</span></span><br></pre></td></tr></table></figure>
<h4><span id="删除slice中的元素">删除slice中的元素</span></h4><p>要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="built_in">copy</span>(slice[i:], slice[i+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(remove(s, <span class="number">2</span>)) <span class="comment">// &quot;[5 6 8 9]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    slice[i] = slice[<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(remove(s, <span class="number">2</span>)) <span class="comment">// &quot;[5 6 9 8]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="练习">练习</span></h4><p><strong>练习 4.3：</strong> 重写reverse函数，使用数组指针代替slice。</p>
<p><strong>练习 4.4：</strong> 编写一个rotate函数，通过一次循环完成旋转。</p>
<p><strong>练习 4.5：</strong> 写一个函数在原地完成消除[]string中相邻重复的字符串的操作。</p>
<p><strong>练习 4.6：</strong> 编写一个函数，原地将一个UTF-8编码的[]byte类型的slice中相邻的空格（参考unicode.IsSpace）替换成一个空格返回</p>
<p><strong>练习 4.7：</strong> 修改reverse函数用于原地反转UTF-8编码的[]byte。是否可以不用分配额外的内存？</p>
<h2><span id="43-map">4.3. Map</span></h2><ul>
<li>哈希表是一种巧妙并且实用的数据结构。</li>
<li>它是一个<strong>无序的key/value对的集合</strong>，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</li>
<li>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value</li>
<li>map中<strong>所有的key都有相同的类型，所有的value也有着相同的类型</strong>，但是key和value之间可以是不同的数据类型<ul>
<li>key必须是支持==比较运算符的数据类型、</li>
</ul>
</li>
</ul>
<h4><span id="创建一个map">创建一个Map</span></h4><h5><span id="使用make函数">使用make函数</span></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure>
<h5><span id="使用map字面量可指定一些最初的keyvalue">使用map字面量，可指定一些最初的key/value</span></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">31</span></span><br><span class="line">ages[<span class="string">&quot;charlie&quot;</span>] = <span class="number">34</span></span><br></pre></td></tr></table></figure>
<h5><span id="另外一种创建方法">另外一种创建方法</span></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="map元素">Map元素</span></h4><h5><span id="访问">访问</span></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">32</span></span><br><span class="line">fmt.Println(ages[<span class="string">&quot;alice&quot;</span>]) <span class="comment">// &quot;32&quot;</span></span><br></pre></td></tr></table></figure>
<h5><span id="删除">删除</span></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">32</span></span><br><span class="line">fmt.Println(ages[<span class="string">&quot;alice&quot;</span>]) <span class="comment">// &quot;32&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>所有这些操作是安全的，即使<strong>这些元素不在map中也没有关系</strong></li>
<li><p>如果一个查找失败将返回value类型对应的零值</p>
</li>
<li><p><code>x += y</code>和<code>x++</code>等简短赋值语法也可以用在map上</p>
</li>
<li>map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = &amp;ages[<span class="string">&quot;bob&quot;</span>] <span class="comment">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure>
<h4><span id="遍历map中所有元素">遍历map中所有元素</span></h4><h5><span id="可以使用range风格的for循环无序">可以使用range风格的for循环（无序）</span></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。</li>
<li>在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/04/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/" rel="prev" title="Go依赖管理">
      <i class="fa fa-chevron-left"></i> Go依赖管理
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-11/" rel="next" title="深度学习-11">
      深度学习-11 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GuoYB"
      src="/images/avatar1.gif">
  <p class="site-author-name" itemprop="name">GuoYB</p>
  <div class="site-description" itemprop="description">欢迎欢迎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ye2222" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ye2222" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:12554804@qq.com" title="E-Mail → mailto:12554804@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GuoYB</span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://fastly.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
